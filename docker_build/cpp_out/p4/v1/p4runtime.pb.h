// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: p4/v1/p4runtime.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_p4_2fv1_2fp4runtime_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_p4_2fv1_2fp4runtime_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include "google/rpc/status.pb.h"
#include "p4/config/v1/p4info.pb.h"
#include "p4/v1/p4data.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_p4_2fv1_2fp4runtime_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_p4_2fv1_2fp4runtime_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[80]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_p4_2fv1_2fp4runtime_2eproto;
namespace p4 {
namespace v1 {
class Action;
struct ActionDefaultTypeInternal;
extern ActionDefaultTypeInternal _Action_default_instance_;
class ActionProfileAction;
struct ActionProfileActionDefaultTypeInternal;
extern ActionProfileActionDefaultTypeInternal _ActionProfileAction_default_instance_;
class ActionProfileActionSet;
struct ActionProfileActionSetDefaultTypeInternal;
extern ActionProfileActionSetDefaultTypeInternal _ActionProfileActionSet_default_instance_;
class ActionProfileGroup;
struct ActionProfileGroupDefaultTypeInternal;
extern ActionProfileGroupDefaultTypeInternal _ActionProfileGroup_default_instance_;
class ActionProfileGroup_Member;
struct ActionProfileGroup_MemberDefaultTypeInternal;
extern ActionProfileGroup_MemberDefaultTypeInternal _ActionProfileGroup_Member_default_instance_;
class ActionProfileMember;
struct ActionProfileMemberDefaultTypeInternal;
extern ActionProfileMemberDefaultTypeInternal _ActionProfileMember_default_instance_;
class Action_Param;
struct Action_ParamDefaultTypeInternal;
extern Action_ParamDefaultTypeInternal _Action_Param_default_instance_;
class CapabilitiesRequest;
struct CapabilitiesRequestDefaultTypeInternal;
extern CapabilitiesRequestDefaultTypeInternal _CapabilitiesRequest_default_instance_;
class CapabilitiesResponse;
struct CapabilitiesResponseDefaultTypeInternal;
extern CapabilitiesResponseDefaultTypeInternal _CapabilitiesResponse_default_instance_;
class ChangeConditionalEntry;
struct ChangeConditionalEntryDefaultTypeInternal;
extern ChangeConditionalEntryDefaultTypeInternal _ChangeConditionalEntry_default_instance_;
class ChangeFlexEntry;
struct ChangeFlexEntryDefaultTypeInternal;
extern ChangeFlexEntryDefaultTypeInternal _ChangeFlexEntry_default_instance_;
class ChangeInitEntry;
struct ChangeInitEntryDefaultTypeInternal;
extern ChangeInitEntryDefaultTypeInternal _ChangeInitEntry_default_instance_;
class ChangeRegisterArrayEntry;
struct ChangeRegisterArrayEntryDefaultTypeInternal;
extern ChangeRegisterArrayEntryDefaultTypeInternal _ChangeRegisterArrayEntry_default_instance_;
class ChangeTableEntry;
struct ChangeTableEntryDefaultTypeInternal;
extern ChangeTableEntryDefaultTypeInternal _ChangeTableEntry_default_instance_;
class CloneSessionEntry;
struct CloneSessionEntryDefaultTypeInternal;
extern CloneSessionEntryDefaultTypeInternal _CloneSessionEntry_default_instance_;
class CounterData;
struct CounterDataDefaultTypeInternal;
extern CounterDataDefaultTypeInternal _CounterData_default_instance_;
class CounterEntry;
struct CounterEntryDefaultTypeInternal;
extern CounterEntryDefaultTypeInternal _CounterEntry_default_instance_;
class DeleteConditionalEntry;
struct DeleteConditionalEntryDefaultTypeInternal;
extern DeleteConditionalEntryDefaultTypeInternal _DeleteConditionalEntry_default_instance_;
class DeleteFlexEntry;
struct DeleteFlexEntryDefaultTypeInternal;
extern DeleteFlexEntryDefaultTypeInternal _DeleteFlexEntry_default_instance_;
class DeleteRegisterArrayEntry;
struct DeleteRegisterArrayEntryDefaultTypeInternal;
extern DeleteRegisterArrayEntryDefaultTypeInternal _DeleteRegisterArrayEntry_default_instance_;
class DeleteTableEntry;
struct DeleteTableEntryDefaultTypeInternal;
extern DeleteTableEntryDefaultTypeInternal _DeleteTableEntry_default_instance_;
class DigestEntry;
struct DigestEntryDefaultTypeInternal;
extern DigestEntryDefaultTypeInternal _DigestEntry_default_instance_;
class DigestEntry_Config;
struct DigestEntry_ConfigDefaultTypeInternal;
extern DigestEntry_ConfigDefaultTypeInternal _DigestEntry_Config_default_instance_;
class DigestList;
struct DigestListDefaultTypeInternal;
extern DigestListDefaultTypeInternal _DigestList_default_instance_;
class DigestListAck;
struct DigestListAckDefaultTypeInternal;
extern DigestListAckDefaultTypeInternal _DigestListAck_default_instance_;
class DigestListAckError;
struct DigestListAckErrorDefaultTypeInternal;
extern DigestListAckErrorDefaultTypeInternal _DigestListAckError_default_instance_;
class DirectCounterEntry;
struct DirectCounterEntryDefaultTypeInternal;
extern DirectCounterEntryDefaultTypeInternal _DirectCounterEntry_default_instance_;
class DirectMeterEntry;
struct DirectMeterEntryDefaultTypeInternal;
extern DirectMeterEntryDefaultTypeInternal _DirectMeterEntry_default_instance_;
class Entity;
struct EntityDefaultTypeInternal;
extern EntityDefaultTypeInternal _Entity_default_instance_;
class Error;
struct ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class ExternEntry;
struct ExternEntryDefaultTypeInternal;
extern ExternEntryDefaultTypeInternal _ExternEntry_default_instance_;
class FieldMatch;
struct FieldMatchDefaultTypeInternal;
extern FieldMatchDefaultTypeInternal _FieldMatch_default_instance_;
class FieldMatch_Exact;
struct FieldMatch_ExactDefaultTypeInternal;
extern FieldMatch_ExactDefaultTypeInternal _FieldMatch_Exact_default_instance_;
class FieldMatch_LPM;
struct FieldMatch_LPMDefaultTypeInternal;
extern FieldMatch_LPMDefaultTypeInternal _FieldMatch_LPM_default_instance_;
class FieldMatch_Optional;
struct FieldMatch_OptionalDefaultTypeInternal;
extern FieldMatch_OptionalDefaultTypeInternal _FieldMatch_Optional_default_instance_;
class FieldMatch_Range;
struct FieldMatch_RangeDefaultTypeInternal;
extern FieldMatch_RangeDefaultTypeInternal _FieldMatch_Range_default_instance_;
class FieldMatch_Ternary;
struct FieldMatch_TernaryDefaultTypeInternal;
extern FieldMatch_TernaryDefaultTypeInternal _FieldMatch_Ternary_default_instance_;
class ForwardingPipelineConfig;
struct ForwardingPipelineConfigDefaultTypeInternal;
extern ForwardingPipelineConfigDefaultTypeInternal _ForwardingPipelineConfig_default_instance_;
class ForwardingPipelineConfig_Cookie;
struct ForwardingPipelineConfig_CookieDefaultTypeInternal;
extern ForwardingPipelineConfig_CookieDefaultTypeInternal _ForwardingPipelineConfig_Cookie_default_instance_;
class GetForwardingPipelineConfigRequest;
struct GetForwardingPipelineConfigRequestDefaultTypeInternal;
extern GetForwardingPipelineConfigRequestDefaultTypeInternal _GetForwardingPipelineConfigRequest_default_instance_;
class GetForwardingPipelineConfigResponse;
struct GetForwardingPipelineConfigResponseDefaultTypeInternal;
extern GetForwardingPipelineConfigResponseDefaultTypeInternal _GetForwardingPipelineConfigResponse_default_instance_;
class IdleTimeoutNotification;
struct IdleTimeoutNotificationDefaultTypeInternal;
extern IdleTimeoutNotificationDefaultTypeInternal _IdleTimeoutNotification_default_instance_;
class Index;
struct IndexDefaultTypeInternal;
extern IndexDefaultTypeInternal _Index_default_instance_;
class InitP4ObjectsNewEntry;
struct InitP4ObjectsNewEntryDefaultTypeInternal;
extern InitP4ObjectsNewEntryDefaultTypeInternal _InitP4ObjectsNewEntry_default_instance_;
class InsertConditionalEntry;
struct InsertConditionalEntryDefaultTypeInternal;
extern InsertConditionalEntryDefaultTypeInternal _InsertConditionalEntry_default_instance_;
class InsertFlexEntry;
struct InsertFlexEntryDefaultTypeInternal;
extern InsertFlexEntryDefaultTypeInternal _InsertFlexEntry_default_instance_;
class InsertRegisterArrayEntry;
struct InsertRegisterArrayEntryDefaultTypeInternal;
extern InsertRegisterArrayEntryDefaultTypeInternal _InsertRegisterArrayEntry_default_instance_;
class InsertTableEntry;
struct InsertTableEntryDefaultTypeInternal;
extern InsertTableEntryDefaultTypeInternal _InsertTableEntry_default_instance_;
class MasterArbitrationUpdate;
struct MasterArbitrationUpdateDefaultTypeInternal;
extern MasterArbitrationUpdateDefaultTypeInternal _MasterArbitrationUpdate_default_instance_;
class MeterConfig;
struct MeterConfigDefaultTypeInternal;
extern MeterConfigDefaultTypeInternal _MeterConfig_default_instance_;
class MeterEntry;
struct MeterEntryDefaultTypeInternal;
extern MeterEntryDefaultTypeInternal _MeterEntry_default_instance_;
class MulticastGroupEntry;
struct MulticastGroupEntryDefaultTypeInternal;
extern MulticastGroupEntryDefaultTypeInternal _MulticastGroupEntry_default_instance_;
class PacketIn;
struct PacketInDefaultTypeInternal;
extern PacketInDefaultTypeInternal _PacketIn_default_instance_;
class PacketMetadata;
struct PacketMetadataDefaultTypeInternal;
extern PacketMetadataDefaultTypeInternal _PacketMetadata_default_instance_;
class PacketOut;
struct PacketOutDefaultTypeInternal;
extern PacketOutDefaultTypeInternal _PacketOut_default_instance_;
class PacketOutError;
struct PacketOutErrorDefaultTypeInternal;
extern PacketOutErrorDefaultTypeInternal _PacketOutError_default_instance_;
class PacketReplicationEngineEntry;
struct PacketReplicationEngineEntryDefaultTypeInternal;
extern PacketReplicationEngineEntryDefaultTypeInternal _PacketReplicationEngineEntry_default_instance_;
class ReadRequest;
struct ReadRequestDefaultTypeInternal;
extern ReadRequestDefaultTypeInternal _ReadRequest_default_instance_;
class ReadResponse;
struct ReadResponseDefaultTypeInternal;
extern ReadResponseDefaultTypeInternal _ReadResponse_default_instance_;
class RegisterEntry;
struct RegisterEntryDefaultTypeInternal;
extern RegisterEntryDefaultTypeInternal _RegisterEntry_default_instance_;
class Replica;
struct ReplicaDefaultTypeInternal;
extern ReplicaDefaultTypeInternal _Replica_default_instance_;
class Role;
struct RoleDefaultTypeInternal;
extern RoleDefaultTypeInternal _Role_default_instance_;
class RuntimeReconfigContent;
struct RuntimeReconfigContentDefaultTypeInternal;
extern RuntimeReconfigContentDefaultTypeInternal _RuntimeReconfigContent_default_instance_;
class RuntimeReconfigEntry;
struct RuntimeReconfigEntryDefaultTypeInternal;
extern RuntimeReconfigEntryDefaultTypeInternal _RuntimeReconfigEntry_default_instance_;
class SetForwardingPipelineConfigRequest;
struct SetForwardingPipelineConfigRequestDefaultTypeInternal;
extern SetForwardingPipelineConfigRequestDefaultTypeInternal _SetForwardingPipelineConfigRequest_default_instance_;
class SetForwardingPipelineConfigResponse;
struct SetForwardingPipelineConfigResponseDefaultTypeInternal;
extern SetForwardingPipelineConfigResponseDefaultTypeInternal _SetForwardingPipelineConfigResponse_default_instance_;
class StreamError;
struct StreamErrorDefaultTypeInternal;
extern StreamErrorDefaultTypeInternal _StreamError_default_instance_;
class StreamMessageRequest;
struct StreamMessageRequestDefaultTypeInternal;
extern StreamMessageRequestDefaultTypeInternal _StreamMessageRequest_default_instance_;
class StreamMessageResponse;
struct StreamMessageResponseDefaultTypeInternal;
extern StreamMessageResponseDefaultTypeInternal _StreamMessageResponse_default_instance_;
class StreamOtherError;
struct StreamOtherErrorDefaultTypeInternal;
extern StreamOtherErrorDefaultTypeInternal _StreamOtherError_default_instance_;
class TableAction;
struct TableActionDefaultTypeInternal;
extern TableActionDefaultTypeInternal _TableAction_default_instance_;
class TableEntry;
struct TableEntryDefaultTypeInternal;
extern TableEntryDefaultTypeInternal _TableEntry_default_instance_;
class TableEntry_IdleTimeout;
struct TableEntry_IdleTimeoutDefaultTypeInternal;
extern TableEntry_IdleTimeoutDefaultTypeInternal _TableEntry_IdleTimeout_default_instance_;
class TriggerEntry;
struct TriggerEntryDefaultTypeInternal;
extern TriggerEntryDefaultTypeInternal _TriggerEntry_default_instance_;
class Uint128;
struct Uint128DefaultTypeInternal;
extern Uint128DefaultTypeInternal _Uint128_default_instance_;
class Update;
struct UpdateDefaultTypeInternal;
extern UpdateDefaultTypeInternal _Update_default_instance_;
class ValueSetEntry;
struct ValueSetEntryDefaultTypeInternal;
extern ValueSetEntryDefaultTypeInternal _ValueSetEntry_default_instance_;
class ValueSetMember;
struct ValueSetMemberDefaultTypeInternal;
extern ValueSetMemberDefaultTypeInternal _ValueSetMember_default_instance_;
class WriteRequest;
struct WriteRequestDefaultTypeInternal;
extern WriteRequestDefaultTypeInternal _WriteRequest_default_instance_;
class WriteResponse;
struct WriteResponseDefaultTypeInternal;
extern WriteResponseDefaultTypeInternal _WriteResponse_default_instance_;
}  // namespace v1
}  // namespace p4
PROTOBUF_NAMESPACE_OPEN
template<> ::p4::v1::Action* Arena::CreateMaybeMessage<::p4::v1::Action>(Arena*);
template<> ::p4::v1::ActionProfileAction* Arena::CreateMaybeMessage<::p4::v1::ActionProfileAction>(Arena*);
template<> ::p4::v1::ActionProfileActionSet* Arena::CreateMaybeMessage<::p4::v1::ActionProfileActionSet>(Arena*);
template<> ::p4::v1::ActionProfileGroup* Arena::CreateMaybeMessage<::p4::v1::ActionProfileGroup>(Arena*);
template<> ::p4::v1::ActionProfileGroup_Member* Arena::CreateMaybeMessage<::p4::v1::ActionProfileGroup_Member>(Arena*);
template<> ::p4::v1::ActionProfileMember* Arena::CreateMaybeMessage<::p4::v1::ActionProfileMember>(Arena*);
template<> ::p4::v1::Action_Param* Arena::CreateMaybeMessage<::p4::v1::Action_Param>(Arena*);
template<> ::p4::v1::CapabilitiesRequest* Arena::CreateMaybeMessage<::p4::v1::CapabilitiesRequest>(Arena*);
template<> ::p4::v1::CapabilitiesResponse* Arena::CreateMaybeMessage<::p4::v1::CapabilitiesResponse>(Arena*);
template<> ::p4::v1::ChangeConditionalEntry* Arena::CreateMaybeMessage<::p4::v1::ChangeConditionalEntry>(Arena*);
template<> ::p4::v1::ChangeFlexEntry* Arena::CreateMaybeMessage<::p4::v1::ChangeFlexEntry>(Arena*);
template<> ::p4::v1::ChangeInitEntry* Arena::CreateMaybeMessage<::p4::v1::ChangeInitEntry>(Arena*);
template<> ::p4::v1::ChangeRegisterArrayEntry* Arena::CreateMaybeMessage<::p4::v1::ChangeRegisterArrayEntry>(Arena*);
template<> ::p4::v1::ChangeTableEntry* Arena::CreateMaybeMessage<::p4::v1::ChangeTableEntry>(Arena*);
template<> ::p4::v1::CloneSessionEntry* Arena::CreateMaybeMessage<::p4::v1::CloneSessionEntry>(Arena*);
template<> ::p4::v1::CounterData* Arena::CreateMaybeMessage<::p4::v1::CounterData>(Arena*);
template<> ::p4::v1::CounterEntry* Arena::CreateMaybeMessage<::p4::v1::CounterEntry>(Arena*);
template<> ::p4::v1::DeleteConditionalEntry* Arena::CreateMaybeMessage<::p4::v1::DeleteConditionalEntry>(Arena*);
template<> ::p4::v1::DeleteFlexEntry* Arena::CreateMaybeMessage<::p4::v1::DeleteFlexEntry>(Arena*);
template<> ::p4::v1::DeleteRegisterArrayEntry* Arena::CreateMaybeMessage<::p4::v1::DeleteRegisterArrayEntry>(Arena*);
template<> ::p4::v1::DeleteTableEntry* Arena::CreateMaybeMessage<::p4::v1::DeleteTableEntry>(Arena*);
template<> ::p4::v1::DigestEntry* Arena::CreateMaybeMessage<::p4::v1::DigestEntry>(Arena*);
template<> ::p4::v1::DigestEntry_Config* Arena::CreateMaybeMessage<::p4::v1::DigestEntry_Config>(Arena*);
template<> ::p4::v1::DigestList* Arena::CreateMaybeMessage<::p4::v1::DigestList>(Arena*);
template<> ::p4::v1::DigestListAck* Arena::CreateMaybeMessage<::p4::v1::DigestListAck>(Arena*);
template<> ::p4::v1::DigestListAckError* Arena::CreateMaybeMessage<::p4::v1::DigestListAckError>(Arena*);
template<> ::p4::v1::DirectCounterEntry* Arena::CreateMaybeMessage<::p4::v1::DirectCounterEntry>(Arena*);
template<> ::p4::v1::DirectMeterEntry* Arena::CreateMaybeMessage<::p4::v1::DirectMeterEntry>(Arena*);
template<> ::p4::v1::Entity* Arena::CreateMaybeMessage<::p4::v1::Entity>(Arena*);
template<> ::p4::v1::Error* Arena::CreateMaybeMessage<::p4::v1::Error>(Arena*);
template<> ::p4::v1::ExternEntry* Arena::CreateMaybeMessage<::p4::v1::ExternEntry>(Arena*);
template<> ::p4::v1::FieldMatch* Arena::CreateMaybeMessage<::p4::v1::FieldMatch>(Arena*);
template<> ::p4::v1::FieldMatch_Exact* Arena::CreateMaybeMessage<::p4::v1::FieldMatch_Exact>(Arena*);
template<> ::p4::v1::FieldMatch_LPM* Arena::CreateMaybeMessage<::p4::v1::FieldMatch_LPM>(Arena*);
template<> ::p4::v1::FieldMatch_Optional* Arena::CreateMaybeMessage<::p4::v1::FieldMatch_Optional>(Arena*);
template<> ::p4::v1::FieldMatch_Range* Arena::CreateMaybeMessage<::p4::v1::FieldMatch_Range>(Arena*);
template<> ::p4::v1::FieldMatch_Ternary* Arena::CreateMaybeMessage<::p4::v1::FieldMatch_Ternary>(Arena*);
template<> ::p4::v1::ForwardingPipelineConfig* Arena::CreateMaybeMessage<::p4::v1::ForwardingPipelineConfig>(Arena*);
template<> ::p4::v1::ForwardingPipelineConfig_Cookie* Arena::CreateMaybeMessage<::p4::v1::ForwardingPipelineConfig_Cookie>(Arena*);
template<> ::p4::v1::GetForwardingPipelineConfigRequest* Arena::CreateMaybeMessage<::p4::v1::GetForwardingPipelineConfigRequest>(Arena*);
template<> ::p4::v1::GetForwardingPipelineConfigResponse* Arena::CreateMaybeMessage<::p4::v1::GetForwardingPipelineConfigResponse>(Arena*);
template<> ::p4::v1::IdleTimeoutNotification* Arena::CreateMaybeMessage<::p4::v1::IdleTimeoutNotification>(Arena*);
template<> ::p4::v1::Index* Arena::CreateMaybeMessage<::p4::v1::Index>(Arena*);
template<> ::p4::v1::InitP4ObjectsNewEntry* Arena::CreateMaybeMessage<::p4::v1::InitP4ObjectsNewEntry>(Arena*);
template<> ::p4::v1::InsertConditionalEntry* Arena::CreateMaybeMessage<::p4::v1::InsertConditionalEntry>(Arena*);
template<> ::p4::v1::InsertFlexEntry* Arena::CreateMaybeMessage<::p4::v1::InsertFlexEntry>(Arena*);
template<> ::p4::v1::InsertRegisterArrayEntry* Arena::CreateMaybeMessage<::p4::v1::InsertRegisterArrayEntry>(Arena*);
template<> ::p4::v1::InsertTableEntry* Arena::CreateMaybeMessage<::p4::v1::InsertTableEntry>(Arena*);
template<> ::p4::v1::MasterArbitrationUpdate* Arena::CreateMaybeMessage<::p4::v1::MasterArbitrationUpdate>(Arena*);
template<> ::p4::v1::MeterConfig* Arena::CreateMaybeMessage<::p4::v1::MeterConfig>(Arena*);
template<> ::p4::v1::MeterEntry* Arena::CreateMaybeMessage<::p4::v1::MeterEntry>(Arena*);
template<> ::p4::v1::MulticastGroupEntry* Arena::CreateMaybeMessage<::p4::v1::MulticastGroupEntry>(Arena*);
template<> ::p4::v1::PacketIn* Arena::CreateMaybeMessage<::p4::v1::PacketIn>(Arena*);
template<> ::p4::v1::PacketMetadata* Arena::CreateMaybeMessage<::p4::v1::PacketMetadata>(Arena*);
template<> ::p4::v1::PacketOut* Arena::CreateMaybeMessage<::p4::v1::PacketOut>(Arena*);
template<> ::p4::v1::PacketOutError* Arena::CreateMaybeMessage<::p4::v1::PacketOutError>(Arena*);
template<> ::p4::v1::PacketReplicationEngineEntry* Arena::CreateMaybeMessage<::p4::v1::PacketReplicationEngineEntry>(Arena*);
template<> ::p4::v1::ReadRequest* Arena::CreateMaybeMessage<::p4::v1::ReadRequest>(Arena*);
template<> ::p4::v1::ReadResponse* Arena::CreateMaybeMessage<::p4::v1::ReadResponse>(Arena*);
template<> ::p4::v1::RegisterEntry* Arena::CreateMaybeMessage<::p4::v1::RegisterEntry>(Arena*);
template<> ::p4::v1::Replica* Arena::CreateMaybeMessage<::p4::v1::Replica>(Arena*);
template<> ::p4::v1::Role* Arena::CreateMaybeMessage<::p4::v1::Role>(Arena*);
template<> ::p4::v1::RuntimeReconfigContent* Arena::CreateMaybeMessage<::p4::v1::RuntimeReconfigContent>(Arena*);
template<> ::p4::v1::RuntimeReconfigEntry* Arena::CreateMaybeMessage<::p4::v1::RuntimeReconfigEntry>(Arena*);
template<> ::p4::v1::SetForwardingPipelineConfigRequest* Arena::CreateMaybeMessage<::p4::v1::SetForwardingPipelineConfigRequest>(Arena*);
template<> ::p4::v1::SetForwardingPipelineConfigResponse* Arena::CreateMaybeMessage<::p4::v1::SetForwardingPipelineConfigResponse>(Arena*);
template<> ::p4::v1::StreamError* Arena::CreateMaybeMessage<::p4::v1::StreamError>(Arena*);
template<> ::p4::v1::StreamMessageRequest* Arena::CreateMaybeMessage<::p4::v1::StreamMessageRequest>(Arena*);
template<> ::p4::v1::StreamMessageResponse* Arena::CreateMaybeMessage<::p4::v1::StreamMessageResponse>(Arena*);
template<> ::p4::v1::StreamOtherError* Arena::CreateMaybeMessage<::p4::v1::StreamOtherError>(Arena*);
template<> ::p4::v1::TableAction* Arena::CreateMaybeMessage<::p4::v1::TableAction>(Arena*);
template<> ::p4::v1::TableEntry* Arena::CreateMaybeMessage<::p4::v1::TableEntry>(Arena*);
template<> ::p4::v1::TableEntry_IdleTimeout* Arena::CreateMaybeMessage<::p4::v1::TableEntry_IdleTimeout>(Arena*);
template<> ::p4::v1::TriggerEntry* Arena::CreateMaybeMessage<::p4::v1::TriggerEntry>(Arena*);
template<> ::p4::v1::Uint128* Arena::CreateMaybeMessage<::p4::v1::Uint128>(Arena*);
template<> ::p4::v1::Update* Arena::CreateMaybeMessage<::p4::v1::Update>(Arena*);
template<> ::p4::v1::ValueSetEntry* Arena::CreateMaybeMessage<::p4::v1::ValueSetEntry>(Arena*);
template<> ::p4::v1::ValueSetMember* Arena::CreateMaybeMessage<::p4::v1::ValueSetMember>(Arena*);
template<> ::p4::v1::WriteRequest* Arena::CreateMaybeMessage<::p4::v1::WriteRequest>(Arena*);
template<> ::p4::v1::WriteResponse* Arena::CreateMaybeMessage<::p4::v1::WriteResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace p4 {
namespace v1 {

enum WriteRequest_Atomicity : int {
  WriteRequest_Atomicity_CONTINUE_ON_ERROR = 0,
  WriteRequest_Atomicity_ROLLBACK_ON_ERROR = 1,
  WriteRequest_Atomicity_DATAPLANE_ATOMIC = 2,
  WriteRequest_Atomicity_WriteRequest_Atomicity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WriteRequest_Atomicity_WriteRequest_Atomicity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WriteRequest_Atomicity_IsValid(int value);
constexpr WriteRequest_Atomicity WriteRequest_Atomicity_Atomicity_MIN = WriteRequest_Atomicity_CONTINUE_ON_ERROR;
constexpr WriteRequest_Atomicity WriteRequest_Atomicity_Atomicity_MAX = WriteRequest_Atomicity_DATAPLANE_ATOMIC;
constexpr int WriteRequest_Atomicity_Atomicity_ARRAYSIZE = WriteRequest_Atomicity_Atomicity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WriteRequest_Atomicity_descriptor();
template<typename T>
inline const std::string& WriteRequest_Atomicity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WriteRequest_Atomicity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WriteRequest_Atomicity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WriteRequest_Atomicity_descriptor(), enum_t_value);
}
inline bool WriteRequest_Atomicity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WriteRequest_Atomicity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WriteRequest_Atomicity>(
    WriteRequest_Atomicity_descriptor(), name, value);
}
enum Update_Type : int {
  Update_Type_UNSPECIFIED = 0,
  Update_Type_INSERT = 1,
  Update_Type_MODIFY = 2,
  Update_Type_DELETE = 3,
  Update_Type_RUNTIME_RECONFIG = 4,
  Update_Type_Update_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Update_Type_Update_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Update_Type_IsValid(int value);
constexpr Update_Type Update_Type_Type_MIN = Update_Type_UNSPECIFIED;
constexpr Update_Type Update_Type_Type_MAX = Update_Type_RUNTIME_RECONFIG;
constexpr int Update_Type_Type_ARRAYSIZE = Update_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Update_Type_descriptor();
template<typename T>
inline const std::string& Update_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Update_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Update_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Update_Type_descriptor(), enum_t_value);
}
inline bool Update_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Update_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Update_Type>(
    Update_Type_descriptor(), name, value);
}
enum RuntimeReconfigEntry_RuntimeReconfigType : int {
  RuntimeReconfigEntry_RuntimeReconfigType_INIT_P4OBJECTS_NEW = 0,
  RuntimeReconfigEntry_RuntimeReconfigType_INSERT_TABLE = 1,
  RuntimeReconfigEntry_RuntimeReconfigType_CHANGE_TABLE = 2,
  RuntimeReconfigEntry_RuntimeReconfigType_DELETE_TABLE = 3,
  RuntimeReconfigEntry_RuntimeReconfigType_INSERT_CONDITIONAL = 4,
  RuntimeReconfigEntry_RuntimeReconfigType_CHANGE_CONDITIONAL = 5,
  RuntimeReconfigEntry_RuntimeReconfigType_DELETE_CONDITIONAL = 6,
  RuntimeReconfigEntry_RuntimeReconfigType_INSERT_FLEX = 7,
  RuntimeReconfigEntry_RuntimeReconfigType_CHANGE_FLEX = 8,
  RuntimeReconfigEntry_RuntimeReconfigType_DELETE_FLEX = 9,
  RuntimeReconfigEntry_RuntimeReconfigType_INSERT_REGISTER_ARRAY = 10,
  RuntimeReconfigEntry_RuntimeReconfigType_CHANGE_REGISTER_ARRAY = 11,
  RuntimeReconfigEntry_RuntimeReconfigType_DELETE_REGISTER_ARRAY = 12,
  RuntimeReconfigEntry_RuntimeReconfigType_TRIGGER = 13,
  RuntimeReconfigEntry_RuntimeReconfigType_CHANGE_INIT = 14,
  RuntimeReconfigEntry_RuntimeReconfigType_RuntimeReconfigEntry_RuntimeReconfigType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RuntimeReconfigEntry_RuntimeReconfigType_RuntimeReconfigEntry_RuntimeReconfigType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RuntimeReconfigEntry_RuntimeReconfigType_IsValid(int value);
constexpr RuntimeReconfigEntry_RuntimeReconfigType RuntimeReconfigEntry_RuntimeReconfigType_RuntimeReconfigType_MIN = RuntimeReconfigEntry_RuntimeReconfigType_INIT_P4OBJECTS_NEW;
constexpr RuntimeReconfigEntry_RuntimeReconfigType RuntimeReconfigEntry_RuntimeReconfigType_RuntimeReconfigType_MAX = RuntimeReconfigEntry_RuntimeReconfigType_CHANGE_INIT;
constexpr int RuntimeReconfigEntry_RuntimeReconfigType_RuntimeReconfigType_ARRAYSIZE = RuntimeReconfigEntry_RuntimeReconfigType_RuntimeReconfigType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RuntimeReconfigEntry_RuntimeReconfigType_descriptor();
template<typename T>
inline const std::string& RuntimeReconfigEntry_RuntimeReconfigType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RuntimeReconfigEntry_RuntimeReconfigType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RuntimeReconfigEntry_RuntimeReconfigType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RuntimeReconfigEntry_RuntimeReconfigType_descriptor(), enum_t_value);
}
inline bool RuntimeReconfigEntry_RuntimeReconfigType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RuntimeReconfigEntry_RuntimeReconfigType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RuntimeReconfigEntry_RuntimeReconfigType>(
    RuntimeReconfigEntry_RuntimeReconfigType_descriptor(), name, value);
}
enum ChangeRegisterArrayEntry_RegisterArrayChangeType : int {
  ChangeRegisterArrayEntry_RegisterArrayChangeType_CHANGE_SIZE = 0,
  ChangeRegisterArrayEntry_RegisterArrayChangeType_CHANGE_BITWIDTH = 1,
  ChangeRegisterArrayEntry_RegisterArrayChangeType_ChangeRegisterArrayEntry_RegisterArrayChangeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ChangeRegisterArrayEntry_RegisterArrayChangeType_ChangeRegisterArrayEntry_RegisterArrayChangeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ChangeRegisterArrayEntry_RegisterArrayChangeType_IsValid(int value);
constexpr ChangeRegisterArrayEntry_RegisterArrayChangeType ChangeRegisterArrayEntry_RegisterArrayChangeType_RegisterArrayChangeType_MIN = ChangeRegisterArrayEntry_RegisterArrayChangeType_CHANGE_SIZE;
constexpr ChangeRegisterArrayEntry_RegisterArrayChangeType ChangeRegisterArrayEntry_RegisterArrayChangeType_RegisterArrayChangeType_MAX = ChangeRegisterArrayEntry_RegisterArrayChangeType_CHANGE_BITWIDTH;
constexpr int ChangeRegisterArrayEntry_RegisterArrayChangeType_RegisterArrayChangeType_ARRAYSIZE = ChangeRegisterArrayEntry_RegisterArrayChangeType_RegisterArrayChangeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChangeRegisterArrayEntry_RegisterArrayChangeType_descriptor();
template<typename T>
inline const std::string& ChangeRegisterArrayEntry_RegisterArrayChangeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChangeRegisterArrayEntry_RegisterArrayChangeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChangeRegisterArrayEntry_RegisterArrayChangeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChangeRegisterArrayEntry_RegisterArrayChangeType_descriptor(), enum_t_value);
}
inline bool ChangeRegisterArrayEntry_RegisterArrayChangeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChangeRegisterArrayEntry_RegisterArrayChangeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChangeRegisterArrayEntry_RegisterArrayChangeType>(
    ChangeRegisterArrayEntry_RegisterArrayChangeType_descriptor(), name, value);
}
enum SetForwardingPipelineConfigRequest_Action : int {
  SetForwardingPipelineConfigRequest_Action_UNSPECIFIED = 0,
  SetForwardingPipelineConfigRequest_Action_VERIFY = 1,
  SetForwardingPipelineConfigRequest_Action_VERIFY_AND_SAVE = 2,
  SetForwardingPipelineConfigRequest_Action_VERIFY_AND_COMMIT = 3,
  SetForwardingPipelineConfigRequest_Action_COMMIT = 4,
  SetForwardingPipelineConfigRequest_Action_RECONCILE_AND_COMMIT = 5,
  SetForwardingPipelineConfigRequest_Action_SetForwardingPipelineConfigRequest_Action_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SetForwardingPipelineConfigRequest_Action_SetForwardingPipelineConfigRequest_Action_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SetForwardingPipelineConfigRequest_Action_IsValid(int value);
constexpr SetForwardingPipelineConfigRequest_Action SetForwardingPipelineConfigRequest_Action_Action_MIN = SetForwardingPipelineConfigRequest_Action_UNSPECIFIED;
constexpr SetForwardingPipelineConfigRequest_Action SetForwardingPipelineConfigRequest_Action_Action_MAX = SetForwardingPipelineConfigRequest_Action_RECONCILE_AND_COMMIT;
constexpr int SetForwardingPipelineConfigRequest_Action_Action_ARRAYSIZE = SetForwardingPipelineConfigRequest_Action_Action_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SetForwardingPipelineConfigRequest_Action_descriptor();
template<typename T>
inline const std::string& SetForwardingPipelineConfigRequest_Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SetForwardingPipelineConfigRequest_Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SetForwardingPipelineConfigRequest_Action_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SetForwardingPipelineConfigRequest_Action_descriptor(), enum_t_value);
}
inline bool SetForwardingPipelineConfigRequest_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SetForwardingPipelineConfigRequest_Action* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SetForwardingPipelineConfigRequest_Action>(
    SetForwardingPipelineConfigRequest_Action_descriptor(), name, value);
}
enum GetForwardingPipelineConfigRequest_ResponseType : int {
  GetForwardingPipelineConfigRequest_ResponseType_ALL = 0,
  GetForwardingPipelineConfigRequest_ResponseType_COOKIE_ONLY = 1,
  GetForwardingPipelineConfigRequest_ResponseType_P4INFO_AND_COOKIE = 2,
  GetForwardingPipelineConfigRequest_ResponseType_DEVICE_CONFIG_AND_COOKIE = 3,
  GetForwardingPipelineConfigRequest_ResponseType_GetForwardingPipelineConfigRequest_ResponseType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GetForwardingPipelineConfigRequest_ResponseType_GetForwardingPipelineConfigRequest_ResponseType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GetForwardingPipelineConfigRequest_ResponseType_IsValid(int value);
constexpr GetForwardingPipelineConfigRequest_ResponseType GetForwardingPipelineConfigRequest_ResponseType_ResponseType_MIN = GetForwardingPipelineConfigRequest_ResponseType_ALL;
constexpr GetForwardingPipelineConfigRequest_ResponseType GetForwardingPipelineConfigRequest_ResponseType_ResponseType_MAX = GetForwardingPipelineConfigRequest_ResponseType_DEVICE_CONFIG_AND_COOKIE;
constexpr int GetForwardingPipelineConfigRequest_ResponseType_ResponseType_ARRAYSIZE = GetForwardingPipelineConfigRequest_ResponseType_ResponseType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GetForwardingPipelineConfigRequest_ResponseType_descriptor();
template<typename T>
inline const std::string& GetForwardingPipelineConfigRequest_ResponseType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GetForwardingPipelineConfigRequest_ResponseType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GetForwardingPipelineConfigRequest_ResponseType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GetForwardingPipelineConfigRequest_ResponseType_descriptor(), enum_t_value);
}
inline bool GetForwardingPipelineConfigRequest_ResponseType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GetForwardingPipelineConfigRequest_ResponseType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GetForwardingPipelineConfigRequest_ResponseType>(
    GetForwardingPipelineConfigRequest_ResponseType_descriptor(), name, value);
}
enum SdnPort : int {
  SDN_PORT_UNKNOWN = 0,
  SDN_PORT_MIN = 1,
  SDN_PORT_MAX = -257,
  SDN_PORT_RECIRCULATE = -6,
  SDN_PORT_CPU = -3,
  SdnPort_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SdnPort_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SdnPort_IsValid(int value);
constexpr SdnPort SdnPort_MIN = SDN_PORT_MAX;
constexpr SdnPort SdnPort_MAX = SDN_PORT_MIN;
constexpr int SdnPort_ARRAYSIZE = SdnPort_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SdnPort_descriptor();
template<typename T>
inline const std::string& SdnPort_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SdnPort>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SdnPort_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SdnPort_descriptor(), enum_t_value);
}
inline bool SdnPort_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SdnPort* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SdnPort>(
    SdnPort_descriptor(), name, value);
}
// ===================================================================

class WriteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.WriteRequest) */ {
 public:
  inline WriteRequest() : WriteRequest(nullptr) {}
  ~WriteRequest() override;
  explicit constexpr WriteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteRequest(const WriteRequest& from);
  WriteRequest(WriteRequest&& from) noexcept
    : WriteRequest() {
    *this = ::std::move(from);
  }

  inline WriteRequest& operator=(const WriteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteRequest& operator=(WriteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteRequest* internal_default_instance() {
    return reinterpret_cast<const WriteRequest*>(
               &_WriteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(WriteRequest& a, WriteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WriteRequest* New() const final {
    return new WriteRequest();
  }

  WriteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WriteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WriteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.WriteRequest";
  }
  protected:
  explicit WriteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WriteRequest_Atomicity Atomicity;
  static constexpr Atomicity CONTINUE_ON_ERROR =
    WriteRequest_Atomicity_CONTINUE_ON_ERROR;
  static constexpr Atomicity ROLLBACK_ON_ERROR =
    WriteRequest_Atomicity_ROLLBACK_ON_ERROR;
  static constexpr Atomicity DATAPLANE_ATOMIC =
    WriteRequest_Atomicity_DATAPLANE_ATOMIC;
  static inline bool Atomicity_IsValid(int value) {
    return WriteRequest_Atomicity_IsValid(value);
  }
  static constexpr Atomicity Atomicity_MIN =
    WriteRequest_Atomicity_Atomicity_MIN;
  static constexpr Atomicity Atomicity_MAX =
    WriteRequest_Atomicity_Atomicity_MAX;
  static constexpr int Atomicity_ARRAYSIZE =
    WriteRequest_Atomicity_Atomicity_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Atomicity_descriptor() {
    return WriteRequest_Atomicity_descriptor();
  }
  template<typename T>
  static inline const std::string& Atomicity_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Atomicity>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Atomicity_Name.");
    return WriteRequest_Atomicity_Name(enum_t_value);
  }
  static inline bool Atomicity_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Atomicity* value) {
    return WriteRequest_Atomicity_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUpdatesFieldNumber = 4,
    kElectionIdFieldNumber = 3,
    kDeviceIdFieldNumber = 1,
    kRoleIdFieldNumber = 2,
    kAtomicityFieldNumber = 5,
  };
  // repeated .p4.v1.Update updates = 4;
  int updates_size() const;
  private:
  int _internal_updates_size() const;
  public:
  void clear_updates();
  ::p4::v1::Update* mutable_updates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Update >*
      mutable_updates();
  private:
  const ::p4::v1::Update& _internal_updates(int index) const;
  ::p4::v1::Update* _internal_add_updates();
  public:
  const ::p4::v1::Update& updates(int index) const;
  ::p4::v1::Update* add_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Update >&
      updates() const;

  // .p4.v1.Uint128 election_id = 3;
  bool has_election_id() const;
  private:
  bool _internal_has_election_id() const;
  public:
  void clear_election_id();
  const ::p4::v1::Uint128& election_id() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::Uint128* release_election_id();
  ::p4::v1::Uint128* mutable_election_id();
  void set_allocated_election_id(::p4::v1::Uint128* election_id);
  private:
  const ::p4::v1::Uint128& _internal_election_id() const;
  ::p4::v1::Uint128* _internal_mutable_election_id();
  public:
  void unsafe_arena_set_allocated_election_id(
      ::p4::v1::Uint128* election_id);
  ::p4::v1::Uint128* unsafe_arena_release_election_id();

  // uint64 device_id = 1;
  void clear_device_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 device_id() const;
  void set_device_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_device_id() const;
  void _internal_set_device_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 role_id = 2;
  void clear_role_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 role_id() const;
  void set_role_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_role_id() const;
  void _internal_set_role_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .p4.v1.WriteRequest.Atomicity atomicity = 5;
  void clear_atomicity();
  ::p4::v1::WriteRequest_Atomicity atomicity() const;
  void set_atomicity(::p4::v1::WriteRequest_Atomicity value);
  private:
  ::p4::v1::WriteRequest_Atomicity _internal_atomicity() const;
  void _internal_set_atomicity(::p4::v1::WriteRequest_Atomicity value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.WriteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Update > updates_;
  ::p4::v1::Uint128* election_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 device_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 role_id_;
  int atomicity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class WriteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:p4.v1.WriteResponse) */ {
 public:
  inline WriteResponse() : WriteResponse(nullptr) {}
  explicit constexpr WriteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteResponse(const WriteResponse& from);
  WriteResponse(WriteResponse&& from) noexcept
    : WriteResponse() {
    *this = ::std::move(from);
  }

  inline WriteResponse& operator=(const WriteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteResponse& operator=(WriteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteResponse* internal_default_instance() {
    return reinterpret_cast<const WriteResponse*>(
               &_WriteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(WriteResponse& a, WriteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WriteResponse* New() const final {
    return new WriteResponse();
  }

  WriteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WriteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const WriteResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const WriteResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.WriteResponse";
  }
  protected:
  explicit WriteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:p4.v1.WriteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class ReadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.ReadRequest) */ {
 public:
  inline ReadRequest() : ReadRequest(nullptr) {}
  ~ReadRequest() override;
  explicit constexpr ReadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadRequest(const ReadRequest& from);
  ReadRequest(ReadRequest&& from) noexcept
    : ReadRequest() {
    *this = ::std::move(from);
  }

  inline ReadRequest& operator=(const ReadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadRequest& operator=(ReadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadRequest* internal_default_instance() {
    return reinterpret_cast<const ReadRequest*>(
               &_ReadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ReadRequest& a, ReadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReadRequest* New() const final {
    return new ReadRequest();
  }

  ReadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReadRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReadRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.ReadRequest";
  }
  protected:
  explicit ReadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntitiesFieldNumber = 2,
    kDeviceIdFieldNumber = 1,
  };
  // repeated .p4.v1.Entity entities = 2;
  int entities_size() const;
  private:
  int _internal_entities_size() const;
  public:
  void clear_entities();
  ::p4::v1::Entity* mutable_entities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Entity >*
      mutable_entities();
  private:
  const ::p4::v1::Entity& _internal_entities(int index) const;
  ::p4::v1::Entity* _internal_add_entities();
  public:
  const ::p4::v1::Entity& entities(int index) const;
  ::p4::v1::Entity* add_entities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Entity >&
      entities() const;

  // uint64 device_id = 1;
  void clear_device_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 device_id() const;
  void set_device_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_device_id() const;
  void _internal_set_device_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.ReadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Entity > entities_;
  ::PROTOBUF_NAMESPACE_ID::uint64 device_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class ReadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.ReadResponse) */ {
 public:
  inline ReadResponse() : ReadResponse(nullptr) {}
  ~ReadResponse() override;
  explicit constexpr ReadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadResponse(const ReadResponse& from);
  ReadResponse(ReadResponse&& from) noexcept
    : ReadResponse() {
    *this = ::std::move(from);
  }

  inline ReadResponse& operator=(const ReadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadResponse& operator=(ReadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadResponse* internal_default_instance() {
    return reinterpret_cast<const ReadResponse*>(
               &_ReadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ReadResponse& a, ReadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReadResponse* New() const final {
    return new ReadResponse();
  }

  ReadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReadResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReadResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.ReadResponse";
  }
  protected:
  explicit ReadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntitiesFieldNumber = 1,
  };
  // repeated .p4.v1.Entity entities = 1;
  int entities_size() const;
  private:
  int _internal_entities_size() const;
  public:
  void clear_entities();
  ::p4::v1::Entity* mutable_entities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Entity >*
      mutable_entities();
  private:
  const ::p4::v1::Entity& _internal_entities(int index) const;
  ::p4::v1::Entity* _internal_add_entities();
  public:
  const ::p4::v1::Entity& entities(int index) const;
  ::p4::v1::Entity* add_entities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Entity >&
      entities() const;

  // @@protoc_insertion_point(class_scope:p4.v1.ReadResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Entity > entities_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class Update final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.Update) */ {
 public:
  inline Update() : Update(nullptr) {}
  ~Update() override;
  explicit constexpr Update(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Update(const Update& from);
  Update(Update&& from) noexcept
    : Update() {
    *this = ::std::move(from);
  }

  inline Update& operator=(const Update& from) {
    CopyFrom(from);
    return *this;
  }
  inline Update& operator=(Update&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Update& default_instance() {
    return *internal_default_instance();
  }
  static inline const Update* internal_default_instance() {
    return reinterpret_cast<const Update*>(
               &_Update_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Update& a, Update& b) {
    a.Swap(&b);
  }
  inline void Swap(Update* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Update* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Update* New() const final {
    return new Update();
  }

  Update* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Update>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Update& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Update& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Update* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.Update";
  }
  protected:
  explicit Update(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Update_Type Type;
  static constexpr Type UNSPECIFIED =
    Update_Type_UNSPECIFIED;
  static constexpr Type INSERT =
    Update_Type_INSERT;
  static constexpr Type MODIFY =
    Update_Type_MODIFY;
  static constexpr Type DELETE =
    Update_Type_DELETE;
  static constexpr Type RUNTIME_RECONFIG =
    Update_Type_RUNTIME_RECONFIG;
  static inline bool Type_IsValid(int value) {
    return Update_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Update_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Update_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Update_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Update_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Update_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Update_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEntityFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .p4.v1.Entity entity = 2;
  bool has_entity() const;
  private:
  bool _internal_has_entity() const;
  public:
  void clear_entity();
  const ::p4::v1::Entity& entity() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::Entity* release_entity();
  ::p4::v1::Entity* mutable_entity();
  void set_allocated_entity(::p4::v1::Entity* entity);
  private:
  const ::p4::v1::Entity& _internal_entity() const;
  ::p4::v1::Entity* _internal_mutable_entity();
  public:
  void unsafe_arena_set_allocated_entity(
      ::p4::v1::Entity* entity);
  ::p4::v1::Entity* unsafe_arena_release_entity();

  // .p4.v1.Update.Type type = 1;
  void clear_type();
  ::p4::v1::Update_Type type() const;
  void set_type(::p4::v1::Update_Type value);
  private:
  ::p4::v1::Update_Type _internal_type() const;
  void _internal_set_type(::p4::v1::Update_Type value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.Update)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::p4::v1::Entity* entity_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class Entity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.Entity) */ {
 public:
  inline Entity() : Entity(nullptr) {}
  ~Entity() override;
  explicit constexpr Entity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Entity(const Entity& from);
  Entity(Entity&& from) noexcept
    : Entity() {
    *this = ::std::move(from);
  }

  inline Entity& operator=(const Entity& from) {
    CopyFrom(from);
    return *this;
  }
  inline Entity& operator=(Entity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Entity& default_instance() {
    return *internal_default_instance();
  }
  enum EntityCase {
    kExternEntry = 1,
    kTableEntry = 2,
    kActionProfileMember = 3,
    kActionProfileGroup = 4,
    kMeterEntry = 5,
    kDirectMeterEntry = 6,
    kCounterEntry = 7,
    kDirectCounterEntry = 8,
    kPacketReplicationEngineEntry = 9,
    kValueSetEntry = 10,
    kRegisterEntry = 11,
    kDigestEntry = 12,
    kRuntimeReconfigEntry = 13,
    ENTITY_NOT_SET = 0,
  };

  static inline const Entity* internal_default_instance() {
    return reinterpret_cast<const Entity*>(
               &_Entity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Entity& a, Entity& b) {
    a.Swap(&b);
  }
  inline void Swap(Entity* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Entity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Entity* New() const final {
    return new Entity();
  }

  Entity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Entity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Entity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Entity& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Entity* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.Entity";
  }
  protected:
  explicit Entity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExternEntryFieldNumber = 1,
    kTableEntryFieldNumber = 2,
    kActionProfileMemberFieldNumber = 3,
    kActionProfileGroupFieldNumber = 4,
    kMeterEntryFieldNumber = 5,
    kDirectMeterEntryFieldNumber = 6,
    kCounterEntryFieldNumber = 7,
    kDirectCounterEntryFieldNumber = 8,
    kPacketReplicationEngineEntryFieldNumber = 9,
    kValueSetEntryFieldNumber = 10,
    kRegisterEntryFieldNumber = 11,
    kDigestEntryFieldNumber = 12,
    kRuntimeReconfigEntryFieldNumber = 13,
  };
  // .p4.v1.ExternEntry extern_entry = 1;
  bool has_extern_entry() const;
  private:
  bool _internal_has_extern_entry() const;
  public:
  void clear_extern_entry();
  const ::p4::v1::ExternEntry& extern_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::ExternEntry* release_extern_entry();
  ::p4::v1::ExternEntry* mutable_extern_entry();
  void set_allocated_extern_entry(::p4::v1::ExternEntry* extern_entry);
  private:
  const ::p4::v1::ExternEntry& _internal_extern_entry() const;
  ::p4::v1::ExternEntry* _internal_mutable_extern_entry();
  public:
  void unsafe_arena_set_allocated_extern_entry(
      ::p4::v1::ExternEntry* extern_entry);
  ::p4::v1::ExternEntry* unsafe_arena_release_extern_entry();

  // .p4.v1.TableEntry table_entry = 2;
  bool has_table_entry() const;
  private:
  bool _internal_has_table_entry() const;
  public:
  void clear_table_entry();
  const ::p4::v1::TableEntry& table_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::TableEntry* release_table_entry();
  ::p4::v1::TableEntry* mutable_table_entry();
  void set_allocated_table_entry(::p4::v1::TableEntry* table_entry);
  private:
  const ::p4::v1::TableEntry& _internal_table_entry() const;
  ::p4::v1::TableEntry* _internal_mutable_table_entry();
  public:
  void unsafe_arena_set_allocated_table_entry(
      ::p4::v1::TableEntry* table_entry);
  ::p4::v1::TableEntry* unsafe_arena_release_table_entry();

  // .p4.v1.ActionProfileMember action_profile_member = 3;
  bool has_action_profile_member() const;
  private:
  bool _internal_has_action_profile_member() const;
  public:
  void clear_action_profile_member();
  const ::p4::v1::ActionProfileMember& action_profile_member() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::ActionProfileMember* release_action_profile_member();
  ::p4::v1::ActionProfileMember* mutable_action_profile_member();
  void set_allocated_action_profile_member(::p4::v1::ActionProfileMember* action_profile_member);
  private:
  const ::p4::v1::ActionProfileMember& _internal_action_profile_member() const;
  ::p4::v1::ActionProfileMember* _internal_mutable_action_profile_member();
  public:
  void unsafe_arena_set_allocated_action_profile_member(
      ::p4::v1::ActionProfileMember* action_profile_member);
  ::p4::v1::ActionProfileMember* unsafe_arena_release_action_profile_member();

  // .p4.v1.ActionProfileGroup action_profile_group = 4;
  bool has_action_profile_group() const;
  private:
  bool _internal_has_action_profile_group() const;
  public:
  void clear_action_profile_group();
  const ::p4::v1::ActionProfileGroup& action_profile_group() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::ActionProfileGroup* release_action_profile_group();
  ::p4::v1::ActionProfileGroup* mutable_action_profile_group();
  void set_allocated_action_profile_group(::p4::v1::ActionProfileGroup* action_profile_group);
  private:
  const ::p4::v1::ActionProfileGroup& _internal_action_profile_group() const;
  ::p4::v1::ActionProfileGroup* _internal_mutable_action_profile_group();
  public:
  void unsafe_arena_set_allocated_action_profile_group(
      ::p4::v1::ActionProfileGroup* action_profile_group);
  ::p4::v1::ActionProfileGroup* unsafe_arena_release_action_profile_group();

  // .p4.v1.MeterEntry meter_entry = 5;
  bool has_meter_entry() const;
  private:
  bool _internal_has_meter_entry() const;
  public:
  void clear_meter_entry();
  const ::p4::v1::MeterEntry& meter_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::MeterEntry* release_meter_entry();
  ::p4::v1::MeterEntry* mutable_meter_entry();
  void set_allocated_meter_entry(::p4::v1::MeterEntry* meter_entry);
  private:
  const ::p4::v1::MeterEntry& _internal_meter_entry() const;
  ::p4::v1::MeterEntry* _internal_mutable_meter_entry();
  public:
  void unsafe_arena_set_allocated_meter_entry(
      ::p4::v1::MeterEntry* meter_entry);
  ::p4::v1::MeterEntry* unsafe_arena_release_meter_entry();

  // .p4.v1.DirectMeterEntry direct_meter_entry = 6;
  bool has_direct_meter_entry() const;
  private:
  bool _internal_has_direct_meter_entry() const;
  public:
  void clear_direct_meter_entry();
  const ::p4::v1::DirectMeterEntry& direct_meter_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::DirectMeterEntry* release_direct_meter_entry();
  ::p4::v1::DirectMeterEntry* mutable_direct_meter_entry();
  void set_allocated_direct_meter_entry(::p4::v1::DirectMeterEntry* direct_meter_entry);
  private:
  const ::p4::v1::DirectMeterEntry& _internal_direct_meter_entry() const;
  ::p4::v1::DirectMeterEntry* _internal_mutable_direct_meter_entry();
  public:
  void unsafe_arena_set_allocated_direct_meter_entry(
      ::p4::v1::DirectMeterEntry* direct_meter_entry);
  ::p4::v1::DirectMeterEntry* unsafe_arena_release_direct_meter_entry();

  // .p4.v1.CounterEntry counter_entry = 7;
  bool has_counter_entry() const;
  private:
  bool _internal_has_counter_entry() const;
  public:
  void clear_counter_entry();
  const ::p4::v1::CounterEntry& counter_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::CounterEntry* release_counter_entry();
  ::p4::v1::CounterEntry* mutable_counter_entry();
  void set_allocated_counter_entry(::p4::v1::CounterEntry* counter_entry);
  private:
  const ::p4::v1::CounterEntry& _internal_counter_entry() const;
  ::p4::v1::CounterEntry* _internal_mutable_counter_entry();
  public:
  void unsafe_arena_set_allocated_counter_entry(
      ::p4::v1::CounterEntry* counter_entry);
  ::p4::v1::CounterEntry* unsafe_arena_release_counter_entry();

  // .p4.v1.DirectCounterEntry direct_counter_entry = 8;
  bool has_direct_counter_entry() const;
  private:
  bool _internal_has_direct_counter_entry() const;
  public:
  void clear_direct_counter_entry();
  const ::p4::v1::DirectCounterEntry& direct_counter_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::DirectCounterEntry* release_direct_counter_entry();
  ::p4::v1::DirectCounterEntry* mutable_direct_counter_entry();
  void set_allocated_direct_counter_entry(::p4::v1::DirectCounterEntry* direct_counter_entry);
  private:
  const ::p4::v1::DirectCounterEntry& _internal_direct_counter_entry() const;
  ::p4::v1::DirectCounterEntry* _internal_mutable_direct_counter_entry();
  public:
  void unsafe_arena_set_allocated_direct_counter_entry(
      ::p4::v1::DirectCounterEntry* direct_counter_entry);
  ::p4::v1::DirectCounterEntry* unsafe_arena_release_direct_counter_entry();

  // .p4.v1.PacketReplicationEngineEntry packet_replication_engine_entry = 9;
  bool has_packet_replication_engine_entry() const;
  private:
  bool _internal_has_packet_replication_engine_entry() const;
  public:
  void clear_packet_replication_engine_entry();
  const ::p4::v1::PacketReplicationEngineEntry& packet_replication_engine_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::PacketReplicationEngineEntry* release_packet_replication_engine_entry();
  ::p4::v1::PacketReplicationEngineEntry* mutable_packet_replication_engine_entry();
  void set_allocated_packet_replication_engine_entry(::p4::v1::PacketReplicationEngineEntry* packet_replication_engine_entry);
  private:
  const ::p4::v1::PacketReplicationEngineEntry& _internal_packet_replication_engine_entry() const;
  ::p4::v1::PacketReplicationEngineEntry* _internal_mutable_packet_replication_engine_entry();
  public:
  void unsafe_arena_set_allocated_packet_replication_engine_entry(
      ::p4::v1::PacketReplicationEngineEntry* packet_replication_engine_entry);
  ::p4::v1::PacketReplicationEngineEntry* unsafe_arena_release_packet_replication_engine_entry();

  // .p4.v1.ValueSetEntry value_set_entry = 10;
  bool has_value_set_entry() const;
  private:
  bool _internal_has_value_set_entry() const;
  public:
  void clear_value_set_entry();
  const ::p4::v1::ValueSetEntry& value_set_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::ValueSetEntry* release_value_set_entry();
  ::p4::v1::ValueSetEntry* mutable_value_set_entry();
  void set_allocated_value_set_entry(::p4::v1::ValueSetEntry* value_set_entry);
  private:
  const ::p4::v1::ValueSetEntry& _internal_value_set_entry() const;
  ::p4::v1::ValueSetEntry* _internal_mutable_value_set_entry();
  public:
  void unsafe_arena_set_allocated_value_set_entry(
      ::p4::v1::ValueSetEntry* value_set_entry);
  ::p4::v1::ValueSetEntry* unsafe_arena_release_value_set_entry();

  // .p4.v1.RegisterEntry register_entry = 11;
  bool has_register_entry() const;
  private:
  bool _internal_has_register_entry() const;
  public:
  void clear_register_entry();
  const ::p4::v1::RegisterEntry& register_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::RegisterEntry* release_register_entry();
  ::p4::v1::RegisterEntry* mutable_register_entry();
  void set_allocated_register_entry(::p4::v1::RegisterEntry* register_entry);
  private:
  const ::p4::v1::RegisterEntry& _internal_register_entry() const;
  ::p4::v1::RegisterEntry* _internal_mutable_register_entry();
  public:
  void unsafe_arena_set_allocated_register_entry(
      ::p4::v1::RegisterEntry* register_entry);
  ::p4::v1::RegisterEntry* unsafe_arena_release_register_entry();

  // .p4.v1.DigestEntry digest_entry = 12;
  bool has_digest_entry() const;
  private:
  bool _internal_has_digest_entry() const;
  public:
  void clear_digest_entry();
  const ::p4::v1::DigestEntry& digest_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::DigestEntry* release_digest_entry();
  ::p4::v1::DigestEntry* mutable_digest_entry();
  void set_allocated_digest_entry(::p4::v1::DigestEntry* digest_entry);
  private:
  const ::p4::v1::DigestEntry& _internal_digest_entry() const;
  ::p4::v1::DigestEntry* _internal_mutable_digest_entry();
  public:
  void unsafe_arena_set_allocated_digest_entry(
      ::p4::v1::DigestEntry* digest_entry);
  ::p4::v1::DigestEntry* unsafe_arena_release_digest_entry();

  // .p4.v1.RuntimeReconfigEntry runtime_reconfig_entry = 13;
  bool has_runtime_reconfig_entry() const;
  private:
  bool _internal_has_runtime_reconfig_entry() const;
  public:
  void clear_runtime_reconfig_entry();
  const ::p4::v1::RuntimeReconfigEntry& runtime_reconfig_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::RuntimeReconfigEntry* release_runtime_reconfig_entry();
  ::p4::v1::RuntimeReconfigEntry* mutable_runtime_reconfig_entry();
  void set_allocated_runtime_reconfig_entry(::p4::v1::RuntimeReconfigEntry* runtime_reconfig_entry);
  private:
  const ::p4::v1::RuntimeReconfigEntry& _internal_runtime_reconfig_entry() const;
  ::p4::v1::RuntimeReconfigEntry* _internal_mutable_runtime_reconfig_entry();
  public:
  void unsafe_arena_set_allocated_runtime_reconfig_entry(
      ::p4::v1::RuntimeReconfigEntry* runtime_reconfig_entry);
  ::p4::v1::RuntimeReconfigEntry* unsafe_arena_release_runtime_reconfig_entry();

  void clear_entity();
  EntityCase entity_case() const;
  // @@protoc_insertion_point(class_scope:p4.v1.Entity)
 private:
  class _Internal;
  void set_has_extern_entry();
  void set_has_table_entry();
  void set_has_action_profile_member();
  void set_has_action_profile_group();
  void set_has_meter_entry();
  void set_has_direct_meter_entry();
  void set_has_counter_entry();
  void set_has_direct_counter_entry();
  void set_has_packet_replication_engine_entry();
  void set_has_value_set_entry();
  void set_has_register_entry();
  void set_has_digest_entry();
  void set_has_runtime_reconfig_entry();

  inline bool has_entity() const;
  inline void clear_has_entity();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EntityUnion {
    constexpr EntityUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::p4::v1::ExternEntry* extern_entry_;
    ::p4::v1::TableEntry* table_entry_;
    ::p4::v1::ActionProfileMember* action_profile_member_;
    ::p4::v1::ActionProfileGroup* action_profile_group_;
    ::p4::v1::MeterEntry* meter_entry_;
    ::p4::v1::DirectMeterEntry* direct_meter_entry_;
    ::p4::v1::CounterEntry* counter_entry_;
    ::p4::v1::DirectCounterEntry* direct_counter_entry_;
    ::p4::v1::PacketReplicationEngineEntry* packet_replication_engine_entry_;
    ::p4::v1::ValueSetEntry* value_set_entry_;
    ::p4::v1::RegisterEntry* register_entry_;
    ::p4::v1::DigestEntry* digest_entry_;
    ::p4::v1::RuntimeReconfigEntry* runtime_reconfig_entry_;
  } entity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class RuntimeReconfigEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.RuntimeReconfigEntry) */ {
 public:
  inline RuntimeReconfigEntry() : RuntimeReconfigEntry(nullptr) {}
  ~RuntimeReconfigEntry() override;
  explicit constexpr RuntimeReconfigEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RuntimeReconfigEntry(const RuntimeReconfigEntry& from);
  RuntimeReconfigEntry(RuntimeReconfigEntry&& from) noexcept
    : RuntimeReconfigEntry() {
    *this = ::std::move(from);
  }

  inline RuntimeReconfigEntry& operator=(const RuntimeReconfigEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline RuntimeReconfigEntry& operator=(RuntimeReconfigEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RuntimeReconfigEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const RuntimeReconfigEntry* internal_default_instance() {
    return reinterpret_cast<const RuntimeReconfigEntry*>(
               &_RuntimeReconfigEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RuntimeReconfigEntry& a, RuntimeReconfigEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(RuntimeReconfigEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RuntimeReconfigEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RuntimeReconfigEntry* New() const final {
    return new RuntimeReconfigEntry();
  }

  RuntimeReconfigEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RuntimeReconfigEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RuntimeReconfigEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RuntimeReconfigEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RuntimeReconfigEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.RuntimeReconfigEntry";
  }
  protected:
  explicit RuntimeReconfigEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RuntimeReconfigEntry_RuntimeReconfigType RuntimeReconfigType;
  static constexpr RuntimeReconfigType INIT_P4OBJECTS_NEW =
    RuntimeReconfigEntry_RuntimeReconfigType_INIT_P4OBJECTS_NEW;
  static constexpr RuntimeReconfigType INSERT_TABLE =
    RuntimeReconfigEntry_RuntimeReconfigType_INSERT_TABLE;
  static constexpr RuntimeReconfigType CHANGE_TABLE =
    RuntimeReconfigEntry_RuntimeReconfigType_CHANGE_TABLE;
  static constexpr RuntimeReconfigType DELETE_TABLE =
    RuntimeReconfigEntry_RuntimeReconfigType_DELETE_TABLE;
  static constexpr RuntimeReconfigType INSERT_CONDITIONAL =
    RuntimeReconfigEntry_RuntimeReconfigType_INSERT_CONDITIONAL;
  static constexpr RuntimeReconfigType CHANGE_CONDITIONAL =
    RuntimeReconfigEntry_RuntimeReconfigType_CHANGE_CONDITIONAL;
  static constexpr RuntimeReconfigType DELETE_CONDITIONAL =
    RuntimeReconfigEntry_RuntimeReconfigType_DELETE_CONDITIONAL;
  static constexpr RuntimeReconfigType INSERT_FLEX =
    RuntimeReconfigEntry_RuntimeReconfigType_INSERT_FLEX;
  static constexpr RuntimeReconfigType CHANGE_FLEX =
    RuntimeReconfigEntry_RuntimeReconfigType_CHANGE_FLEX;
  static constexpr RuntimeReconfigType DELETE_FLEX =
    RuntimeReconfigEntry_RuntimeReconfigType_DELETE_FLEX;
  static constexpr RuntimeReconfigType INSERT_REGISTER_ARRAY =
    RuntimeReconfigEntry_RuntimeReconfigType_INSERT_REGISTER_ARRAY;
  static constexpr RuntimeReconfigType CHANGE_REGISTER_ARRAY =
    RuntimeReconfigEntry_RuntimeReconfigType_CHANGE_REGISTER_ARRAY;
  static constexpr RuntimeReconfigType DELETE_REGISTER_ARRAY =
    RuntimeReconfigEntry_RuntimeReconfigType_DELETE_REGISTER_ARRAY;
  static constexpr RuntimeReconfigType TRIGGER =
    RuntimeReconfigEntry_RuntimeReconfigType_TRIGGER;
  static constexpr RuntimeReconfigType CHANGE_INIT =
    RuntimeReconfigEntry_RuntimeReconfigType_CHANGE_INIT;
  static inline bool RuntimeReconfigType_IsValid(int value) {
    return RuntimeReconfigEntry_RuntimeReconfigType_IsValid(value);
  }
  static constexpr RuntimeReconfigType RuntimeReconfigType_MIN =
    RuntimeReconfigEntry_RuntimeReconfigType_RuntimeReconfigType_MIN;
  static constexpr RuntimeReconfigType RuntimeReconfigType_MAX =
    RuntimeReconfigEntry_RuntimeReconfigType_RuntimeReconfigType_MAX;
  static constexpr int RuntimeReconfigType_ARRAYSIZE =
    RuntimeReconfigEntry_RuntimeReconfigType_RuntimeReconfigType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RuntimeReconfigType_descriptor() {
    return RuntimeReconfigEntry_RuntimeReconfigType_descriptor();
  }
  template<typename T>
  static inline const std::string& RuntimeReconfigType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RuntimeReconfigType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RuntimeReconfigType_Name.");
    return RuntimeReconfigEntry_RuntimeReconfigType_Name(enum_t_value);
  }
  static inline bool RuntimeReconfigType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RuntimeReconfigType* value) {
    return RuntimeReconfigEntry_RuntimeReconfigType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRuntimeReconfigContentFieldNumber = 2,
    kRuntimeReconfigTypeFieldNumber = 1,
  };
  // .p4.v1.RuntimeReconfigContent runtime_reconfig_content = 2;
  bool has_runtime_reconfig_content() const;
  private:
  bool _internal_has_runtime_reconfig_content() const;
  public:
  void clear_runtime_reconfig_content();
  const ::p4::v1::RuntimeReconfigContent& runtime_reconfig_content() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::RuntimeReconfigContent* release_runtime_reconfig_content();
  ::p4::v1::RuntimeReconfigContent* mutable_runtime_reconfig_content();
  void set_allocated_runtime_reconfig_content(::p4::v1::RuntimeReconfigContent* runtime_reconfig_content);
  private:
  const ::p4::v1::RuntimeReconfigContent& _internal_runtime_reconfig_content() const;
  ::p4::v1::RuntimeReconfigContent* _internal_mutable_runtime_reconfig_content();
  public:
  void unsafe_arena_set_allocated_runtime_reconfig_content(
      ::p4::v1::RuntimeReconfigContent* runtime_reconfig_content);
  ::p4::v1::RuntimeReconfigContent* unsafe_arena_release_runtime_reconfig_content();

  // .p4.v1.RuntimeReconfigEntry.RuntimeReconfigType runtime_reconfig_type = 1;
  void clear_runtime_reconfig_type();
  ::p4::v1::RuntimeReconfigEntry_RuntimeReconfigType runtime_reconfig_type() const;
  void set_runtime_reconfig_type(::p4::v1::RuntimeReconfigEntry_RuntimeReconfigType value);
  private:
  ::p4::v1::RuntimeReconfigEntry_RuntimeReconfigType _internal_runtime_reconfig_type() const;
  void _internal_set_runtime_reconfig_type(::p4::v1::RuntimeReconfigEntry_RuntimeReconfigType value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.RuntimeReconfigEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::p4::v1::RuntimeReconfigContent* runtime_reconfig_content_;
  int runtime_reconfig_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class RuntimeReconfigContent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.RuntimeReconfigContent) */ {
 public:
  inline RuntimeReconfigContent() : RuntimeReconfigContent(nullptr) {}
  ~RuntimeReconfigContent() override;
  explicit constexpr RuntimeReconfigContent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RuntimeReconfigContent(const RuntimeReconfigContent& from);
  RuntimeReconfigContent(RuntimeReconfigContent&& from) noexcept
    : RuntimeReconfigContent() {
    *this = ::std::move(from);
  }

  inline RuntimeReconfigContent& operator=(const RuntimeReconfigContent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RuntimeReconfigContent& operator=(RuntimeReconfigContent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RuntimeReconfigContent& default_instance() {
    return *internal_default_instance();
  }
  enum ContentCase {
    kInitP4ObjectsNewEntry = 1,
    kInsertTableEntry = 2,
    kChangeTableEntry = 3,
    kDeleteTableEntry = 4,
    kInsertConditionalEntry = 5,
    kChangeConditionalEntry = 6,
    kDeleteConditionalEntry = 7,
    kInsertFlexEntry = 8,
    kChangeFlexEntry = 9,
    kDeleteFlexEntry = 10,
    kInsertRegisterArrayEntry = 11,
    kChangeRegisterArrayEntry = 12,
    kDeleteRegisterArrayEntry = 13,
    kTriggerEntry = 14,
    kChangeInitEntry = 15,
    CONTENT_NOT_SET = 0,
  };

  static inline const RuntimeReconfigContent* internal_default_instance() {
    return reinterpret_cast<const RuntimeReconfigContent*>(
               &_RuntimeReconfigContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RuntimeReconfigContent& a, RuntimeReconfigContent& b) {
    a.Swap(&b);
  }
  inline void Swap(RuntimeReconfigContent* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RuntimeReconfigContent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RuntimeReconfigContent* New() const final {
    return new RuntimeReconfigContent();
  }

  RuntimeReconfigContent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RuntimeReconfigContent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RuntimeReconfigContent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RuntimeReconfigContent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RuntimeReconfigContent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.RuntimeReconfigContent";
  }
  protected:
  explicit RuntimeReconfigContent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitP4ObjectsNewEntryFieldNumber = 1,
    kInsertTableEntryFieldNumber = 2,
    kChangeTableEntryFieldNumber = 3,
    kDeleteTableEntryFieldNumber = 4,
    kInsertConditionalEntryFieldNumber = 5,
    kChangeConditionalEntryFieldNumber = 6,
    kDeleteConditionalEntryFieldNumber = 7,
    kInsertFlexEntryFieldNumber = 8,
    kChangeFlexEntryFieldNumber = 9,
    kDeleteFlexEntryFieldNumber = 10,
    kInsertRegisterArrayEntryFieldNumber = 11,
    kChangeRegisterArrayEntryFieldNumber = 12,
    kDeleteRegisterArrayEntryFieldNumber = 13,
    kTriggerEntryFieldNumber = 14,
    kChangeInitEntryFieldNumber = 15,
  };
  // .p4.v1.InitP4ObjectsNewEntry init_p4objects_new_entry = 1;
  bool has_init_p4objects_new_entry() const;
  private:
  bool _internal_has_init_p4objects_new_entry() const;
  public:
  void clear_init_p4objects_new_entry();
  const ::p4::v1::InitP4ObjectsNewEntry& init_p4objects_new_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::InitP4ObjectsNewEntry* release_init_p4objects_new_entry();
  ::p4::v1::InitP4ObjectsNewEntry* mutable_init_p4objects_new_entry();
  void set_allocated_init_p4objects_new_entry(::p4::v1::InitP4ObjectsNewEntry* init_p4objects_new_entry);
  private:
  const ::p4::v1::InitP4ObjectsNewEntry& _internal_init_p4objects_new_entry() const;
  ::p4::v1::InitP4ObjectsNewEntry* _internal_mutable_init_p4objects_new_entry();
  public:
  void unsafe_arena_set_allocated_init_p4objects_new_entry(
      ::p4::v1::InitP4ObjectsNewEntry* init_p4objects_new_entry);
  ::p4::v1::InitP4ObjectsNewEntry* unsafe_arena_release_init_p4objects_new_entry();

  // .p4.v1.InsertTableEntry insert_table_entry = 2;
  bool has_insert_table_entry() const;
  private:
  bool _internal_has_insert_table_entry() const;
  public:
  void clear_insert_table_entry();
  const ::p4::v1::InsertTableEntry& insert_table_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::InsertTableEntry* release_insert_table_entry();
  ::p4::v1::InsertTableEntry* mutable_insert_table_entry();
  void set_allocated_insert_table_entry(::p4::v1::InsertTableEntry* insert_table_entry);
  private:
  const ::p4::v1::InsertTableEntry& _internal_insert_table_entry() const;
  ::p4::v1::InsertTableEntry* _internal_mutable_insert_table_entry();
  public:
  void unsafe_arena_set_allocated_insert_table_entry(
      ::p4::v1::InsertTableEntry* insert_table_entry);
  ::p4::v1::InsertTableEntry* unsafe_arena_release_insert_table_entry();

  // .p4.v1.ChangeTableEntry change_table_entry = 3;
  bool has_change_table_entry() const;
  private:
  bool _internal_has_change_table_entry() const;
  public:
  void clear_change_table_entry();
  const ::p4::v1::ChangeTableEntry& change_table_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::ChangeTableEntry* release_change_table_entry();
  ::p4::v1::ChangeTableEntry* mutable_change_table_entry();
  void set_allocated_change_table_entry(::p4::v1::ChangeTableEntry* change_table_entry);
  private:
  const ::p4::v1::ChangeTableEntry& _internal_change_table_entry() const;
  ::p4::v1::ChangeTableEntry* _internal_mutable_change_table_entry();
  public:
  void unsafe_arena_set_allocated_change_table_entry(
      ::p4::v1::ChangeTableEntry* change_table_entry);
  ::p4::v1::ChangeTableEntry* unsafe_arena_release_change_table_entry();

  // .p4.v1.DeleteTableEntry delete_table_entry = 4;
  bool has_delete_table_entry() const;
  private:
  bool _internal_has_delete_table_entry() const;
  public:
  void clear_delete_table_entry();
  const ::p4::v1::DeleteTableEntry& delete_table_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::DeleteTableEntry* release_delete_table_entry();
  ::p4::v1::DeleteTableEntry* mutable_delete_table_entry();
  void set_allocated_delete_table_entry(::p4::v1::DeleteTableEntry* delete_table_entry);
  private:
  const ::p4::v1::DeleteTableEntry& _internal_delete_table_entry() const;
  ::p4::v1::DeleteTableEntry* _internal_mutable_delete_table_entry();
  public:
  void unsafe_arena_set_allocated_delete_table_entry(
      ::p4::v1::DeleteTableEntry* delete_table_entry);
  ::p4::v1::DeleteTableEntry* unsafe_arena_release_delete_table_entry();

  // .p4.v1.InsertConditionalEntry insert_conditional_entry = 5;
  bool has_insert_conditional_entry() const;
  private:
  bool _internal_has_insert_conditional_entry() const;
  public:
  void clear_insert_conditional_entry();
  const ::p4::v1::InsertConditionalEntry& insert_conditional_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::InsertConditionalEntry* release_insert_conditional_entry();
  ::p4::v1::InsertConditionalEntry* mutable_insert_conditional_entry();
  void set_allocated_insert_conditional_entry(::p4::v1::InsertConditionalEntry* insert_conditional_entry);
  private:
  const ::p4::v1::InsertConditionalEntry& _internal_insert_conditional_entry() const;
  ::p4::v1::InsertConditionalEntry* _internal_mutable_insert_conditional_entry();
  public:
  void unsafe_arena_set_allocated_insert_conditional_entry(
      ::p4::v1::InsertConditionalEntry* insert_conditional_entry);
  ::p4::v1::InsertConditionalEntry* unsafe_arena_release_insert_conditional_entry();

  // .p4.v1.ChangeConditionalEntry change_conditional_entry = 6;
  bool has_change_conditional_entry() const;
  private:
  bool _internal_has_change_conditional_entry() const;
  public:
  void clear_change_conditional_entry();
  const ::p4::v1::ChangeConditionalEntry& change_conditional_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::ChangeConditionalEntry* release_change_conditional_entry();
  ::p4::v1::ChangeConditionalEntry* mutable_change_conditional_entry();
  void set_allocated_change_conditional_entry(::p4::v1::ChangeConditionalEntry* change_conditional_entry);
  private:
  const ::p4::v1::ChangeConditionalEntry& _internal_change_conditional_entry() const;
  ::p4::v1::ChangeConditionalEntry* _internal_mutable_change_conditional_entry();
  public:
  void unsafe_arena_set_allocated_change_conditional_entry(
      ::p4::v1::ChangeConditionalEntry* change_conditional_entry);
  ::p4::v1::ChangeConditionalEntry* unsafe_arena_release_change_conditional_entry();

  // .p4.v1.DeleteConditionalEntry delete_conditional_entry = 7;
  bool has_delete_conditional_entry() const;
  private:
  bool _internal_has_delete_conditional_entry() const;
  public:
  void clear_delete_conditional_entry();
  const ::p4::v1::DeleteConditionalEntry& delete_conditional_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::DeleteConditionalEntry* release_delete_conditional_entry();
  ::p4::v1::DeleteConditionalEntry* mutable_delete_conditional_entry();
  void set_allocated_delete_conditional_entry(::p4::v1::DeleteConditionalEntry* delete_conditional_entry);
  private:
  const ::p4::v1::DeleteConditionalEntry& _internal_delete_conditional_entry() const;
  ::p4::v1::DeleteConditionalEntry* _internal_mutable_delete_conditional_entry();
  public:
  void unsafe_arena_set_allocated_delete_conditional_entry(
      ::p4::v1::DeleteConditionalEntry* delete_conditional_entry);
  ::p4::v1::DeleteConditionalEntry* unsafe_arena_release_delete_conditional_entry();

  // .p4.v1.InsertFlexEntry insert_flex_entry = 8;
  bool has_insert_flex_entry() const;
  private:
  bool _internal_has_insert_flex_entry() const;
  public:
  void clear_insert_flex_entry();
  const ::p4::v1::InsertFlexEntry& insert_flex_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::InsertFlexEntry* release_insert_flex_entry();
  ::p4::v1::InsertFlexEntry* mutable_insert_flex_entry();
  void set_allocated_insert_flex_entry(::p4::v1::InsertFlexEntry* insert_flex_entry);
  private:
  const ::p4::v1::InsertFlexEntry& _internal_insert_flex_entry() const;
  ::p4::v1::InsertFlexEntry* _internal_mutable_insert_flex_entry();
  public:
  void unsafe_arena_set_allocated_insert_flex_entry(
      ::p4::v1::InsertFlexEntry* insert_flex_entry);
  ::p4::v1::InsertFlexEntry* unsafe_arena_release_insert_flex_entry();

  // .p4.v1.ChangeFlexEntry change_flex_entry = 9;
  bool has_change_flex_entry() const;
  private:
  bool _internal_has_change_flex_entry() const;
  public:
  void clear_change_flex_entry();
  const ::p4::v1::ChangeFlexEntry& change_flex_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::ChangeFlexEntry* release_change_flex_entry();
  ::p4::v1::ChangeFlexEntry* mutable_change_flex_entry();
  void set_allocated_change_flex_entry(::p4::v1::ChangeFlexEntry* change_flex_entry);
  private:
  const ::p4::v1::ChangeFlexEntry& _internal_change_flex_entry() const;
  ::p4::v1::ChangeFlexEntry* _internal_mutable_change_flex_entry();
  public:
  void unsafe_arena_set_allocated_change_flex_entry(
      ::p4::v1::ChangeFlexEntry* change_flex_entry);
  ::p4::v1::ChangeFlexEntry* unsafe_arena_release_change_flex_entry();

  // .p4.v1.DeleteFlexEntry delete_flex_entry = 10;
  bool has_delete_flex_entry() const;
  private:
  bool _internal_has_delete_flex_entry() const;
  public:
  void clear_delete_flex_entry();
  const ::p4::v1::DeleteFlexEntry& delete_flex_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::DeleteFlexEntry* release_delete_flex_entry();
  ::p4::v1::DeleteFlexEntry* mutable_delete_flex_entry();
  void set_allocated_delete_flex_entry(::p4::v1::DeleteFlexEntry* delete_flex_entry);
  private:
  const ::p4::v1::DeleteFlexEntry& _internal_delete_flex_entry() const;
  ::p4::v1::DeleteFlexEntry* _internal_mutable_delete_flex_entry();
  public:
  void unsafe_arena_set_allocated_delete_flex_entry(
      ::p4::v1::DeleteFlexEntry* delete_flex_entry);
  ::p4::v1::DeleteFlexEntry* unsafe_arena_release_delete_flex_entry();

  // .p4.v1.InsertRegisterArrayEntry insert_register_array_entry = 11;
  bool has_insert_register_array_entry() const;
  private:
  bool _internal_has_insert_register_array_entry() const;
  public:
  void clear_insert_register_array_entry();
  const ::p4::v1::InsertRegisterArrayEntry& insert_register_array_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::InsertRegisterArrayEntry* release_insert_register_array_entry();
  ::p4::v1::InsertRegisterArrayEntry* mutable_insert_register_array_entry();
  void set_allocated_insert_register_array_entry(::p4::v1::InsertRegisterArrayEntry* insert_register_array_entry);
  private:
  const ::p4::v1::InsertRegisterArrayEntry& _internal_insert_register_array_entry() const;
  ::p4::v1::InsertRegisterArrayEntry* _internal_mutable_insert_register_array_entry();
  public:
  void unsafe_arena_set_allocated_insert_register_array_entry(
      ::p4::v1::InsertRegisterArrayEntry* insert_register_array_entry);
  ::p4::v1::InsertRegisterArrayEntry* unsafe_arena_release_insert_register_array_entry();

  // .p4.v1.ChangeRegisterArrayEntry change_register_array_entry = 12;
  bool has_change_register_array_entry() const;
  private:
  bool _internal_has_change_register_array_entry() const;
  public:
  void clear_change_register_array_entry();
  const ::p4::v1::ChangeRegisterArrayEntry& change_register_array_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::ChangeRegisterArrayEntry* release_change_register_array_entry();
  ::p4::v1::ChangeRegisterArrayEntry* mutable_change_register_array_entry();
  void set_allocated_change_register_array_entry(::p4::v1::ChangeRegisterArrayEntry* change_register_array_entry);
  private:
  const ::p4::v1::ChangeRegisterArrayEntry& _internal_change_register_array_entry() const;
  ::p4::v1::ChangeRegisterArrayEntry* _internal_mutable_change_register_array_entry();
  public:
  void unsafe_arena_set_allocated_change_register_array_entry(
      ::p4::v1::ChangeRegisterArrayEntry* change_register_array_entry);
  ::p4::v1::ChangeRegisterArrayEntry* unsafe_arena_release_change_register_array_entry();

  // .p4.v1.DeleteRegisterArrayEntry delete_register_array_entry = 13;
  bool has_delete_register_array_entry() const;
  private:
  bool _internal_has_delete_register_array_entry() const;
  public:
  void clear_delete_register_array_entry();
  const ::p4::v1::DeleteRegisterArrayEntry& delete_register_array_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::DeleteRegisterArrayEntry* release_delete_register_array_entry();
  ::p4::v1::DeleteRegisterArrayEntry* mutable_delete_register_array_entry();
  void set_allocated_delete_register_array_entry(::p4::v1::DeleteRegisterArrayEntry* delete_register_array_entry);
  private:
  const ::p4::v1::DeleteRegisterArrayEntry& _internal_delete_register_array_entry() const;
  ::p4::v1::DeleteRegisterArrayEntry* _internal_mutable_delete_register_array_entry();
  public:
  void unsafe_arena_set_allocated_delete_register_array_entry(
      ::p4::v1::DeleteRegisterArrayEntry* delete_register_array_entry);
  ::p4::v1::DeleteRegisterArrayEntry* unsafe_arena_release_delete_register_array_entry();

  // .p4.v1.TriggerEntry trigger_entry = 14;
  bool has_trigger_entry() const;
  private:
  bool _internal_has_trigger_entry() const;
  public:
  void clear_trigger_entry();
  const ::p4::v1::TriggerEntry& trigger_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::TriggerEntry* release_trigger_entry();
  ::p4::v1::TriggerEntry* mutable_trigger_entry();
  void set_allocated_trigger_entry(::p4::v1::TriggerEntry* trigger_entry);
  private:
  const ::p4::v1::TriggerEntry& _internal_trigger_entry() const;
  ::p4::v1::TriggerEntry* _internal_mutable_trigger_entry();
  public:
  void unsafe_arena_set_allocated_trigger_entry(
      ::p4::v1::TriggerEntry* trigger_entry);
  ::p4::v1::TriggerEntry* unsafe_arena_release_trigger_entry();

  // .p4.v1.ChangeInitEntry change_init_entry = 15;
  bool has_change_init_entry() const;
  private:
  bool _internal_has_change_init_entry() const;
  public:
  void clear_change_init_entry();
  const ::p4::v1::ChangeInitEntry& change_init_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::ChangeInitEntry* release_change_init_entry();
  ::p4::v1::ChangeInitEntry* mutable_change_init_entry();
  void set_allocated_change_init_entry(::p4::v1::ChangeInitEntry* change_init_entry);
  private:
  const ::p4::v1::ChangeInitEntry& _internal_change_init_entry() const;
  ::p4::v1::ChangeInitEntry* _internal_mutable_change_init_entry();
  public:
  void unsafe_arena_set_allocated_change_init_entry(
      ::p4::v1::ChangeInitEntry* change_init_entry);
  ::p4::v1::ChangeInitEntry* unsafe_arena_release_change_init_entry();

  void clear_content();
  ContentCase content_case() const;
  // @@protoc_insertion_point(class_scope:p4.v1.RuntimeReconfigContent)
 private:
  class _Internal;
  void set_has_init_p4objects_new_entry();
  void set_has_insert_table_entry();
  void set_has_change_table_entry();
  void set_has_delete_table_entry();
  void set_has_insert_conditional_entry();
  void set_has_change_conditional_entry();
  void set_has_delete_conditional_entry();
  void set_has_insert_flex_entry();
  void set_has_change_flex_entry();
  void set_has_delete_flex_entry();
  void set_has_insert_register_array_entry();
  void set_has_change_register_array_entry();
  void set_has_delete_register_array_entry();
  void set_has_trigger_entry();
  void set_has_change_init_entry();

  inline bool has_content() const;
  inline void clear_has_content();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ContentUnion {
    constexpr ContentUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::p4::v1::InitP4ObjectsNewEntry* init_p4objects_new_entry_;
    ::p4::v1::InsertTableEntry* insert_table_entry_;
    ::p4::v1::ChangeTableEntry* change_table_entry_;
    ::p4::v1::DeleteTableEntry* delete_table_entry_;
    ::p4::v1::InsertConditionalEntry* insert_conditional_entry_;
    ::p4::v1::ChangeConditionalEntry* change_conditional_entry_;
    ::p4::v1::DeleteConditionalEntry* delete_conditional_entry_;
    ::p4::v1::InsertFlexEntry* insert_flex_entry_;
    ::p4::v1::ChangeFlexEntry* change_flex_entry_;
    ::p4::v1::DeleteFlexEntry* delete_flex_entry_;
    ::p4::v1::InsertRegisterArrayEntry* insert_register_array_entry_;
    ::p4::v1::ChangeRegisterArrayEntry* change_register_array_entry_;
    ::p4::v1::DeleteRegisterArrayEntry* delete_register_array_entry_;
    ::p4::v1::TriggerEntry* trigger_entry_;
    ::p4::v1::ChangeInitEntry* change_init_entry_;
  } content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class InitP4ObjectsNewEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.InitP4ObjectsNewEntry) */ {
 public:
  inline InitP4ObjectsNewEntry() : InitP4ObjectsNewEntry(nullptr) {}
  ~InitP4ObjectsNewEntry() override;
  explicit constexpr InitP4ObjectsNewEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitP4ObjectsNewEntry(const InitP4ObjectsNewEntry& from);
  InitP4ObjectsNewEntry(InitP4ObjectsNewEntry&& from) noexcept
    : InitP4ObjectsNewEntry() {
    *this = ::std::move(from);
  }

  inline InitP4ObjectsNewEntry& operator=(const InitP4ObjectsNewEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitP4ObjectsNewEntry& operator=(InitP4ObjectsNewEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitP4ObjectsNewEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitP4ObjectsNewEntry* internal_default_instance() {
    return reinterpret_cast<const InitP4ObjectsNewEntry*>(
               &_InitP4ObjectsNewEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(InitP4ObjectsNewEntry& a, InitP4ObjectsNewEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(InitP4ObjectsNewEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitP4ObjectsNewEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InitP4ObjectsNewEntry* New() const final {
    return new InitP4ObjectsNewEntry();
  }

  InitP4ObjectsNewEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InitP4ObjectsNewEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitP4ObjectsNewEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InitP4ObjectsNewEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitP4ObjectsNewEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.InitP4ObjectsNewEntry";
  }
  protected:
  explicit InitP4ObjectsNewEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kP4ObjectsNewJsonFieldNumber = 1,
  };
  // bytes p4objects_new_json = 1;
  void clear_p4objects_new_json();
  const std::string& p4objects_new_json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_p4objects_new_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_p4objects_new_json();
  PROTOBUF_MUST_USE_RESULT std::string* release_p4objects_new_json();
  void set_allocated_p4objects_new_json(std::string* p4objects_new_json);
  private:
  const std::string& _internal_p4objects_new_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_p4objects_new_json(const std::string& value);
  std::string* _internal_mutable_p4objects_new_json();
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.InitP4ObjectsNewEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr p4objects_new_json_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class InsertTableEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.InsertTableEntry) */ {
 public:
  inline InsertTableEntry() : InsertTableEntry(nullptr) {}
  ~InsertTableEntry() override;
  explicit constexpr InsertTableEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertTableEntry(const InsertTableEntry& from);
  InsertTableEntry(InsertTableEntry&& from) noexcept
    : InsertTableEntry() {
    *this = ::std::move(from);
  }

  inline InsertTableEntry& operator=(const InsertTableEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertTableEntry& operator=(InsertTableEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertTableEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertTableEntry* internal_default_instance() {
    return reinterpret_cast<const InsertTableEntry*>(
               &_InsertTableEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(InsertTableEntry& a, InsertTableEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertTableEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertTableEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsertTableEntry* New() const final {
    return new InsertTableEntry();
  }

  InsertTableEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsertTableEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertTableEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InsertTableEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertTableEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.InsertTableEntry";
  }
  protected:
  explicit InsertTableEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPipelineNameFieldNumber = 1,
    kTableNameFieldNumber = 2,
  };
  // string pipeline_name = 1;
  void clear_pipeline_name();
  const std::string& pipeline_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pipeline_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pipeline_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_pipeline_name();
  void set_allocated_pipeline_name(std::string* pipeline_name);
  private:
  const std::string& _internal_pipeline_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pipeline_name(const std::string& value);
  std::string* _internal_mutable_pipeline_name();
  public:

  // string table_name = 2;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.InsertTableEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pipeline_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class ChangeTableEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.ChangeTableEntry) */ {
 public:
  inline ChangeTableEntry() : ChangeTableEntry(nullptr) {}
  ~ChangeTableEntry() override;
  explicit constexpr ChangeTableEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeTableEntry(const ChangeTableEntry& from);
  ChangeTableEntry(ChangeTableEntry&& from) noexcept
    : ChangeTableEntry() {
    *this = ::std::move(from);
  }

  inline ChangeTableEntry& operator=(const ChangeTableEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeTableEntry& operator=(ChangeTableEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeTableEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeTableEntry* internal_default_instance() {
    return reinterpret_cast<const ChangeTableEntry*>(
               &_ChangeTableEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ChangeTableEntry& a, ChangeTableEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeTableEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeTableEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChangeTableEntry* New() const final {
    return new ChangeTableEntry();
  }

  ChangeTableEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChangeTableEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeTableEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeTableEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeTableEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.ChangeTableEntry";
  }
  protected:
  explicit ChangeTableEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPipelineNameFieldNumber = 1,
    kTableNameFieldNumber = 2,
    kEdgeNameFieldNumber = 3,
    kTableNameNextFieldNumber = 4,
  };
  // string pipeline_name = 1;
  void clear_pipeline_name();
  const std::string& pipeline_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pipeline_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pipeline_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_pipeline_name();
  void set_allocated_pipeline_name(std::string* pipeline_name);
  private:
  const std::string& _internal_pipeline_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pipeline_name(const std::string& value);
  std::string* _internal_mutable_pipeline_name();
  public:

  // string table_name = 2;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // string edge_name = 3;
  void clear_edge_name();
  const std::string& edge_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_edge_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_edge_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_edge_name();
  void set_allocated_edge_name(std::string* edge_name);
  private:
  const std::string& _internal_edge_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_edge_name(const std::string& value);
  std::string* _internal_mutable_edge_name();
  public:

  // string table_name_next = 4;
  void clear_table_name_next();
  const std::string& table_name_next() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name_next(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name_next();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name_next();
  void set_allocated_table_name_next(std::string* table_name_next);
  private:
  const std::string& _internal_table_name_next() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name_next(const std::string& value);
  std::string* _internal_mutable_table_name_next();
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.ChangeTableEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pipeline_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr edge_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_next_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class DeleteTableEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.DeleteTableEntry) */ {
 public:
  inline DeleteTableEntry() : DeleteTableEntry(nullptr) {}
  ~DeleteTableEntry() override;
  explicit constexpr DeleteTableEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteTableEntry(const DeleteTableEntry& from);
  DeleteTableEntry(DeleteTableEntry&& from) noexcept
    : DeleteTableEntry() {
    *this = ::std::move(from);
  }

  inline DeleteTableEntry& operator=(const DeleteTableEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteTableEntry& operator=(DeleteTableEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteTableEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteTableEntry* internal_default_instance() {
    return reinterpret_cast<const DeleteTableEntry*>(
               &_DeleteTableEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DeleteTableEntry& a, DeleteTableEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteTableEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteTableEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteTableEntry* New() const final {
    return new DeleteTableEntry();
  }

  DeleteTableEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteTableEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteTableEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteTableEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteTableEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.DeleteTableEntry";
  }
  protected:
  explicit DeleteTableEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPipelineNameFieldNumber = 1,
    kTableNameFieldNumber = 2,
  };
  // string pipeline_name = 1;
  void clear_pipeline_name();
  const std::string& pipeline_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pipeline_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pipeline_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_pipeline_name();
  void set_allocated_pipeline_name(std::string* pipeline_name);
  private:
  const std::string& _internal_pipeline_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pipeline_name(const std::string& value);
  std::string* _internal_mutable_pipeline_name();
  public:

  // string table_name = 2;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.DeleteTableEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pipeline_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class InsertConditionalEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.InsertConditionalEntry) */ {
 public:
  inline InsertConditionalEntry() : InsertConditionalEntry(nullptr) {}
  ~InsertConditionalEntry() override;
  explicit constexpr InsertConditionalEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertConditionalEntry(const InsertConditionalEntry& from);
  InsertConditionalEntry(InsertConditionalEntry&& from) noexcept
    : InsertConditionalEntry() {
    *this = ::std::move(from);
  }

  inline InsertConditionalEntry& operator=(const InsertConditionalEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertConditionalEntry& operator=(InsertConditionalEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertConditionalEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertConditionalEntry* internal_default_instance() {
    return reinterpret_cast<const InsertConditionalEntry*>(
               &_InsertConditionalEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(InsertConditionalEntry& a, InsertConditionalEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertConditionalEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertConditionalEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsertConditionalEntry* New() const final {
    return new InsertConditionalEntry();
  }

  InsertConditionalEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsertConditionalEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertConditionalEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InsertConditionalEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertConditionalEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.InsertConditionalEntry";
  }
  protected:
  explicit InsertConditionalEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPipelineNameFieldNumber = 1,
    kBranchNameFieldNumber = 2,
  };
  // string pipeline_name = 1;
  void clear_pipeline_name();
  const std::string& pipeline_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pipeline_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pipeline_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_pipeline_name();
  void set_allocated_pipeline_name(std::string* pipeline_name);
  private:
  const std::string& _internal_pipeline_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pipeline_name(const std::string& value);
  std::string* _internal_mutable_pipeline_name();
  public:

  // string branch_name = 2;
  void clear_branch_name();
  const std::string& branch_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_branch_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_branch_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_branch_name();
  void set_allocated_branch_name(std::string* branch_name);
  private:
  const std::string& _internal_branch_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_branch_name(const std::string& value);
  std::string* _internal_mutable_branch_name();
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.InsertConditionalEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pipeline_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr branch_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class ChangeConditionalEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.ChangeConditionalEntry) */ {
 public:
  inline ChangeConditionalEntry() : ChangeConditionalEntry(nullptr) {}
  ~ChangeConditionalEntry() override;
  explicit constexpr ChangeConditionalEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeConditionalEntry(const ChangeConditionalEntry& from);
  ChangeConditionalEntry(ChangeConditionalEntry&& from) noexcept
    : ChangeConditionalEntry() {
    *this = ::std::move(from);
  }

  inline ChangeConditionalEntry& operator=(const ChangeConditionalEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeConditionalEntry& operator=(ChangeConditionalEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeConditionalEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeConditionalEntry* internal_default_instance() {
    return reinterpret_cast<const ChangeConditionalEntry*>(
               &_ChangeConditionalEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ChangeConditionalEntry& a, ChangeConditionalEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeConditionalEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeConditionalEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChangeConditionalEntry* New() const final {
    return new ChangeConditionalEntry();
  }

  ChangeConditionalEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChangeConditionalEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeConditionalEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeConditionalEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeConditionalEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.ChangeConditionalEntry";
  }
  protected:
  explicit ChangeConditionalEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPipelineNameFieldNumber = 1,
    kBranchNameFieldNumber = 2,
    kNodeNameFieldNumber = 4,
    kTrueOrFalseNextFieldNumber = 3,
  };
  // string pipeline_name = 1;
  void clear_pipeline_name();
  const std::string& pipeline_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pipeline_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pipeline_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_pipeline_name();
  void set_allocated_pipeline_name(std::string* pipeline_name);
  private:
  const std::string& _internal_pipeline_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pipeline_name(const std::string& value);
  std::string* _internal_mutable_pipeline_name();
  public:

  // string branch_name = 2;
  void clear_branch_name();
  const std::string& branch_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_branch_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_branch_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_branch_name();
  void set_allocated_branch_name(std::string* branch_name);
  private:
  const std::string& _internal_branch_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_branch_name(const std::string& value);
  std::string* _internal_mutable_branch_name();
  public:

  // string node_name = 4;
  void clear_node_name();
  const std::string& node_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_node_name();
  void set_allocated_node_name(std::string* node_name);
  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(const std::string& value);
  std::string* _internal_mutable_node_name();
  public:

  // bool true_or_false_next = 3;
  void clear_true_or_false_next();
  bool true_or_false_next() const;
  void set_true_or_false_next(bool value);
  private:
  bool _internal_true_or_false_next() const;
  void _internal_set_true_or_false_next(bool value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.ChangeConditionalEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pipeline_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr branch_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_name_;
  bool true_or_false_next_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class DeleteConditionalEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.DeleteConditionalEntry) */ {
 public:
  inline DeleteConditionalEntry() : DeleteConditionalEntry(nullptr) {}
  ~DeleteConditionalEntry() override;
  explicit constexpr DeleteConditionalEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteConditionalEntry(const DeleteConditionalEntry& from);
  DeleteConditionalEntry(DeleteConditionalEntry&& from) noexcept
    : DeleteConditionalEntry() {
    *this = ::std::move(from);
  }

  inline DeleteConditionalEntry& operator=(const DeleteConditionalEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteConditionalEntry& operator=(DeleteConditionalEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteConditionalEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteConditionalEntry* internal_default_instance() {
    return reinterpret_cast<const DeleteConditionalEntry*>(
               &_DeleteConditionalEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DeleteConditionalEntry& a, DeleteConditionalEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteConditionalEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteConditionalEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteConditionalEntry* New() const final {
    return new DeleteConditionalEntry();
  }

  DeleteConditionalEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteConditionalEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteConditionalEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteConditionalEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteConditionalEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.DeleteConditionalEntry";
  }
  protected:
  explicit DeleteConditionalEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPipelineNameFieldNumber = 1,
    kBranchNameFieldNumber = 2,
  };
  // string pipeline_name = 1;
  void clear_pipeline_name();
  const std::string& pipeline_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pipeline_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pipeline_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_pipeline_name();
  void set_allocated_pipeline_name(std::string* pipeline_name);
  private:
  const std::string& _internal_pipeline_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pipeline_name(const std::string& value);
  std::string* _internal_mutable_pipeline_name();
  public:

  // string branch_name = 2;
  void clear_branch_name();
  const std::string& branch_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_branch_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_branch_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_branch_name();
  void set_allocated_branch_name(std::string* branch_name);
  private:
  const std::string& _internal_branch_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_branch_name(const std::string& value);
  std::string* _internal_mutable_branch_name();
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.DeleteConditionalEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pipeline_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr branch_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class InsertFlexEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.InsertFlexEntry) */ {
 public:
  inline InsertFlexEntry() : InsertFlexEntry(nullptr) {}
  ~InsertFlexEntry() override;
  explicit constexpr InsertFlexEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertFlexEntry(const InsertFlexEntry& from);
  InsertFlexEntry(InsertFlexEntry&& from) noexcept
    : InsertFlexEntry() {
    *this = ::std::move(from);
  }

  inline InsertFlexEntry& operator=(const InsertFlexEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertFlexEntry& operator=(InsertFlexEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertFlexEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertFlexEntry* internal_default_instance() {
    return reinterpret_cast<const InsertFlexEntry*>(
               &_InsertFlexEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(InsertFlexEntry& a, InsertFlexEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertFlexEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertFlexEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsertFlexEntry* New() const final {
    return new InsertFlexEntry();
  }

  InsertFlexEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsertFlexEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertFlexEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InsertFlexEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertFlexEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.InsertFlexEntry";
  }
  protected:
  explicit InsertFlexEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPipelineNameFieldNumber = 1,
    kNodeNameFieldNumber = 2,
    kTrueNextNodeFieldNumber = 3,
    kFalseNextNodeFieldNumber = 4,
  };
  // string pipeline_name = 1;
  void clear_pipeline_name();
  const std::string& pipeline_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pipeline_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pipeline_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_pipeline_name();
  void set_allocated_pipeline_name(std::string* pipeline_name);
  private:
  const std::string& _internal_pipeline_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pipeline_name(const std::string& value);
  std::string* _internal_mutable_pipeline_name();
  public:

  // string node_name = 2;
  void clear_node_name();
  const std::string& node_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_node_name();
  void set_allocated_node_name(std::string* node_name);
  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(const std::string& value);
  std::string* _internal_mutable_node_name();
  public:

  // string true_next_node = 3;
  void clear_true_next_node();
  const std::string& true_next_node() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_true_next_node(ArgT0&& arg0, ArgT... args);
  std::string* mutable_true_next_node();
  PROTOBUF_MUST_USE_RESULT std::string* release_true_next_node();
  void set_allocated_true_next_node(std::string* true_next_node);
  private:
  const std::string& _internal_true_next_node() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_true_next_node(const std::string& value);
  std::string* _internal_mutable_true_next_node();
  public:

  // string false_next_node = 4;
  void clear_false_next_node();
  const std::string& false_next_node() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_false_next_node(ArgT0&& arg0, ArgT... args);
  std::string* mutable_false_next_node();
  PROTOBUF_MUST_USE_RESULT std::string* release_false_next_node();
  void set_allocated_false_next_node(std::string* false_next_node);
  private:
  const std::string& _internal_false_next_node() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_false_next_node(const std::string& value);
  std::string* _internal_mutable_false_next_node();
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.InsertFlexEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pipeline_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr true_next_node_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr false_next_node_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class ChangeFlexEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.ChangeFlexEntry) */ {
 public:
  inline ChangeFlexEntry() : ChangeFlexEntry(nullptr) {}
  ~ChangeFlexEntry() override;
  explicit constexpr ChangeFlexEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeFlexEntry(const ChangeFlexEntry& from);
  ChangeFlexEntry(ChangeFlexEntry&& from) noexcept
    : ChangeFlexEntry() {
    *this = ::std::move(from);
  }

  inline ChangeFlexEntry& operator=(const ChangeFlexEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeFlexEntry& operator=(ChangeFlexEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeFlexEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeFlexEntry* internal_default_instance() {
    return reinterpret_cast<const ChangeFlexEntry*>(
               &_ChangeFlexEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ChangeFlexEntry& a, ChangeFlexEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeFlexEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeFlexEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChangeFlexEntry* New() const final {
    return new ChangeFlexEntry();
  }

  ChangeFlexEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChangeFlexEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeFlexEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeFlexEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeFlexEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.ChangeFlexEntry";
  }
  protected:
  explicit ChangeFlexEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPipelineNameFieldNumber = 1,
    kFlxNameFieldNumber = 2,
    kNodeNextFieldNumber = 4,
    kTrueOrFalseNextFieldNumber = 3,
  };
  // string pipeline_name = 1;
  void clear_pipeline_name();
  const std::string& pipeline_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pipeline_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pipeline_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_pipeline_name();
  void set_allocated_pipeline_name(std::string* pipeline_name);
  private:
  const std::string& _internal_pipeline_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pipeline_name(const std::string& value);
  std::string* _internal_mutable_pipeline_name();
  public:

  // string flx_name = 2;
  void clear_flx_name();
  const std::string& flx_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_flx_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_flx_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_flx_name();
  void set_allocated_flx_name(std::string* flx_name);
  private:
  const std::string& _internal_flx_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_flx_name(const std::string& value);
  std::string* _internal_mutable_flx_name();
  public:

  // string node_next = 4;
  void clear_node_next();
  const std::string& node_next() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_next(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_next();
  PROTOBUF_MUST_USE_RESULT std::string* release_node_next();
  void set_allocated_node_next(std::string* node_next);
  private:
  const std::string& _internal_node_next() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_next(const std::string& value);
  std::string* _internal_mutable_node_next();
  public:

  // bool true_or_false_next = 3;
  void clear_true_or_false_next();
  bool true_or_false_next() const;
  void set_true_or_false_next(bool value);
  private:
  bool _internal_true_or_false_next() const;
  void _internal_set_true_or_false_next(bool value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.ChangeFlexEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pipeline_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr flx_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_next_;
  bool true_or_false_next_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class DeleteFlexEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.DeleteFlexEntry) */ {
 public:
  inline DeleteFlexEntry() : DeleteFlexEntry(nullptr) {}
  ~DeleteFlexEntry() override;
  explicit constexpr DeleteFlexEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteFlexEntry(const DeleteFlexEntry& from);
  DeleteFlexEntry(DeleteFlexEntry&& from) noexcept
    : DeleteFlexEntry() {
    *this = ::std::move(from);
  }

  inline DeleteFlexEntry& operator=(const DeleteFlexEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFlexEntry& operator=(DeleteFlexEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFlexEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFlexEntry* internal_default_instance() {
    return reinterpret_cast<const DeleteFlexEntry*>(
               &_DeleteFlexEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DeleteFlexEntry& a, DeleteFlexEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFlexEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFlexEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteFlexEntry* New() const final {
    return new DeleteFlexEntry();
  }

  DeleteFlexEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteFlexEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteFlexEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteFlexEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFlexEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.DeleteFlexEntry";
  }
  protected:
  explicit DeleteFlexEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPipelineNameFieldNumber = 1,
    kFlxNameFieldNumber = 2,
  };
  // string pipeline_name = 1;
  void clear_pipeline_name();
  const std::string& pipeline_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pipeline_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pipeline_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_pipeline_name();
  void set_allocated_pipeline_name(std::string* pipeline_name);
  private:
  const std::string& _internal_pipeline_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pipeline_name(const std::string& value);
  std::string* _internal_mutable_pipeline_name();
  public:

  // string flx_name = 2;
  void clear_flx_name();
  const std::string& flx_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_flx_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_flx_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_flx_name();
  void set_allocated_flx_name(std::string* flx_name);
  private:
  const std::string& _internal_flx_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_flx_name(const std::string& value);
  std::string* _internal_mutable_flx_name();
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.DeleteFlexEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pipeline_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr flx_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class InsertRegisterArrayEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.InsertRegisterArrayEntry) */ {
 public:
  inline InsertRegisterArrayEntry() : InsertRegisterArrayEntry(nullptr) {}
  ~InsertRegisterArrayEntry() override;
  explicit constexpr InsertRegisterArrayEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertRegisterArrayEntry(const InsertRegisterArrayEntry& from);
  InsertRegisterArrayEntry(InsertRegisterArrayEntry&& from) noexcept
    : InsertRegisterArrayEntry() {
    *this = ::std::move(from);
  }

  inline InsertRegisterArrayEntry& operator=(const InsertRegisterArrayEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertRegisterArrayEntry& operator=(InsertRegisterArrayEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertRegisterArrayEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertRegisterArrayEntry* internal_default_instance() {
    return reinterpret_cast<const InsertRegisterArrayEntry*>(
               &_InsertRegisterArrayEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(InsertRegisterArrayEntry& a, InsertRegisterArrayEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertRegisterArrayEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertRegisterArrayEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsertRegisterArrayEntry* New() const final {
    return new InsertRegisterArrayEntry();
  }

  InsertRegisterArrayEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsertRegisterArrayEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertRegisterArrayEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InsertRegisterArrayEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertRegisterArrayEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.InsertRegisterArrayEntry";
  }
  protected:
  explicit InsertRegisterArrayEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegisterArrayNameFieldNumber = 1,
    kRegisterArraySizeFieldNumber = 2,
    kRegisterArrayBitwidthFieldNumber = 3,
  };
  // string register_array_name = 1;
  void clear_register_array_name();
  const std::string& register_array_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_register_array_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_register_array_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_register_array_name();
  void set_allocated_register_array_name(std::string* register_array_name);
  private:
  const std::string& _internal_register_array_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_register_array_name(const std::string& value);
  std::string* _internal_mutable_register_array_name();
  public:

  // uint32 register_array_size = 2;
  void clear_register_array_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 register_array_size() const;
  void set_register_array_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_register_array_size() const;
  void _internal_set_register_array_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 register_array_bitwidth = 3;
  void clear_register_array_bitwidth();
  ::PROTOBUF_NAMESPACE_ID::uint32 register_array_bitwidth() const;
  void set_register_array_bitwidth(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_register_array_bitwidth() const;
  void _internal_set_register_array_bitwidth(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.InsertRegisterArrayEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr register_array_name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 register_array_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 register_array_bitwidth_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class ChangeRegisterArrayEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.ChangeRegisterArrayEntry) */ {
 public:
  inline ChangeRegisterArrayEntry() : ChangeRegisterArrayEntry(nullptr) {}
  ~ChangeRegisterArrayEntry() override;
  explicit constexpr ChangeRegisterArrayEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeRegisterArrayEntry(const ChangeRegisterArrayEntry& from);
  ChangeRegisterArrayEntry(ChangeRegisterArrayEntry&& from) noexcept
    : ChangeRegisterArrayEntry() {
    *this = ::std::move(from);
  }

  inline ChangeRegisterArrayEntry& operator=(const ChangeRegisterArrayEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeRegisterArrayEntry& operator=(ChangeRegisterArrayEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeRegisterArrayEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeRegisterArrayEntry* internal_default_instance() {
    return reinterpret_cast<const ChangeRegisterArrayEntry*>(
               &_ChangeRegisterArrayEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ChangeRegisterArrayEntry& a, ChangeRegisterArrayEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeRegisterArrayEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeRegisterArrayEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChangeRegisterArrayEntry* New() const final {
    return new ChangeRegisterArrayEntry();
  }

  ChangeRegisterArrayEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChangeRegisterArrayEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeRegisterArrayEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeRegisterArrayEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeRegisterArrayEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.ChangeRegisterArrayEntry";
  }
  protected:
  explicit ChangeRegisterArrayEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ChangeRegisterArrayEntry_RegisterArrayChangeType RegisterArrayChangeType;
  static constexpr RegisterArrayChangeType CHANGE_SIZE =
    ChangeRegisterArrayEntry_RegisterArrayChangeType_CHANGE_SIZE;
  static constexpr RegisterArrayChangeType CHANGE_BITWIDTH =
    ChangeRegisterArrayEntry_RegisterArrayChangeType_CHANGE_BITWIDTH;
  static inline bool RegisterArrayChangeType_IsValid(int value) {
    return ChangeRegisterArrayEntry_RegisterArrayChangeType_IsValid(value);
  }
  static constexpr RegisterArrayChangeType RegisterArrayChangeType_MIN =
    ChangeRegisterArrayEntry_RegisterArrayChangeType_RegisterArrayChangeType_MIN;
  static constexpr RegisterArrayChangeType RegisterArrayChangeType_MAX =
    ChangeRegisterArrayEntry_RegisterArrayChangeType_RegisterArrayChangeType_MAX;
  static constexpr int RegisterArrayChangeType_ARRAYSIZE =
    ChangeRegisterArrayEntry_RegisterArrayChangeType_RegisterArrayChangeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RegisterArrayChangeType_descriptor() {
    return ChangeRegisterArrayEntry_RegisterArrayChangeType_descriptor();
  }
  template<typename T>
  static inline const std::string& RegisterArrayChangeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RegisterArrayChangeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RegisterArrayChangeType_Name.");
    return ChangeRegisterArrayEntry_RegisterArrayChangeType_Name(enum_t_value);
  }
  static inline bool RegisterArrayChangeType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RegisterArrayChangeType* value) {
    return ChangeRegisterArrayEntry_RegisterArrayChangeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRegisterArrayNameFieldNumber = 1,
    kRegisterArrayChangeTypeFieldNumber = 2,
    kNewValueFieldNumber = 3,
  };
  // string register_array_name = 1;
  void clear_register_array_name();
  const std::string& register_array_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_register_array_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_register_array_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_register_array_name();
  void set_allocated_register_array_name(std::string* register_array_name);
  private:
  const std::string& _internal_register_array_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_register_array_name(const std::string& value);
  std::string* _internal_mutable_register_array_name();
  public:

  // .p4.v1.ChangeRegisterArrayEntry.RegisterArrayChangeType register_array_change_type = 2;
  void clear_register_array_change_type();
  ::p4::v1::ChangeRegisterArrayEntry_RegisterArrayChangeType register_array_change_type() const;
  void set_register_array_change_type(::p4::v1::ChangeRegisterArrayEntry_RegisterArrayChangeType value);
  private:
  ::p4::v1::ChangeRegisterArrayEntry_RegisterArrayChangeType _internal_register_array_change_type() const;
  void _internal_set_register_array_change_type(::p4::v1::ChangeRegisterArrayEntry_RegisterArrayChangeType value);
  public:

  // uint32 new_value = 3;
  void clear_new_value();
  ::PROTOBUF_NAMESPACE_ID::uint32 new_value() const;
  void set_new_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_new_value() const;
  void _internal_set_new_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.ChangeRegisterArrayEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr register_array_name_;
  int register_array_change_type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 new_value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class DeleteRegisterArrayEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.DeleteRegisterArrayEntry) */ {
 public:
  inline DeleteRegisterArrayEntry() : DeleteRegisterArrayEntry(nullptr) {}
  ~DeleteRegisterArrayEntry() override;
  explicit constexpr DeleteRegisterArrayEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRegisterArrayEntry(const DeleteRegisterArrayEntry& from);
  DeleteRegisterArrayEntry(DeleteRegisterArrayEntry&& from) noexcept
    : DeleteRegisterArrayEntry() {
    *this = ::std::move(from);
  }

  inline DeleteRegisterArrayEntry& operator=(const DeleteRegisterArrayEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRegisterArrayEntry& operator=(DeleteRegisterArrayEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRegisterArrayEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRegisterArrayEntry* internal_default_instance() {
    return reinterpret_cast<const DeleteRegisterArrayEntry*>(
               &_DeleteRegisterArrayEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(DeleteRegisterArrayEntry& a, DeleteRegisterArrayEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRegisterArrayEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRegisterArrayEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteRegisterArrayEntry* New() const final {
    return new DeleteRegisterArrayEntry();
  }

  DeleteRegisterArrayEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRegisterArrayEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRegisterArrayEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteRegisterArrayEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRegisterArrayEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.DeleteRegisterArrayEntry";
  }
  protected:
  explicit DeleteRegisterArrayEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegisterArrayNameFieldNumber = 1,
  };
  // string register_array_name = 1;
  void clear_register_array_name();
  const std::string& register_array_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_register_array_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_register_array_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_register_array_name();
  void set_allocated_register_array_name(std::string* register_array_name);
  private:
  const std::string& _internal_register_array_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_register_array_name(const std::string& value);
  std::string* _internal_mutable_register_array_name();
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.DeleteRegisterArrayEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr register_array_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class TriggerEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.TriggerEntry) */ {
 public:
  inline TriggerEntry() : TriggerEntry(nullptr) {}
  ~TriggerEntry() override;
  explicit constexpr TriggerEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TriggerEntry(const TriggerEntry& from);
  TriggerEntry(TriggerEntry&& from) noexcept
    : TriggerEntry() {
    *this = ::std::move(from);
  }

  inline TriggerEntry& operator=(const TriggerEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline TriggerEntry& operator=(TriggerEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TriggerEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const TriggerEntry* internal_default_instance() {
    return reinterpret_cast<const TriggerEntry*>(
               &_TriggerEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(TriggerEntry& a, TriggerEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(TriggerEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TriggerEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TriggerEntry* New() const final {
    return new TriggerEntry();
  }

  TriggerEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TriggerEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TriggerEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TriggerEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TriggerEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.TriggerEntry";
  }
  protected:
  explicit TriggerEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOnOrOffFieldNumber = 1,
  };
  // bool on_or_off = 1;
  void clear_on_or_off();
  bool on_or_off() const;
  void set_on_or_off(bool value);
  private:
  bool _internal_on_or_off() const;
  void _internal_set_on_or_off(bool value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.TriggerEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool on_or_off_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class ChangeInitEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.ChangeInitEntry) */ {
 public:
  inline ChangeInitEntry() : ChangeInitEntry(nullptr) {}
  ~ChangeInitEntry() override;
  explicit constexpr ChangeInitEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeInitEntry(const ChangeInitEntry& from);
  ChangeInitEntry(ChangeInitEntry&& from) noexcept
    : ChangeInitEntry() {
    *this = ::std::move(from);
  }

  inline ChangeInitEntry& operator=(const ChangeInitEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeInitEntry& operator=(ChangeInitEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeInitEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeInitEntry* internal_default_instance() {
    return reinterpret_cast<const ChangeInitEntry*>(
               &_ChangeInitEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ChangeInitEntry& a, ChangeInitEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeInitEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeInitEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChangeInitEntry* New() const final {
    return new ChangeInitEntry();
  }

  ChangeInitEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChangeInitEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeInitEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeInitEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeInitEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.ChangeInitEntry";
  }
  protected:
  explicit ChangeInitEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPipelineNameFieldNumber = 1,
    kTableNameNextFieldNumber = 2,
  };
  // string pipeline_name = 1;
  void clear_pipeline_name();
  const std::string& pipeline_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pipeline_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pipeline_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_pipeline_name();
  void set_allocated_pipeline_name(std::string* pipeline_name);
  private:
  const std::string& _internal_pipeline_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pipeline_name(const std::string& value);
  std::string* _internal_mutable_pipeline_name();
  public:

  // string table_name_next = 2;
  void clear_table_name_next();
  const std::string& table_name_next() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name_next(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name_next();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name_next();
  void set_allocated_table_name_next(std::string* table_name_next);
  private:
  const std::string& _internal_table_name_next() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name_next(const std::string& value);
  std::string* _internal_mutable_table_name_next();
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.ChangeInitEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pipeline_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_next_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class ExternEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.ExternEntry) */ {
 public:
  inline ExternEntry() : ExternEntry(nullptr) {}
  ~ExternEntry() override;
  explicit constexpr ExternEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExternEntry(const ExternEntry& from);
  ExternEntry(ExternEntry&& from) noexcept
    : ExternEntry() {
    *this = ::std::move(from);
  }

  inline ExternEntry& operator=(const ExternEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExternEntry& operator=(ExternEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExternEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExternEntry* internal_default_instance() {
    return reinterpret_cast<const ExternEntry*>(
               &_ExternEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ExternEntry& a, ExternEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(ExternEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExternEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExternEntry* New() const final {
    return new ExternEntry();
  }

  ExternEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExternEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExternEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExternEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExternEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.ExternEntry";
  }
  protected:
  explicit ExternEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 3,
    kExternTypeIdFieldNumber = 1,
    kExternIdFieldNumber = 2,
  };
  // .google.protobuf.Any entry = 3;
  bool has_entry() const;
  private:
  bool _internal_has_entry() const;
  public:
  void clear_entry();
  const ::PROTOBUF_NAMESPACE_ID::Any& entry() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Any* release_entry();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_entry();
  void set_allocated_entry(::PROTOBUF_NAMESPACE_ID::Any* entry);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_entry() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_entry();
  public:
  void unsafe_arena_set_allocated_entry(
      ::PROTOBUF_NAMESPACE_ID::Any* entry);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_entry();

  // uint32 extern_type_id = 1;
  void clear_extern_type_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 extern_type_id() const;
  void set_extern_type_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_extern_type_id() const;
  void _internal_set_extern_type_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 extern_id = 2;
  void clear_extern_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 extern_id() const;
  void set_extern_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_extern_id() const;
  void _internal_set_extern_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.ExternEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Any* entry_;
  ::PROTOBUF_NAMESPACE_ID::uint32 extern_type_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 extern_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class TableEntry_IdleTimeout final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.TableEntry.IdleTimeout) */ {
 public:
  inline TableEntry_IdleTimeout() : TableEntry_IdleTimeout(nullptr) {}
  ~TableEntry_IdleTimeout() override;
  explicit constexpr TableEntry_IdleTimeout(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableEntry_IdleTimeout(const TableEntry_IdleTimeout& from);
  TableEntry_IdleTimeout(TableEntry_IdleTimeout&& from) noexcept
    : TableEntry_IdleTimeout() {
    *this = ::std::move(from);
  }

  inline TableEntry_IdleTimeout& operator=(const TableEntry_IdleTimeout& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableEntry_IdleTimeout& operator=(TableEntry_IdleTimeout&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableEntry_IdleTimeout& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableEntry_IdleTimeout* internal_default_instance() {
    return reinterpret_cast<const TableEntry_IdleTimeout*>(
               &_TableEntry_IdleTimeout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(TableEntry_IdleTimeout& a, TableEntry_IdleTimeout& b) {
    a.Swap(&b);
  }
  inline void Swap(TableEntry_IdleTimeout* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableEntry_IdleTimeout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TableEntry_IdleTimeout* New() const final {
    return new TableEntry_IdleTimeout();
  }

  TableEntry_IdleTimeout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TableEntry_IdleTimeout>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableEntry_IdleTimeout& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TableEntry_IdleTimeout& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableEntry_IdleTimeout* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.TableEntry.IdleTimeout";
  }
  protected:
  explicit TableEntry_IdleTimeout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElapsedNsFieldNumber = 1,
  };
  // int64 elapsed_ns = 1;
  void clear_elapsed_ns();
  ::PROTOBUF_NAMESPACE_ID::int64 elapsed_ns() const;
  void set_elapsed_ns(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_elapsed_ns() const;
  void _internal_set_elapsed_ns(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.TableEntry.IdleTimeout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 elapsed_ns_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class TableEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.TableEntry) */ {
 public:
  inline TableEntry() : TableEntry(nullptr) {}
  ~TableEntry() override;
  explicit constexpr TableEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableEntry(const TableEntry& from);
  TableEntry(TableEntry&& from) noexcept
    : TableEntry() {
    *this = ::std::move(from);
  }

  inline TableEntry& operator=(const TableEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableEntry& operator=(TableEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableEntry* internal_default_instance() {
    return reinterpret_cast<const TableEntry*>(
               &_TableEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(TableEntry& a, TableEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(TableEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TableEntry* New() const final {
    return new TableEntry();
  }

  TableEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TableEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TableEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.TableEntry";
  }
  protected:
  explicit TableEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TableEntry_IdleTimeout IdleTimeout;

  // accessors -------------------------------------------------------

  enum : int {
    kMatchFieldNumber = 2,
    kMetadataFieldNumber = 11,
    kActionFieldNumber = 3,
    kMeterConfigFieldNumber = 6,
    kCounterDataFieldNumber = 7,
    kTimeSinceLastHitFieldNumber = 10,
    kTableIdFieldNumber = 1,
    kPriorityFieldNumber = 4,
    kControllerMetadataFieldNumber = 5,
    kIdleTimeoutNsFieldNumber = 9,
    kIsDefaultActionFieldNumber = 8,
  };
  // repeated .p4.v1.FieldMatch match = 2;
  int match_size() const;
  private:
  int _internal_match_size() const;
  public:
  void clear_match();
  ::p4::v1::FieldMatch* mutable_match(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::FieldMatch >*
      mutable_match();
  private:
  const ::p4::v1::FieldMatch& _internal_match(int index) const;
  ::p4::v1::FieldMatch* _internal_add_match();
  public:
  const ::p4::v1::FieldMatch& match(int index) const;
  ::p4::v1::FieldMatch* add_match();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::FieldMatch >&
      match() const;

  // bytes metadata = 11;
  void clear_metadata();
  const std::string& metadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metadata();
  PROTOBUF_MUST_USE_RESULT std::string* release_metadata();
  void set_allocated_metadata(std::string* metadata);
  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(const std::string& value);
  std::string* _internal_mutable_metadata();
  public:

  // .p4.v1.TableAction action = 3;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const ::p4::v1::TableAction& action() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::TableAction* release_action();
  ::p4::v1::TableAction* mutable_action();
  void set_allocated_action(::p4::v1::TableAction* action);
  private:
  const ::p4::v1::TableAction& _internal_action() const;
  ::p4::v1::TableAction* _internal_mutable_action();
  public:
  void unsafe_arena_set_allocated_action(
      ::p4::v1::TableAction* action);
  ::p4::v1::TableAction* unsafe_arena_release_action();

  // .p4.v1.MeterConfig meter_config = 6;
  bool has_meter_config() const;
  private:
  bool _internal_has_meter_config() const;
  public:
  void clear_meter_config();
  const ::p4::v1::MeterConfig& meter_config() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::MeterConfig* release_meter_config();
  ::p4::v1::MeterConfig* mutable_meter_config();
  void set_allocated_meter_config(::p4::v1::MeterConfig* meter_config);
  private:
  const ::p4::v1::MeterConfig& _internal_meter_config() const;
  ::p4::v1::MeterConfig* _internal_mutable_meter_config();
  public:
  void unsafe_arena_set_allocated_meter_config(
      ::p4::v1::MeterConfig* meter_config);
  ::p4::v1::MeterConfig* unsafe_arena_release_meter_config();

  // .p4.v1.CounterData counter_data = 7;
  bool has_counter_data() const;
  private:
  bool _internal_has_counter_data() const;
  public:
  void clear_counter_data();
  const ::p4::v1::CounterData& counter_data() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::CounterData* release_counter_data();
  ::p4::v1::CounterData* mutable_counter_data();
  void set_allocated_counter_data(::p4::v1::CounterData* counter_data);
  private:
  const ::p4::v1::CounterData& _internal_counter_data() const;
  ::p4::v1::CounterData* _internal_mutable_counter_data();
  public:
  void unsafe_arena_set_allocated_counter_data(
      ::p4::v1::CounterData* counter_data);
  ::p4::v1::CounterData* unsafe_arena_release_counter_data();

  // .p4.v1.TableEntry.IdleTimeout time_since_last_hit = 10;
  bool has_time_since_last_hit() const;
  private:
  bool _internal_has_time_since_last_hit() const;
  public:
  void clear_time_since_last_hit();
  const ::p4::v1::TableEntry_IdleTimeout& time_since_last_hit() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::TableEntry_IdleTimeout* release_time_since_last_hit();
  ::p4::v1::TableEntry_IdleTimeout* mutable_time_since_last_hit();
  void set_allocated_time_since_last_hit(::p4::v1::TableEntry_IdleTimeout* time_since_last_hit);
  private:
  const ::p4::v1::TableEntry_IdleTimeout& _internal_time_since_last_hit() const;
  ::p4::v1::TableEntry_IdleTimeout* _internal_mutable_time_since_last_hit();
  public:
  void unsafe_arena_set_allocated_time_since_last_hit(
      ::p4::v1::TableEntry_IdleTimeout* time_since_last_hit);
  ::p4::v1::TableEntry_IdleTimeout* unsafe_arena_release_time_since_last_hit();

  // uint32 table_id = 1;
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // int32 priority = 4;
  void clear_priority();
  ::PROTOBUF_NAMESPACE_ID::int32 priority() const;
  void set_priority(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_priority() const;
  void _internal_set_priority(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // uint64 controller_metadata = 5 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_controller_metadata();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::uint64 controller_metadata() const;
  PROTOBUF_DEPRECATED void set_controller_metadata(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_controller_metadata() const;
  void _internal_set_controller_metadata(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // int64 idle_timeout_ns = 9;
  void clear_idle_timeout_ns();
  ::PROTOBUF_NAMESPACE_ID::int64 idle_timeout_ns() const;
  void set_idle_timeout_ns(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_idle_timeout_ns() const;
  void _internal_set_idle_timeout_ns(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool is_default_action = 8;
  void clear_is_default_action();
  bool is_default_action() const;
  void set_is_default_action(bool value);
  private:
  bool _internal_is_default_action() const;
  void _internal_set_is_default_action(bool value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.TableEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::FieldMatch > match_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_;
  ::p4::v1::TableAction* action_;
  ::p4::v1::MeterConfig* meter_config_;
  ::p4::v1::CounterData* counter_data_;
  ::p4::v1::TableEntry_IdleTimeout* time_since_last_hit_;
  ::PROTOBUF_NAMESPACE_ID::uint32 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 priority_;
  ::PROTOBUF_NAMESPACE_ID::uint64 controller_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 idle_timeout_ns_;
  bool is_default_action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class FieldMatch_Exact final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.FieldMatch.Exact) */ {
 public:
  inline FieldMatch_Exact() : FieldMatch_Exact(nullptr) {}
  ~FieldMatch_Exact() override;
  explicit constexpr FieldMatch_Exact(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FieldMatch_Exact(const FieldMatch_Exact& from);
  FieldMatch_Exact(FieldMatch_Exact&& from) noexcept
    : FieldMatch_Exact() {
    *this = ::std::move(from);
  }

  inline FieldMatch_Exact& operator=(const FieldMatch_Exact& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldMatch_Exact& operator=(FieldMatch_Exact&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldMatch_Exact& default_instance() {
    return *internal_default_instance();
  }
  static inline const FieldMatch_Exact* internal_default_instance() {
    return reinterpret_cast<const FieldMatch_Exact*>(
               &_FieldMatch_Exact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(FieldMatch_Exact& a, FieldMatch_Exact& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldMatch_Exact* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldMatch_Exact* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FieldMatch_Exact* New() const final {
    return new FieldMatch_Exact();
  }

  FieldMatch_Exact* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FieldMatch_Exact>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FieldMatch_Exact& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FieldMatch_Exact& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldMatch_Exact* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.FieldMatch.Exact";
  }
  protected:
  explicit FieldMatch_Exact(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.FieldMatch.Exact)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class FieldMatch_Ternary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.FieldMatch.Ternary) */ {
 public:
  inline FieldMatch_Ternary() : FieldMatch_Ternary(nullptr) {}
  ~FieldMatch_Ternary() override;
  explicit constexpr FieldMatch_Ternary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FieldMatch_Ternary(const FieldMatch_Ternary& from);
  FieldMatch_Ternary(FieldMatch_Ternary&& from) noexcept
    : FieldMatch_Ternary() {
    *this = ::std::move(from);
  }

  inline FieldMatch_Ternary& operator=(const FieldMatch_Ternary& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldMatch_Ternary& operator=(FieldMatch_Ternary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldMatch_Ternary& default_instance() {
    return *internal_default_instance();
  }
  static inline const FieldMatch_Ternary* internal_default_instance() {
    return reinterpret_cast<const FieldMatch_Ternary*>(
               &_FieldMatch_Ternary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(FieldMatch_Ternary& a, FieldMatch_Ternary& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldMatch_Ternary* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldMatch_Ternary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FieldMatch_Ternary* New() const final {
    return new FieldMatch_Ternary();
  }

  FieldMatch_Ternary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FieldMatch_Ternary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FieldMatch_Ternary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FieldMatch_Ternary& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldMatch_Ternary* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.FieldMatch.Ternary";
  }
  protected:
  explicit FieldMatch_Ternary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kMaskFieldNumber = 2,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // bytes mask = 2;
  void clear_mask();
  const std::string& mask() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mask(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mask();
  PROTOBUF_MUST_USE_RESULT std::string* release_mask();
  void set_allocated_mask(std::string* mask);
  private:
  const std::string& _internal_mask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mask(const std::string& value);
  std::string* _internal_mutable_mask();
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.FieldMatch.Ternary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mask_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class FieldMatch_LPM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.FieldMatch.LPM) */ {
 public:
  inline FieldMatch_LPM() : FieldMatch_LPM(nullptr) {}
  ~FieldMatch_LPM() override;
  explicit constexpr FieldMatch_LPM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FieldMatch_LPM(const FieldMatch_LPM& from);
  FieldMatch_LPM(FieldMatch_LPM&& from) noexcept
    : FieldMatch_LPM() {
    *this = ::std::move(from);
  }

  inline FieldMatch_LPM& operator=(const FieldMatch_LPM& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldMatch_LPM& operator=(FieldMatch_LPM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldMatch_LPM& default_instance() {
    return *internal_default_instance();
  }
  static inline const FieldMatch_LPM* internal_default_instance() {
    return reinterpret_cast<const FieldMatch_LPM*>(
               &_FieldMatch_LPM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(FieldMatch_LPM& a, FieldMatch_LPM& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldMatch_LPM* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldMatch_LPM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FieldMatch_LPM* New() const final {
    return new FieldMatch_LPM();
  }

  FieldMatch_LPM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FieldMatch_LPM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FieldMatch_LPM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FieldMatch_LPM& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldMatch_LPM* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.FieldMatch.LPM";
  }
  protected:
  explicit FieldMatch_LPM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kPrefixLenFieldNumber = 2,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // int32 prefix_len = 2;
  void clear_prefix_len();
  ::PROTOBUF_NAMESPACE_ID::int32 prefix_len() const;
  void set_prefix_len(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_prefix_len() const;
  void _internal_set_prefix_len(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.FieldMatch.LPM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::int32 prefix_len_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class FieldMatch_Range final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.FieldMatch.Range) */ {
 public:
  inline FieldMatch_Range() : FieldMatch_Range(nullptr) {}
  ~FieldMatch_Range() override;
  explicit constexpr FieldMatch_Range(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FieldMatch_Range(const FieldMatch_Range& from);
  FieldMatch_Range(FieldMatch_Range&& from) noexcept
    : FieldMatch_Range() {
    *this = ::std::move(from);
  }

  inline FieldMatch_Range& operator=(const FieldMatch_Range& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldMatch_Range& operator=(FieldMatch_Range&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldMatch_Range& default_instance() {
    return *internal_default_instance();
  }
  static inline const FieldMatch_Range* internal_default_instance() {
    return reinterpret_cast<const FieldMatch_Range*>(
               &_FieldMatch_Range_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(FieldMatch_Range& a, FieldMatch_Range& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldMatch_Range* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldMatch_Range* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FieldMatch_Range* New() const final {
    return new FieldMatch_Range();
  }

  FieldMatch_Range* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FieldMatch_Range>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FieldMatch_Range& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FieldMatch_Range& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldMatch_Range* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.FieldMatch.Range";
  }
  protected:
  explicit FieldMatch_Range(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLowFieldNumber = 1,
    kHighFieldNumber = 2,
  };
  // bytes low = 1;
  void clear_low();
  const std::string& low() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_low(ArgT0&& arg0, ArgT... args);
  std::string* mutable_low();
  PROTOBUF_MUST_USE_RESULT std::string* release_low();
  void set_allocated_low(std::string* low);
  private:
  const std::string& _internal_low() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_low(const std::string& value);
  std::string* _internal_mutable_low();
  public:

  // bytes high = 2;
  void clear_high();
  const std::string& high() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_high(ArgT0&& arg0, ArgT... args);
  std::string* mutable_high();
  PROTOBUF_MUST_USE_RESULT std::string* release_high();
  void set_allocated_high(std::string* high);
  private:
  const std::string& _internal_high() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_high(const std::string& value);
  std::string* _internal_mutable_high();
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.FieldMatch.Range)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr low_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr high_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class FieldMatch_Optional final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.FieldMatch.Optional) */ {
 public:
  inline FieldMatch_Optional() : FieldMatch_Optional(nullptr) {}
  ~FieldMatch_Optional() override;
  explicit constexpr FieldMatch_Optional(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FieldMatch_Optional(const FieldMatch_Optional& from);
  FieldMatch_Optional(FieldMatch_Optional&& from) noexcept
    : FieldMatch_Optional() {
    *this = ::std::move(from);
  }

  inline FieldMatch_Optional& operator=(const FieldMatch_Optional& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldMatch_Optional& operator=(FieldMatch_Optional&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldMatch_Optional& default_instance() {
    return *internal_default_instance();
  }
  static inline const FieldMatch_Optional* internal_default_instance() {
    return reinterpret_cast<const FieldMatch_Optional*>(
               &_FieldMatch_Optional_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(FieldMatch_Optional& a, FieldMatch_Optional& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldMatch_Optional* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldMatch_Optional* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FieldMatch_Optional* New() const final {
    return new FieldMatch_Optional();
  }

  FieldMatch_Optional* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FieldMatch_Optional>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FieldMatch_Optional& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FieldMatch_Optional& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldMatch_Optional* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.FieldMatch.Optional";
  }
  protected:
  explicit FieldMatch_Optional(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.FieldMatch.Optional)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class FieldMatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.FieldMatch) */ {
 public:
  inline FieldMatch() : FieldMatch(nullptr) {}
  ~FieldMatch() override;
  explicit constexpr FieldMatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FieldMatch(const FieldMatch& from);
  FieldMatch(FieldMatch&& from) noexcept
    : FieldMatch() {
    *this = ::std::move(from);
  }

  inline FieldMatch& operator=(const FieldMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldMatch& operator=(FieldMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldMatch& default_instance() {
    return *internal_default_instance();
  }
  enum FieldMatchTypeCase {
    kExact = 2,
    kTernary = 3,
    kLpm = 4,
    kRange = 6,
    kOptional = 7,
    kOther = 100,
    FIELD_MATCH_TYPE_NOT_SET = 0,
  };

  static inline const FieldMatch* internal_default_instance() {
    return reinterpret_cast<const FieldMatch*>(
               &_FieldMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(FieldMatch& a, FieldMatch& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldMatch* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FieldMatch* New() const final {
    return new FieldMatch();
  }

  FieldMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FieldMatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FieldMatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FieldMatch& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldMatch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.FieldMatch";
  }
  protected:
  explicit FieldMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FieldMatch_Exact Exact;
  typedef FieldMatch_Ternary Ternary;
  typedef FieldMatch_LPM LPM;
  typedef FieldMatch_Range Range;
  typedef FieldMatch_Optional Optional;

  // accessors -------------------------------------------------------

  enum : int {
    kFieldIdFieldNumber = 1,
    kExactFieldNumber = 2,
    kTernaryFieldNumber = 3,
    kLpmFieldNumber = 4,
    kRangeFieldNumber = 6,
    kOptionalFieldNumber = 7,
    kOtherFieldNumber = 100,
  };
  // uint32 field_id = 1;
  void clear_field_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 field_id() const;
  void set_field_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_field_id() const;
  void _internal_set_field_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .p4.v1.FieldMatch.Exact exact = 2;
  bool has_exact() const;
  private:
  bool _internal_has_exact() const;
  public:
  void clear_exact();
  const ::p4::v1::FieldMatch_Exact& exact() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::FieldMatch_Exact* release_exact();
  ::p4::v1::FieldMatch_Exact* mutable_exact();
  void set_allocated_exact(::p4::v1::FieldMatch_Exact* exact);
  private:
  const ::p4::v1::FieldMatch_Exact& _internal_exact() const;
  ::p4::v1::FieldMatch_Exact* _internal_mutable_exact();
  public:
  void unsafe_arena_set_allocated_exact(
      ::p4::v1::FieldMatch_Exact* exact);
  ::p4::v1::FieldMatch_Exact* unsafe_arena_release_exact();

  // .p4.v1.FieldMatch.Ternary ternary = 3;
  bool has_ternary() const;
  private:
  bool _internal_has_ternary() const;
  public:
  void clear_ternary();
  const ::p4::v1::FieldMatch_Ternary& ternary() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::FieldMatch_Ternary* release_ternary();
  ::p4::v1::FieldMatch_Ternary* mutable_ternary();
  void set_allocated_ternary(::p4::v1::FieldMatch_Ternary* ternary);
  private:
  const ::p4::v1::FieldMatch_Ternary& _internal_ternary() const;
  ::p4::v1::FieldMatch_Ternary* _internal_mutable_ternary();
  public:
  void unsafe_arena_set_allocated_ternary(
      ::p4::v1::FieldMatch_Ternary* ternary);
  ::p4::v1::FieldMatch_Ternary* unsafe_arena_release_ternary();

  // .p4.v1.FieldMatch.LPM lpm = 4;
  bool has_lpm() const;
  private:
  bool _internal_has_lpm() const;
  public:
  void clear_lpm();
  const ::p4::v1::FieldMatch_LPM& lpm() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::FieldMatch_LPM* release_lpm();
  ::p4::v1::FieldMatch_LPM* mutable_lpm();
  void set_allocated_lpm(::p4::v1::FieldMatch_LPM* lpm);
  private:
  const ::p4::v1::FieldMatch_LPM& _internal_lpm() const;
  ::p4::v1::FieldMatch_LPM* _internal_mutable_lpm();
  public:
  void unsafe_arena_set_allocated_lpm(
      ::p4::v1::FieldMatch_LPM* lpm);
  ::p4::v1::FieldMatch_LPM* unsafe_arena_release_lpm();

  // .p4.v1.FieldMatch.Range range = 6;
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  const ::p4::v1::FieldMatch_Range& range() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::FieldMatch_Range* release_range();
  ::p4::v1::FieldMatch_Range* mutable_range();
  void set_allocated_range(::p4::v1::FieldMatch_Range* range);
  private:
  const ::p4::v1::FieldMatch_Range& _internal_range() const;
  ::p4::v1::FieldMatch_Range* _internal_mutable_range();
  public:
  void unsafe_arena_set_allocated_range(
      ::p4::v1::FieldMatch_Range* range);
  ::p4::v1::FieldMatch_Range* unsafe_arena_release_range();

  // .p4.v1.FieldMatch.Optional optional = 7;
  bool has_optional() const;
  private:
  bool _internal_has_optional() const;
  public:
  void clear_optional();
  const ::p4::v1::FieldMatch_Optional& optional() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::FieldMatch_Optional* release_optional();
  ::p4::v1::FieldMatch_Optional* mutable_optional();
  void set_allocated_optional(::p4::v1::FieldMatch_Optional* optional);
  private:
  const ::p4::v1::FieldMatch_Optional& _internal_optional() const;
  ::p4::v1::FieldMatch_Optional* _internal_mutable_optional();
  public:
  void unsafe_arena_set_allocated_optional(
      ::p4::v1::FieldMatch_Optional* optional);
  ::p4::v1::FieldMatch_Optional* unsafe_arena_release_optional();

  // .google.protobuf.Any other = 100;
  bool has_other() const;
  private:
  bool _internal_has_other() const;
  public:
  void clear_other();
  const ::PROTOBUF_NAMESPACE_ID::Any& other() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Any* release_other();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_other();
  void set_allocated_other(::PROTOBUF_NAMESPACE_ID::Any* other);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_other() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_other();
  public:
  void unsafe_arena_set_allocated_other(
      ::PROTOBUF_NAMESPACE_ID::Any* other);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_other();

  void clear_field_match_type();
  FieldMatchTypeCase field_match_type_case() const;
  // @@protoc_insertion_point(class_scope:p4.v1.FieldMatch)
 private:
  class _Internal;
  void set_has_exact();
  void set_has_ternary();
  void set_has_lpm();
  void set_has_range();
  void set_has_optional();
  void set_has_other();

  inline bool has_field_match_type() const;
  inline void clear_has_field_match_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 field_id_;
  union FieldMatchTypeUnion {
    constexpr FieldMatchTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::p4::v1::FieldMatch_Exact* exact_;
    ::p4::v1::FieldMatch_Ternary* ternary_;
    ::p4::v1::FieldMatch_LPM* lpm_;
    ::p4::v1::FieldMatch_Range* range_;
    ::p4::v1::FieldMatch_Optional* optional_;
    ::PROTOBUF_NAMESPACE_ID::Any* other_;
  } field_match_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class TableAction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.TableAction) */ {
 public:
  inline TableAction() : TableAction(nullptr) {}
  ~TableAction() override;
  explicit constexpr TableAction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableAction(const TableAction& from);
  TableAction(TableAction&& from) noexcept
    : TableAction() {
    *this = ::std::move(from);
  }

  inline TableAction& operator=(const TableAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableAction& operator=(TableAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableAction& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kAction = 1,
    kActionProfileMemberId = 2,
    kActionProfileGroupId = 3,
    kActionProfileActionSet = 4,
    TYPE_NOT_SET = 0,
  };

  static inline const TableAction* internal_default_instance() {
    return reinterpret_cast<const TableAction*>(
               &_TableAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(TableAction& a, TableAction& b) {
    a.Swap(&b);
  }
  inline void Swap(TableAction* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableAction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TableAction* New() const final {
    return new TableAction();
  }

  TableAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TableAction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableAction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TableAction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableAction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.TableAction";
  }
  protected:
  explicit TableAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
    kActionProfileMemberIdFieldNumber = 2,
    kActionProfileGroupIdFieldNumber = 3,
    kActionProfileActionSetFieldNumber = 4,
  };
  // .p4.v1.Action action = 1;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const ::p4::v1::Action& action() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::Action* release_action();
  ::p4::v1::Action* mutable_action();
  void set_allocated_action(::p4::v1::Action* action);
  private:
  const ::p4::v1::Action& _internal_action() const;
  ::p4::v1::Action* _internal_mutable_action();
  public:
  void unsafe_arena_set_allocated_action(
      ::p4::v1::Action* action);
  ::p4::v1::Action* unsafe_arena_release_action();

  // uint32 action_profile_member_id = 2;
  bool has_action_profile_member_id() const;
  private:
  bool _internal_has_action_profile_member_id() const;
  public:
  void clear_action_profile_member_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 action_profile_member_id() const;
  void set_action_profile_member_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_action_profile_member_id() const;
  void _internal_set_action_profile_member_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 action_profile_group_id = 3;
  bool has_action_profile_group_id() const;
  private:
  bool _internal_has_action_profile_group_id() const;
  public:
  void clear_action_profile_group_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 action_profile_group_id() const;
  void set_action_profile_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_action_profile_group_id() const;
  void _internal_set_action_profile_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .p4.v1.ActionProfileActionSet action_profile_action_set = 4;
  bool has_action_profile_action_set() const;
  private:
  bool _internal_has_action_profile_action_set() const;
  public:
  void clear_action_profile_action_set();
  const ::p4::v1::ActionProfileActionSet& action_profile_action_set() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::ActionProfileActionSet* release_action_profile_action_set();
  ::p4::v1::ActionProfileActionSet* mutable_action_profile_action_set();
  void set_allocated_action_profile_action_set(::p4::v1::ActionProfileActionSet* action_profile_action_set);
  private:
  const ::p4::v1::ActionProfileActionSet& _internal_action_profile_action_set() const;
  ::p4::v1::ActionProfileActionSet* _internal_mutable_action_profile_action_set();
  public:
  void unsafe_arena_set_allocated_action_profile_action_set(
      ::p4::v1::ActionProfileActionSet* action_profile_action_set);
  ::p4::v1::ActionProfileActionSet* unsafe_arena_release_action_profile_action_set();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:p4.v1.TableAction)
 private:
  class _Internal;
  void set_has_action();
  void set_has_action_profile_member_id();
  void set_has_action_profile_group_id();
  void set_has_action_profile_action_set();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::p4::v1::Action* action_;
    ::PROTOBUF_NAMESPACE_ID::uint32 action_profile_member_id_;
    ::PROTOBUF_NAMESPACE_ID::uint32 action_profile_group_id_;
    ::p4::v1::ActionProfileActionSet* action_profile_action_set_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class Action_Param final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.Action.Param) */ {
 public:
  inline Action_Param() : Action_Param(nullptr) {}
  ~Action_Param() override;
  explicit constexpr Action_Param(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Action_Param(const Action_Param& from);
  Action_Param(Action_Param&& from) noexcept
    : Action_Param() {
    *this = ::std::move(from);
  }

  inline Action_Param& operator=(const Action_Param& from) {
    CopyFrom(from);
    return *this;
  }
  inline Action_Param& operator=(Action_Param&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Action_Param& default_instance() {
    return *internal_default_instance();
  }
  static inline const Action_Param* internal_default_instance() {
    return reinterpret_cast<const Action_Param*>(
               &_Action_Param_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(Action_Param& a, Action_Param& b) {
    a.Swap(&b);
  }
  inline void Swap(Action_Param* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Action_Param* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Action_Param* New() const final {
    return new Action_Param();
  }

  Action_Param* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Action_Param>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Action_Param& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Action_Param& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Action_Param* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.Action.Param";
  }
  protected:
  explicit Action_Param(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 3,
    kParamIdFieldNumber = 2,
  };
  // bytes value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // uint32 param_id = 2;
  void clear_param_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 param_id() const;
  void set_param_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_param_id() const;
  void _internal_set_param_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.Action.Param)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::uint32 param_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class Action final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.Action) */ {
 public:
  inline Action() : Action(nullptr) {}
  ~Action() override;
  explicit constexpr Action(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Action(const Action& from);
  Action(Action&& from) noexcept
    : Action() {
    *this = ::std::move(from);
  }

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  inline Action& operator=(Action&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Action& default_instance() {
    return *internal_default_instance();
  }
  static inline const Action* internal_default_instance() {
    return reinterpret_cast<const Action*>(
               &_Action_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(Action& a, Action& b) {
    a.Swap(&b);
  }
  inline void Swap(Action* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Action* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Action* New() const final {
    return new Action();
  }

  Action* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Action>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Action& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Action& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Action* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.Action";
  }
  protected:
  explicit Action(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Action_Param Param;

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 4,
    kActionIdFieldNumber = 1,
  };
  // repeated .p4.v1.Action.Param params = 4;
  int params_size() const;
  private:
  int _internal_params_size() const;
  public:
  void clear_params();
  ::p4::v1::Action_Param* mutable_params(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Action_Param >*
      mutable_params();
  private:
  const ::p4::v1::Action_Param& _internal_params(int index) const;
  ::p4::v1::Action_Param* _internal_add_params();
  public:
  const ::p4::v1::Action_Param& params(int index) const;
  ::p4::v1::Action_Param* add_params();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Action_Param >&
      params() const;

  // uint32 action_id = 1;
  void clear_action_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 action_id() const;
  void set_action_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_action_id() const;
  void _internal_set_action_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.Action)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Action_Param > params_;
  ::PROTOBUF_NAMESPACE_ID::uint32 action_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class ActionProfileActionSet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.ActionProfileActionSet) */ {
 public:
  inline ActionProfileActionSet() : ActionProfileActionSet(nullptr) {}
  ~ActionProfileActionSet() override;
  explicit constexpr ActionProfileActionSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionProfileActionSet(const ActionProfileActionSet& from);
  ActionProfileActionSet(ActionProfileActionSet&& from) noexcept
    : ActionProfileActionSet() {
    *this = ::std::move(from);
  }

  inline ActionProfileActionSet& operator=(const ActionProfileActionSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionProfileActionSet& operator=(ActionProfileActionSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionProfileActionSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionProfileActionSet* internal_default_instance() {
    return reinterpret_cast<const ActionProfileActionSet*>(
               &_ActionProfileActionSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ActionProfileActionSet& a, ActionProfileActionSet& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionProfileActionSet* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionProfileActionSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionProfileActionSet* New() const final {
    return new ActionProfileActionSet();
  }

  ActionProfileActionSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionProfileActionSet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionProfileActionSet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ActionProfileActionSet& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionProfileActionSet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.ActionProfileActionSet";
  }
  protected:
  explicit ActionProfileActionSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionProfileActionsFieldNumber = 1,
  };
  // repeated .p4.v1.ActionProfileAction action_profile_actions = 1;
  int action_profile_actions_size() const;
  private:
  int _internal_action_profile_actions_size() const;
  public:
  void clear_action_profile_actions();
  ::p4::v1::ActionProfileAction* mutable_action_profile_actions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::ActionProfileAction >*
      mutable_action_profile_actions();
  private:
  const ::p4::v1::ActionProfileAction& _internal_action_profile_actions(int index) const;
  ::p4::v1::ActionProfileAction* _internal_add_action_profile_actions();
  public:
  const ::p4::v1::ActionProfileAction& action_profile_actions(int index) const;
  ::p4::v1::ActionProfileAction* add_action_profile_actions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::ActionProfileAction >&
      action_profile_actions() const;

  // @@protoc_insertion_point(class_scope:p4.v1.ActionProfileActionSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::ActionProfileAction > action_profile_actions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class ActionProfileAction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.ActionProfileAction) */ {
 public:
  inline ActionProfileAction() : ActionProfileAction(nullptr) {}
  ~ActionProfileAction() override;
  explicit constexpr ActionProfileAction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionProfileAction(const ActionProfileAction& from);
  ActionProfileAction(ActionProfileAction&& from) noexcept
    : ActionProfileAction() {
    *this = ::std::move(from);
  }

  inline ActionProfileAction& operator=(const ActionProfileAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionProfileAction& operator=(ActionProfileAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionProfileAction& default_instance() {
    return *internal_default_instance();
  }
  enum WatchKindCase {
    kWatch = 3,
    kWatchPort = 4,
    WATCH_KIND_NOT_SET = 0,
  };

  static inline const ActionProfileAction* internal_default_instance() {
    return reinterpret_cast<const ActionProfileAction*>(
               &_ActionProfileAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ActionProfileAction& a, ActionProfileAction& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionProfileAction* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionProfileAction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionProfileAction* New() const final {
    return new ActionProfileAction();
  }

  ActionProfileAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionProfileAction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionProfileAction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ActionProfileAction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionProfileAction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.ActionProfileAction";
  }
  protected:
  explicit ActionProfileAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
    kWeightFieldNumber = 2,
    kWatchFieldNumber = 3,
    kWatchPortFieldNumber = 4,
  };
  // .p4.v1.Action action = 1;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const ::p4::v1::Action& action() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::Action* release_action();
  ::p4::v1::Action* mutable_action();
  void set_allocated_action(::p4::v1::Action* action);
  private:
  const ::p4::v1::Action& _internal_action() const;
  ::p4::v1::Action* _internal_mutable_action();
  public:
  void unsafe_arena_set_allocated_action(
      ::p4::v1::Action* action);
  ::p4::v1::Action* unsafe_arena_release_action();

  // int32 weight = 2;
  void clear_weight();
  ::PROTOBUF_NAMESPACE_ID::int32 weight() const;
  void set_weight(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_weight() const;
  void _internal_set_weight(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 watch = 3 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_watch() const;
  private:
  bool _internal_has_watch() const;
  public:
  PROTOBUF_DEPRECATED void clear_watch();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::int32 watch() const;
  PROTOBUF_DEPRECATED void set_watch(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_watch() const;
  void _internal_set_watch(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bytes watch_port = 4;
  bool has_watch_port() const;
  private:
  bool _internal_has_watch_port() const;
  public:
  void clear_watch_port();
  const std::string& watch_port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_watch_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_watch_port();
  PROTOBUF_MUST_USE_RESULT std::string* release_watch_port();
  void set_allocated_watch_port(std::string* watch_port);
  private:
  const std::string& _internal_watch_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_watch_port(const std::string& value);
  std::string* _internal_mutable_watch_port();
  public:

  void clear_watch_kind();
  WatchKindCase watch_kind_case() const;
  // @@protoc_insertion_point(class_scope:p4.v1.ActionProfileAction)
 private:
  class _Internal;
  void set_has_watch();
  void set_has_watch_port();

  inline bool has_watch_kind() const;
  inline void clear_has_watch_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::p4::v1::Action* action_;
  ::PROTOBUF_NAMESPACE_ID::int32 weight_;
  union WatchKindUnion {
    constexpr WatchKindUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::int32 watch_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr watch_port_;
  } watch_kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class ActionProfileMember final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.ActionProfileMember) */ {
 public:
  inline ActionProfileMember() : ActionProfileMember(nullptr) {}
  ~ActionProfileMember() override;
  explicit constexpr ActionProfileMember(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionProfileMember(const ActionProfileMember& from);
  ActionProfileMember(ActionProfileMember&& from) noexcept
    : ActionProfileMember() {
    *this = ::std::move(from);
  }

  inline ActionProfileMember& operator=(const ActionProfileMember& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionProfileMember& operator=(ActionProfileMember&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionProfileMember& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionProfileMember* internal_default_instance() {
    return reinterpret_cast<const ActionProfileMember*>(
               &_ActionProfileMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ActionProfileMember& a, ActionProfileMember& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionProfileMember* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionProfileMember* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionProfileMember* New() const final {
    return new ActionProfileMember();
  }

  ActionProfileMember* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionProfileMember>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionProfileMember& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ActionProfileMember& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionProfileMember* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.ActionProfileMember";
  }
  protected:
  explicit ActionProfileMember(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 3,
    kActionProfileIdFieldNumber = 1,
    kMemberIdFieldNumber = 2,
  };
  // .p4.v1.Action action = 3;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const ::p4::v1::Action& action() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::Action* release_action();
  ::p4::v1::Action* mutable_action();
  void set_allocated_action(::p4::v1::Action* action);
  private:
  const ::p4::v1::Action& _internal_action() const;
  ::p4::v1::Action* _internal_mutable_action();
  public:
  void unsafe_arena_set_allocated_action(
      ::p4::v1::Action* action);
  ::p4::v1::Action* unsafe_arena_release_action();

  // uint32 action_profile_id = 1;
  void clear_action_profile_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 action_profile_id() const;
  void set_action_profile_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_action_profile_id() const;
  void _internal_set_action_profile_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 member_id = 2;
  void clear_member_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 member_id() const;
  void set_member_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_member_id() const;
  void _internal_set_member_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.ActionProfileMember)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::p4::v1::Action* action_;
  ::PROTOBUF_NAMESPACE_ID::uint32 action_profile_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 member_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class ActionProfileGroup_Member final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.ActionProfileGroup.Member) */ {
 public:
  inline ActionProfileGroup_Member() : ActionProfileGroup_Member(nullptr) {}
  ~ActionProfileGroup_Member() override;
  explicit constexpr ActionProfileGroup_Member(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionProfileGroup_Member(const ActionProfileGroup_Member& from);
  ActionProfileGroup_Member(ActionProfileGroup_Member&& from) noexcept
    : ActionProfileGroup_Member() {
    *this = ::std::move(from);
  }

  inline ActionProfileGroup_Member& operator=(const ActionProfileGroup_Member& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionProfileGroup_Member& operator=(ActionProfileGroup_Member&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionProfileGroup_Member& default_instance() {
    return *internal_default_instance();
  }
  enum WatchKindCase {
    kWatch = 3,
    kWatchPort = 4,
    WATCH_KIND_NOT_SET = 0,
  };

  static inline const ActionProfileGroup_Member* internal_default_instance() {
    return reinterpret_cast<const ActionProfileGroup_Member*>(
               &_ActionProfileGroup_Member_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(ActionProfileGroup_Member& a, ActionProfileGroup_Member& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionProfileGroup_Member* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionProfileGroup_Member* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionProfileGroup_Member* New() const final {
    return new ActionProfileGroup_Member();
  }

  ActionProfileGroup_Member* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionProfileGroup_Member>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionProfileGroup_Member& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ActionProfileGroup_Member& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionProfileGroup_Member* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.ActionProfileGroup.Member";
  }
  protected:
  explicit ActionProfileGroup_Member(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemberIdFieldNumber = 1,
    kWeightFieldNumber = 2,
    kWatchFieldNumber = 3,
    kWatchPortFieldNumber = 4,
  };
  // uint32 member_id = 1;
  void clear_member_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 member_id() const;
  void set_member_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_member_id() const;
  void _internal_set_member_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // int32 weight = 2;
  void clear_weight();
  ::PROTOBUF_NAMESPACE_ID::int32 weight() const;
  void set_weight(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_weight() const;
  void _internal_set_weight(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 watch = 3 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_watch() const;
  private:
  bool _internal_has_watch() const;
  public:
  PROTOBUF_DEPRECATED void clear_watch();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::int32 watch() const;
  PROTOBUF_DEPRECATED void set_watch(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_watch() const;
  void _internal_set_watch(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bytes watch_port = 4;
  bool has_watch_port() const;
  private:
  bool _internal_has_watch_port() const;
  public:
  void clear_watch_port();
  const std::string& watch_port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_watch_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_watch_port();
  PROTOBUF_MUST_USE_RESULT std::string* release_watch_port();
  void set_allocated_watch_port(std::string* watch_port);
  private:
  const std::string& _internal_watch_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_watch_port(const std::string& value);
  std::string* _internal_mutable_watch_port();
  public:

  void clear_watch_kind();
  WatchKindCase watch_kind_case() const;
  // @@protoc_insertion_point(class_scope:p4.v1.ActionProfileGroup.Member)
 private:
  class _Internal;
  void set_has_watch();
  void set_has_watch_port();

  inline bool has_watch_kind() const;
  inline void clear_has_watch_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 member_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 weight_;
  union WatchKindUnion {
    constexpr WatchKindUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::int32 watch_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr watch_port_;
  } watch_kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class ActionProfileGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.ActionProfileGroup) */ {
 public:
  inline ActionProfileGroup() : ActionProfileGroup(nullptr) {}
  ~ActionProfileGroup() override;
  explicit constexpr ActionProfileGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionProfileGroup(const ActionProfileGroup& from);
  ActionProfileGroup(ActionProfileGroup&& from) noexcept
    : ActionProfileGroup() {
    *this = ::std::move(from);
  }

  inline ActionProfileGroup& operator=(const ActionProfileGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionProfileGroup& operator=(ActionProfileGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionProfileGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionProfileGroup* internal_default_instance() {
    return reinterpret_cast<const ActionProfileGroup*>(
               &_ActionProfileGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ActionProfileGroup& a, ActionProfileGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionProfileGroup* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionProfileGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionProfileGroup* New() const final {
    return new ActionProfileGroup();
  }

  ActionProfileGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionProfileGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionProfileGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ActionProfileGroup& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionProfileGroup* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.ActionProfileGroup";
  }
  protected:
  explicit ActionProfileGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ActionProfileGroup_Member Member;

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 3,
    kActionProfileIdFieldNumber = 1,
    kGroupIdFieldNumber = 2,
    kMaxSizeFieldNumber = 4,
  };
  // repeated .p4.v1.ActionProfileGroup.Member members = 3;
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  ::p4::v1::ActionProfileGroup_Member* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::ActionProfileGroup_Member >*
      mutable_members();
  private:
  const ::p4::v1::ActionProfileGroup_Member& _internal_members(int index) const;
  ::p4::v1::ActionProfileGroup_Member* _internal_add_members();
  public:
  const ::p4::v1::ActionProfileGroup_Member& members(int index) const;
  ::p4::v1::ActionProfileGroup_Member* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::ActionProfileGroup_Member >&
      members() const;

  // uint32 action_profile_id = 1;
  void clear_action_profile_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 action_profile_id() const;
  void set_action_profile_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_action_profile_id() const;
  void _internal_set_action_profile_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 group_id = 2;
  void clear_group_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 group_id() const;
  void set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_group_id() const;
  void _internal_set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // int32 max_size = 4;
  void clear_max_size();
  ::PROTOBUF_NAMESPACE_ID::int32 max_size() const;
  void set_max_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_size() const;
  void _internal_set_max_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.ActionProfileGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::ActionProfileGroup_Member > members_;
  ::PROTOBUF_NAMESPACE_ID::uint32 action_profile_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 group_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class Index final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.Index) */ {
 public:
  inline Index() : Index(nullptr) {}
  ~Index() override;
  explicit constexpr Index(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Index(const Index& from);
  Index(Index&& from) noexcept
    : Index() {
    *this = ::std::move(from);
  }

  inline Index& operator=(const Index& from) {
    CopyFrom(from);
    return *this;
  }
  inline Index& operator=(Index&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Index& default_instance() {
    return *internal_default_instance();
  }
  static inline const Index* internal_default_instance() {
    return reinterpret_cast<const Index*>(
               &_Index_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(Index& a, Index& b) {
    a.Swap(&b);
  }
  inline void Swap(Index* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Index* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Index* New() const final {
    return new Index();
  }

  Index* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Index>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Index& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Index& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Index* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.Index";
  }
  protected:
  explicit Index(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // int64 index = 1;
  void clear_index();
  ::PROTOBUF_NAMESPACE_ID::int64 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_index() const;
  void _internal_set_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.Index)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class MeterEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.MeterEntry) */ {
 public:
  inline MeterEntry() : MeterEntry(nullptr) {}
  ~MeterEntry() override;
  explicit constexpr MeterEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MeterEntry(const MeterEntry& from);
  MeterEntry(MeterEntry&& from) noexcept
    : MeterEntry() {
    *this = ::std::move(from);
  }

  inline MeterEntry& operator=(const MeterEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeterEntry& operator=(MeterEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MeterEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const MeterEntry* internal_default_instance() {
    return reinterpret_cast<const MeterEntry*>(
               &_MeterEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(MeterEntry& a, MeterEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(MeterEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeterEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MeterEntry* New() const final {
    return new MeterEntry();
  }

  MeterEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MeterEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MeterEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MeterEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MeterEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.MeterEntry";
  }
  protected:
  explicit MeterEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 2,
    kConfigFieldNumber = 3,
    kMeterIdFieldNumber = 1,
  };
  // .p4.v1.Index index = 2;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  const ::p4::v1::Index& index() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::Index* release_index();
  ::p4::v1::Index* mutable_index();
  void set_allocated_index(::p4::v1::Index* index);
  private:
  const ::p4::v1::Index& _internal_index() const;
  ::p4::v1::Index* _internal_mutable_index();
  public:
  void unsafe_arena_set_allocated_index(
      ::p4::v1::Index* index);
  ::p4::v1::Index* unsafe_arena_release_index();

  // .p4.v1.MeterConfig config = 3;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::p4::v1::MeterConfig& config() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::MeterConfig* release_config();
  ::p4::v1::MeterConfig* mutable_config();
  void set_allocated_config(::p4::v1::MeterConfig* config);
  private:
  const ::p4::v1::MeterConfig& _internal_config() const;
  ::p4::v1::MeterConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::p4::v1::MeterConfig* config);
  ::p4::v1::MeterConfig* unsafe_arena_release_config();

  // uint32 meter_id = 1;
  void clear_meter_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 meter_id() const;
  void set_meter_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_meter_id() const;
  void _internal_set_meter_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.MeterEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::p4::v1::Index* index_;
  ::p4::v1::MeterConfig* config_;
  ::PROTOBUF_NAMESPACE_ID::uint32 meter_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class DirectMeterEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.DirectMeterEntry) */ {
 public:
  inline DirectMeterEntry() : DirectMeterEntry(nullptr) {}
  ~DirectMeterEntry() override;
  explicit constexpr DirectMeterEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectMeterEntry(const DirectMeterEntry& from);
  DirectMeterEntry(DirectMeterEntry&& from) noexcept
    : DirectMeterEntry() {
    *this = ::std::move(from);
  }

  inline DirectMeterEntry& operator=(const DirectMeterEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectMeterEntry& operator=(DirectMeterEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DirectMeterEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectMeterEntry* internal_default_instance() {
    return reinterpret_cast<const DirectMeterEntry*>(
               &_DirectMeterEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(DirectMeterEntry& a, DirectMeterEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectMeterEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectMeterEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DirectMeterEntry* New() const final {
    return new DirectMeterEntry();
  }

  DirectMeterEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectMeterEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DirectMeterEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DirectMeterEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectMeterEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.DirectMeterEntry";
  }
  protected:
  explicit DirectMeterEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableEntryFieldNumber = 1,
    kConfigFieldNumber = 2,
  };
  // .p4.v1.TableEntry table_entry = 1;
  bool has_table_entry() const;
  private:
  bool _internal_has_table_entry() const;
  public:
  void clear_table_entry();
  const ::p4::v1::TableEntry& table_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::TableEntry* release_table_entry();
  ::p4::v1::TableEntry* mutable_table_entry();
  void set_allocated_table_entry(::p4::v1::TableEntry* table_entry);
  private:
  const ::p4::v1::TableEntry& _internal_table_entry() const;
  ::p4::v1::TableEntry* _internal_mutable_table_entry();
  public:
  void unsafe_arena_set_allocated_table_entry(
      ::p4::v1::TableEntry* table_entry);
  ::p4::v1::TableEntry* unsafe_arena_release_table_entry();

  // .p4.v1.MeterConfig config = 2;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::p4::v1::MeterConfig& config() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::MeterConfig* release_config();
  ::p4::v1::MeterConfig* mutable_config();
  void set_allocated_config(::p4::v1::MeterConfig* config);
  private:
  const ::p4::v1::MeterConfig& _internal_config() const;
  ::p4::v1::MeterConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::p4::v1::MeterConfig* config);
  ::p4::v1::MeterConfig* unsafe_arena_release_config();

  // @@protoc_insertion_point(class_scope:p4.v1.DirectMeterEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::p4::v1::TableEntry* table_entry_;
  ::p4::v1::MeterConfig* config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class MeterConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.MeterConfig) */ {
 public:
  inline MeterConfig() : MeterConfig(nullptr) {}
  ~MeterConfig() override;
  explicit constexpr MeterConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MeterConfig(const MeterConfig& from);
  MeterConfig(MeterConfig&& from) noexcept
    : MeterConfig() {
    *this = ::std::move(from);
  }

  inline MeterConfig& operator=(const MeterConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeterConfig& operator=(MeterConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MeterConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const MeterConfig* internal_default_instance() {
    return reinterpret_cast<const MeterConfig*>(
               &_MeterConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(MeterConfig& a, MeterConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(MeterConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeterConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MeterConfig* New() const final {
    return new MeterConfig();
  }

  MeterConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MeterConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MeterConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MeterConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MeterConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.MeterConfig";
  }
  protected:
  explicit MeterConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCirFieldNumber = 1,
    kCburstFieldNumber = 2,
    kPirFieldNumber = 3,
    kPburstFieldNumber = 4,
  };
  // int64 cir = 1;
  void clear_cir();
  ::PROTOBUF_NAMESPACE_ID::int64 cir() const;
  void set_cir(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_cir() const;
  void _internal_set_cir(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 cburst = 2;
  void clear_cburst();
  ::PROTOBUF_NAMESPACE_ID::int64 cburst() const;
  void set_cburst(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_cburst() const;
  void _internal_set_cburst(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 pir = 3;
  void clear_pir();
  ::PROTOBUF_NAMESPACE_ID::int64 pir() const;
  void set_pir(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_pir() const;
  void _internal_set_pir(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 pburst = 4;
  void clear_pburst();
  ::PROTOBUF_NAMESPACE_ID::int64 pburst() const;
  void set_pburst(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_pburst() const;
  void _internal_set_pburst(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.MeterConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 cir_;
  ::PROTOBUF_NAMESPACE_ID::int64 cburst_;
  ::PROTOBUF_NAMESPACE_ID::int64 pir_;
  ::PROTOBUF_NAMESPACE_ID::int64 pburst_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class CounterEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.CounterEntry) */ {
 public:
  inline CounterEntry() : CounterEntry(nullptr) {}
  ~CounterEntry() override;
  explicit constexpr CounterEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CounterEntry(const CounterEntry& from);
  CounterEntry(CounterEntry&& from) noexcept
    : CounterEntry() {
    *this = ::std::move(from);
  }

  inline CounterEntry& operator=(const CounterEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline CounterEntry& operator=(CounterEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CounterEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const CounterEntry* internal_default_instance() {
    return reinterpret_cast<const CounterEntry*>(
               &_CounterEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(CounterEntry& a, CounterEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(CounterEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CounterEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CounterEntry* New() const final {
    return new CounterEntry();
  }

  CounterEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CounterEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CounterEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CounterEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CounterEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.CounterEntry";
  }
  protected:
  explicit CounterEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 2,
    kDataFieldNumber = 3,
    kCounterIdFieldNumber = 1,
  };
  // .p4.v1.Index index = 2;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  const ::p4::v1::Index& index() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::Index* release_index();
  ::p4::v1::Index* mutable_index();
  void set_allocated_index(::p4::v1::Index* index);
  private:
  const ::p4::v1::Index& _internal_index() const;
  ::p4::v1::Index* _internal_mutable_index();
  public:
  void unsafe_arena_set_allocated_index(
      ::p4::v1::Index* index);
  ::p4::v1::Index* unsafe_arena_release_index();

  // .p4.v1.CounterData data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::p4::v1::CounterData& data() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::CounterData* release_data();
  ::p4::v1::CounterData* mutable_data();
  void set_allocated_data(::p4::v1::CounterData* data);
  private:
  const ::p4::v1::CounterData& _internal_data() const;
  ::p4::v1::CounterData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::p4::v1::CounterData* data);
  ::p4::v1::CounterData* unsafe_arena_release_data();

  // uint32 counter_id = 1;
  void clear_counter_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 counter_id() const;
  void set_counter_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_counter_id() const;
  void _internal_set_counter_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.CounterEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::p4::v1::Index* index_;
  ::p4::v1::CounterData* data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 counter_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class DirectCounterEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.DirectCounterEntry) */ {
 public:
  inline DirectCounterEntry() : DirectCounterEntry(nullptr) {}
  ~DirectCounterEntry() override;
  explicit constexpr DirectCounterEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectCounterEntry(const DirectCounterEntry& from);
  DirectCounterEntry(DirectCounterEntry&& from) noexcept
    : DirectCounterEntry() {
    *this = ::std::move(from);
  }

  inline DirectCounterEntry& operator=(const DirectCounterEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectCounterEntry& operator=(DirectCounterEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DirectCounterEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectCounterEntry* internal_default_instance() {
    return reinterpret_cast<const DirectCounterEntry*>(
               &_DirectCounterEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(DirectCounterEntry& a, DirectCounterEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectCounterEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectCounterEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DirectCounterEntry* New() const final {
    return new DirectCounterEntry();
  }

  DirectCounterEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectCounterEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DirectCounterEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DirectCounterEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectCounterEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.DirectCounterEntry";
  }
  protected:
  explicit DirectCounterEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableEntryFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // .p4.v1.TableEntry table_entry = 1;
  bool has_table_entry() const;
  private:
  bool _internal_has_table_entry() const;
  public:
  void clear_table_entry();
  const ::p4::v1::TableEntry& table_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::TableEntry* release_table_entry();
  ::p4::v1::TableEntry* mutable_table_entry();
  void set_allocated_table_entry(::p4::v1::TableEntry* table_entry);
  private:
  const ::p4::v1::TableEntry& _internal_table_entry() const;
  ::p4::v1::TableEntry* _internal_mutable_table_entry();
  public:
  void unsafe_arena_set_allocated_table_entry(
      ::p4::v1::TableEntry* table_entry);
  ::p4::v1::TableEntry* unsafe_arena_release_table_entry();

  // .p4.v1.CounterData data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::p4::v1::CounterData& data() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::CounterData* release_data();
  ::p4::v1::CounterData* mutable_data();
  void set_allocated_data(::p4::v1::CounterData* data);
  private:
  const ::p4::v1::CounterData& _internal_data() const;
  ::p4::v1::CounterData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::p4::v1::CounterData* data);
  ::p4::v1::CounterData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:p4.v1.DirectCounterEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::p4::v1::TableEntry* table_entry_;
  ::p4::v1::CounterData* data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class CounterData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.CounterData) */ {
 public:
  inline CounterData() : CounterData(nullptr) {}
  ~CounterData() override;
  explicit constexpr CounterData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CounterData(const CounterData& from);
  CounterData(CounterData&& from) noexcept
    : CounterData() {
    *this = ::std::move(from);
  }

  inline CounterData& operator=(const CounterData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CounterData& operator=(CounterData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CounterData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CounterData* internal_default_instance() {
    return reinterpret_cast<const CounterData*>(
               &_CounterData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(CounterData& a, CounterData& b) {
    a.Swap(&b);
  }
  inline void Swap(CounterData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CounterData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CounterData* New() const final {
    return new CounterData();
  }

  CounterData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CounterData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CounterData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CounterData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CounterData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.CounterData";
  }
  protected:
  explicit CounterData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kByteCountFieldNumber = 1,
    kPacketCountFieldNumber = 2,
  };
  // int64 byte_count = 1;
  void clear_byte_count();
  ::PROTOBUF_NAMESPACE_ID::int64 byte_count() const;
  void set_byte_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_byte_count() const;
  void _internal_set_byte_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 packet_count = 2;
  void clear_packet_count();
  ::PROTOBUF_NAMESPACE_ID::int64 packet_count() const;
  void set_packet_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_packet_count() const;
  void _internal_set_packet_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.CounterData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 byte_count_;
  ::PROTOBUF_NAMESPACE_ID::int64 packet_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class PacketReplicationEngineEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.PacketReplicationEngineEntry) */ {
 public:
  inline PacketReplicationEngineEntry() : PacketReplicationEngineEntry(nullptr) {}
  ~PacketReplicationEngineEntry() override;
  explicit constexpr PacketReplicationEngineEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PacketReplicationEngineEntry(const PacketReplicationEngineEntry& from);
  PacketReplicationEngineEntry(PacketReplicationEngineEntry&& from) noexcept
    : PacketReplicationEngineEntry() {
    *this = ::std::move(from);
  }

  inline PacketReplicationEngineEntry& operator=(const PacketReplicationEngineEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline PacketReplicationEngineEntry& operator=(PacketReplicationEngineEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PacketReplicationEngineEntry& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kMulticastGroupEntry = 1,
    kCloneSessionEntry = 2,
    TYPE_NOT_SET = 0,
  };

  static inline const PacketReplicationEngineEntry* internal_default_instance() {
    return reinterpret_cast<const PacketReplicationEngineEntry*>(
               &_PacketReplicationEngineEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(PacketReplicationEngineEntry& a, PacketReplicationEngineEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(PacketReplicationEngineEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PacketReplicationEngineEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PacketReplicationEngineEntry* New() const final {
    return new PacketReplicationEngineEntry();
  }

  PacketReplicationEngineEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PacketReplicationEngineEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PacketReplicationEngineEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PacketReplicationEngineEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PacketReplicationEngineEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.PacketReplicationEngineEntry";
  }
  protected:
  explicit PacketReplicationEngineEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMulticastGroupEntryFieldNumber = 1,
    kCloneSessionEntryFieldNumber = 2,
  };
  // .p4.v1.MulticastGroupEntry multicast_group_entry = 1;
  bool has_multicast_group_entry() const;
  private:
  bool _internal_has_multicast_group_entry() const;
  public:
  void clear_multicast_group_entry();
  const ::p4::v1::MulticastGroupEntry& multicast_group_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::MulticastGroupEntry* release_multicast_group_entry();
  ::p4::v1::MulticastGroupEntry* mutable_multicast_group_entry();
  void set_allocated_multicast_group_entry(::p4::v1::MulticastGroupEntry* multicast_group_entry);
  private:
  const ::p4::v1::MulticastGroupEntry& _internal_multicast_group_entry() const;
  ::p4::v1::MulticastGroupEntry* _internal_mutable_multicast_group_entry();
  public:
  void unsafe_arena_set_allocated_multicast_group_entry(
      ::p4::v1::MulticastGroupEntry* multicast_group_entry);
  ::p4::v1::MulticastGroupEntry* unsafe_arena_release_multicast_group_entry();

  // .p4.v1.CloneSessionEntry clone_session_entry = 2;
  bool has_clone_session_entry() const;
  private:
  bool _internal_has_clone_session_entry() const;
  public:
  void clear_clone_session_entry();
  const ::p4::v1::CloneSessionEntry& clone_session_entry() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::CloneSessionEntry* release_clone_session_entry();
  ::p4::v1::CloneSessionEntry* mutable_clone_session_entry();
  void set_allocated_clone_session_entry(::p4::v1::CloneSessionEntry* clone_session_entry);
  private:
  const ::p4::v1::CloneSessionEntry& _internal_clone_session_entry() const;
  ::p4::v1::CloneSessionEntry* _internal_mutable_clone_session_entry();
  public:
  void unsafe_arena_set_allocated_clone_session_entry(
      ::p4::v1::CloneSessionEntry* clone_session_entry);
  ::p4::v1::CloneSessionEntry* unsafe_arena_release_clone_session_entry();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:p4.v1.PacketReplicationEngineEntry)
 private:
  class _Internal;
  void set_has_multicast_group_entry();
  void set_has_clone_session_entry();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::p4::v1::MulticastGroupEntry* multicast_group_entry_;
    ::p4::v1::CloneSessionEntry* clone_session_entry_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class Replica final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.Replica) */ {
 public:
  inline Replica() : Replica(nullptr) {}
  ~Replica() override;
  explicit constexpr Replica(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Replica(const Replica& from);
  Replica(Replica&& from) noexcept
    : Replica() {
    *this = ::std::move(from);
  }

  inline Replica& operator=(const Replica& from) {
    CopyFrom(from);
    return *this;
  }
  inline Replica& operator=(Replica&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Replica& default_instance() {
    return *internal_default_instance();
  }
  static inline const Replica* internal_default_instance() {
    return reinterpret_cast<const Replica*>(
               &_Replica_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(Replica& a, Replica& b) {
    a.Swap(&b);
  }
  inline void Swap(Replica* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Replica* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Replica* New() const final {
    return new Replica();
  }

  Replica* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Replica>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Replica& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Replica& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Replica* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.Replica";
  }
  protected:
  explicit Replica(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEgressPortFieldNumber = 1,
    kInstanceFieldNumber = 2,
  };
  // uint32 egress_port = 1;
  void clear_egress_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 egress_port() const;
  void set_egress_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_egress_port() const;
  void _internal_set_egress_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 instance = 2;
  void clear_instance();
  ::PROTOBUF_NAMESPACE_ID::uint32 instance() const;
  void set_instance(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_instance() const;
  void _internal_set_instance(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.Replica)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 egress_port_;
  ::PROTOBUF_NAMESPACE_ID::uint32 instance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class MulticastGroupEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.MulticastGroupEntry) */ {
 public:
  inline MulticastGroupEntry() : MulticastGroupEntry(nullptr) {}
  ~MulticastGroupEntry() override;
  explicit constexpr MulticastGroupEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MulticastGroupEntry(const MulticastGroupEntry& from);
  MulticastGroupEntry(MulticastGroupEntry&& from) noexcept
    : MulticastGroupEntry() {
    *this = ::std::move(from);
  }

  inline MulticastGroupEntry& operator=(const MulticastGroupEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline MulticastGroupEntry& operator=(MulticastGroupEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MulticastGroupEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const MulticastGroupEntry* internal_default_instance() {
    return reinterpret_cast<const MulticastGroupEntry*>(
               &_MulticastGroupEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(MulticastGroupEntry& a, MulticastGroupEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(MulticastGroupEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MulticastGroupEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MulticastGroupEntry* New() const final {
    return new MulticastGroupEntry();
  }

  MulticastGroupEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MulticastGroupEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MulticastGroupEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MulticastGroupEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MulticastGroupEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.MulticastGroupEntry";
  }
  protected:
  explicit MulticastGroupEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplicasFieldNumber = 2,
    kMulticastGroupIdFieldNumber = 1,
  };
  // repeated .p4.v1.Replica replicas = 2;
  int replicas_size() const;
  private:
  int _internal_replicas_size() const;
  public:
  void clear_replicas();
  ::p4::v1::Replica* mutable_replicas(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Replica >*
      mutable_replicas();
  private:
  const ::p4::v1::Replica& _internal_replicas(int index) const;
  ::p4::v1::Replica* _internal_add_replicas();
  public:
  const ::p4::v1::Replica& replicas(int index) const;
  ::p4::v1::Replica* add_replicas();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Replica >&
      replicas() const;

  // uint32 multicast_group_id = 1;
  void clear_multicast_group_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 multicast_group_id() const;
  void set_multicast_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_multicast_group_id() const;
  void _internal_set_multicast_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.MulticastGroupEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Replica > replicas_;
  ::PROTOBUF_NAMESPACE_ID::uint32 multicast_group_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class CloneSessionEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.CloneSessionEntry) */ {
 public:
  inline CloneSessionEntry() : CloneSessionEntry(nullptr) {}
  ~CloneSessionEntry() override;
  explicit constexpr CloneSessionEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloneSessionEntry(const CloneSessionEntry& from);
  CloneSessionEntry(CloneSessionEntry&& from) noexcept
    : CloneSessionEntry() {
    *this = ::std::move(from);
  }

  inline CloneSessionEntry& operator=(const CloneSessionEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloneSessionEntry& operator=(CloneSessionEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloneSessionEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloneSessionEntry* internal_default_instance() {
    return reinterpret_cast<const CloneSessionEntry*>(
               &_CloneSessionEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(CloneSessionEntry& a, CloneSessionEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(CloneSessionEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloneSessionEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CloneSessionEntry* New() const final {
    return new CloneSessionEntry();
  }

  CloneSessionEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CloneSessionEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CloneSessionEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CloneSessionEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloneSessionEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.CloneSessionEntry";
  }
  protected:
  explicit CloneSessionEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplicasFieldNumber = 2,
    kSessionIdFieldNumber = 1,
    kClassOfServiceFieldNumber = 3,
    kPacketLengthBytesFieldNumber = 4,
  };
  // repeated .p4.v1.Replica replicas = 2;
  int replicas_size() const;
  private:
  int _internal_replicas_size() const;
  public:
  void clear_replicas();
  ::p4::v1::Replica* mutable_replicas(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Replica >*
      mutable_replicas();
  private:
  const ::p4::v1::Replica& _internal_replicas(int index) const;
  ::p4::v1::Replica* _internal_add_replicas();
  public:
  const ::p4::v1::Replica& replicas(int index) const;
  ::p4::v1::Replica* add_replicas();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Replica >&
      replicas() const;

  // uint32 session_id = 1;
  void clear_session_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 session_id() const;
  void set_session_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_session_id() const;
  void _internal_set_session_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 class_of_service = 3;
  void clear_class_of_service();
  ::PROTOBUF_NAMESPACE_ID::uint32 class_of_service() const;
  void set_class_of_service(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_class_of_service() const;
  void _internal_set_class_of_service(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // int32 packet_length_bytes = 4;
  void clear_packet_length_bytes();
  ::PROTOBUF_NAMESPACE_ID::int32 packet_length_bytes() const;
  void set_packet_length_bytes(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_packet_length_bytes() const;
  void _internal_set_packet_length_bytes(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.CloneSessionEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Replica > replicas_;
  ::PROTOBUF_NAMESPACE_ID::uint32 session_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 class_of_service_;
  ::PROTOBUF_NAMESPACE_ID::int32 packet_length_bytes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class ValueSetMember final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.ValueSetMember) */ {
 public:
  inline ValueSetMember() : ValueSetMember(nullptr) {}
  ~ValueSetMember() override;
  explicit constexpr ValueSetMember(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValueSetMember(const ValueSetMember& from);
  ValueSetMember(ValueSetMember&& from) noexcept
    : ValueSetMember() {
    *this = ::std::move(from);
  }

  inline ValueSetMember& operator=(const ValueSetMember& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValueSetMember& operator=(ValueSetMember&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValueSetMember& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValueSetMember* internal_default_instance() {
    return reinterpret_cast<const ValueSetMember*>(
               &_ValueSetMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(ValueSetMember& a, ValueSetMember& b) {
    a.Swap(&b);
  }
  inline void Swap(ValueSetMember* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValueSetMember* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValueSetMember* New() const final {
    return new ValueSetMember();
  }

  ValueSetMember* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValueSetMember>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValueSetMember& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ValueSetMember& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValueSetMember* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.ValueSetMember";
  }
  protected:
  explicit ValueSetMember(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchFieldNumber = 1,
  };
  // repeated .p4.v1.FieldMatch match = 1;
  int match_size() const;
  private:
  int _internal_match_size() const;
  public:
  void clear_match();
  ::p4::v1::FieldMatch* mutable_match(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::FieldMatch >*
      mutable_match();
  private:
  const ::p4::v1::FieldMatch& _internal_match(int index) const;
  ::p4::v1::FieldMatch* _internal_add_match();
  public:
  const ::p4::v1::FieldMatch& match(int index) const;
  ::p4::v1::FieldMatch* add_match();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::FieldMatch >&
      match() const;

  // @@protoc_insertion_point(class_scope:p4.v1.ValueSetMember)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::FieldMatch > match_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class ValueSetEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.ValueSetEntry) */ {
 public:
  inline ValueSetEntry() : ValueSetEntry(nullptr) {}
  ~ValueSetEntry() override;
  explicit constexpr ValueSetEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValueSetEntry(const ValueSetEntry& from);
  ValueSetEntry(ValueSetEntry&& from) noexcept
    : ValueSetEntry() {
    *this = ::std::move(from);
  }

  inline ValueSetEntry& operator=(const ValueSetEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValueSetEntry& operator=(ValueSetEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValueSetEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValueSetEntry* internal_default_instance() {
    return reinterpret_cast<const ValueSetEntry*>(
               &_ValueSetEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(ValueSetEntry& a, ValueSetEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(ValueSetEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValueSetEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValueSetEntry* New() const final {
    return new ValueSetEntry();
  }

  ValueSetEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValueSetEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValueSetEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ValueSetEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValueSetEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.ValueSetEntry";
  }
  protected:
  explicit ValueSetEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 2,
    kValueSetIdFieldNumber = 1,
  };
  // repeated .p4.v1.ValueSetMember members = 2;
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  ::p4::v1::ValueSetMember* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::ValueSetMember >*
      mutable_members();
  private:
  const ::p4::v1::ValueSetMember& _internal_members(int index) const;
  ::p4::v1::ValueSetMember* _internal_add_members();
  public:
  const ::p4::v1::ValueSetMember& members(int index) const;
  ::p4::v1::ValueSetMember* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::ValueSetMember >&
      members() const;

  // uint32 value_set_id = 1;
  void clear_value_set_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 value_set_id() const;
  void set_value_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_value_set_id() const;
  void _internal_set_value_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.ValueSetEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::ValueSetMember > members_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_set_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class RegisterEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.RegisterEntry) */ {
 public:
  inline RegisterEntry() : RegisterEntry(nullptr) {}
  ~RegisterEntry() override;
  explicit constexpr RegisterEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterEntry(const RegisterEntry& from);
  RegisterEntry(RegisterEntry&& from) noexcept
    : RegisterEntry() {
    *this = ::std::move(from);
  }

  inline RegisterEntry& operator=(const RegisterEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterEntry& operator=(RegisterEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterEntry* internal_default_instance() {
    return reinterpret_cast<const RegisterEntry*>(
               &_RegisterEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(RegisterEntry& a, RegisterEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegisterEntry* New() const final {
    return new RegisterEntry();
  }

  RegisterEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegisterEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegisterEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.RegisterEntry";
  }
  protected:
  explicit RegisterEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 2,
    kDataFieldNumber = 3,
    kRegisterIdFieldNumber = 1,
  };
  // .p4.v1.Index index = 2;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  const ::p4::v1::Index& index() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::Index* release_index();
  ::p4::v1::Index* mutable_index();
  void set_allocated_index(::p4::v1::Index* index);
  private:
  const ::p4::v1::Index& _internal_index() const;
  ::p4::v1::Index* _internal_mutable_index();
  public:
  void unsafe_arena_set_allocated_index(
      ::p4::v1::Index* index);
  ::p4::v1::Index* unsafe_arena_release_index();

  // .p4.v1.P4Data data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::p4::v1::P4Data& data() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::P4Data* release_data();
  ::p4::v1::P4Data* mutable_data();
  void set_allocated_data(::p4::v1::P4Data* data);
  private:
  const ::p4::v1::P4Data& _internal_data() const;
  ::p4::v1::P4Data* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::p4::v1::P4Data* data);
  ::p4::v1::P4Data* unsafe_arena_release_data();

  // uint32 register_id = 1;
  void clear_register_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 register_id() const;
  void set_register_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_register_id() const;
  void _internal_set_register_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.RegisterEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::p4::v1::Index* index_;
  ::p4::v1::P4Data* data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 register_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class DigestEntry_Config final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.DigestEntry.Config) */ {
 public:
  inline DigestEntry_Config() : DigestEntry_Config(nullptr) {}
  ~DigestEntry_Config() override;
  explicit constexpr DigestEntry_Config(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DigestEntry_Config(const DigestEntry_Config& from);
  DigestEntry_Config(DigestEntry_Config&& from) noexcept
    : DigestEntry_Config() {
    *this = ::std::move(from);
  }

  inline DigestEntry_Config& operator=(const DigestEntry_Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline DigestEntry_Config& operator=(DigestEntry_Config&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DigestEntry_Config& default_instance() {
    return *internal_default_instance();
  }
  static inline const DigestEntry_Config* internal_default_instance() {
    return reinterpret_cast<const DigestEntry_Config*>(
               &_DigestEntry_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(DigestEntry_Config& a, DigestEntry_Config& b) {
    a.Swap(&b);
  }
  inline void Swap(DigestEntry_Config* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DigestEntry_Config* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DigestEntry_Config* New() const final {
    return new DigestEntry_Config();
  }

  DigestEntry_Config* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DigestEntry_Config>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DigestEntry_Config& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DigestEntry_Config& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DigestEntry_Config* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.DigestEntry.Config";
  }
  protected:
  explicit DigestEntry_Config(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxTimeoutNsFieldNumber = 1,
    kAckTimeoutNsFieldNumber = 3,
    kMaxListSizeFieldNumber = 2,
  };
  // int64 max_timeout_ns = 1;
  void clear_max_timeout_ns();
  ::PROTOBUF_NAMESPACE_ID::int64 max_timeout_ns() const;
  void set_max_timeout_ns(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_max_timeout_ns() const;
  void _internal_set_max_timeout_ns(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 ack_timeout_ns = 3;
  void clear_ack_timeout_ns();
  ::PROTOBUF_NAMESPACE_ID::int64 ack_timeout_ns() const;
  void set_ack_timeout_ns(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_ack_timeout_ns() const;
  void _internal_set_ack_timeout_ns(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 max_list_size = 2;
  void clear_max_list_size();
  ::PROTOBUF_NAMESPACE_ID::int32 max_list_size() const;
  void set_max_list_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_list_size() const;
  void _internal_set_max_list_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.DigestEntry.Config)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 max_timeout_ns_;
  ::PROTOBUF_NAMESPACE_ID::int64 ack_timeout_ns_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_list_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class DigestEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.DigestEntry) */ {
 public:
  inline DigestEntry() : DigestEntry(nullptr) {}
  ~DigestEntry() override;
  explicit constexpr DigestEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DigestEntry(const DigestEntry& from);
  DigestEntry(DigestEntry&& from) noexcept
    : DigestEntry() {
    *this = ::std::move(from);
  }

  inline DigestEntry& operator=(const DigestEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline DigestEntry& operator=(DigestEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DigestEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const DigestEntry* internal_default_instance() {
    return reinterpret_cast<const DigestEntry*>(
               &_DigestEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(DigestEntry& a, DigestEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(DigestEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DigestEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DigestEntry* New() const final {
    return new DigestEntry();
  }

  DigestEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DigestEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DigestEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DigestEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DigestEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.DigestEntry";
  }
  protected:
  explicit DigestEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DigestEntry_Config Config;

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 2,
    kDigestIdFieldNumber = 1,
  };
  // .p4.v1.DigestEntry.Config config = 2;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::p4::v1::DigestEntry_Config& config() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::DigestEntry_Config* release_config();
  ::p4::v1::DigestEntry_Config* mutable_config();
  void set_allocated_config(::p4::v1::DigestEntry_Config* config);
  private:
  const ::p4::v1::DigestEntry_Config& _internal_config() const;
  ::p4::v1::DigestEntry_Config* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::p4::v1::DigestEntry_Config* config);
  ::p4::v1::DigestEntry_Config* unsafe_arena_release_config();

  // uint32 digest_id = 1;
  void clear_digest_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 digest_id() const;
  void set_digest_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_digest_id() const;
  void _internal_set_digest_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.DigestEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::p4::v1::DigestEntry_Config* config_;
  ::PROTOBUF_NAMESPACE_ID::uint32 digest_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class StreamMessageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.StreamMessageRequest) */ {
 public:
  inline StreamMessageRequest() : StreamMessageRequest(nullptr) {}
  ~StreamMessageRequest() override;
  explicit constexpr StreamMessageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamMessageRequest(const StreamMessageRequest& from);
  StreamMessageRequest(StreamMessageRequest&& from) noexcept
    : StreamMessageRequest() {
    *this = ::std::move(from);
  }

  inline StreamMessageRequest& operator=(const StreamMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamMessageRequest& operator=(StreamMessageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamMessageRequest& default_instance() {
    return *internal_default_instance();
  }
  enum UpdateCase {
    kArbitration = 1,
    kPacket = 2,
    kDigestAck = 3,
    kOther = 4,
    UPDATE_NOT_SET = 0,
  };

  static inline const StreamMessageRequest* internal_default_instance() {
    return reinterpret_cast<const StreamMessageRequest*>(
               &_StreamMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(StreamMessageRequest& a, StreamMessageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamMessageRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamMessageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamMessageRequest* New() const final {
    return new StreamMessageRequest();
  }

  StreamMessageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamMessageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamMessageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StreamMessageRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamMessageRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.StreamMessageRequest";
  }
  protected:
  explicit StreamMessageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArbitrationFieldNumber = 1,
    kPacketFieldNumber = 2,
    kDigestAckFieldNumber = 3,
    kOtherFieldNumber = 4,
  };
  // .p4.v1.MasterArbitrationUpdate arbitration = 1;
  bool has_arbitration() const;
  private:
  bool _internal_has_arbitration() const;
  public:
  void clear_arbitration();
  const ::p4::v1::MasterArbitrationUpdate& arbitration() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::MasterArbitrationUpdate* release_arbitration();
  ::p4::v1::MasterArbitrationUpdate* mutable_arbitration();
  void set_allocated_arbitration(::p4::v1::MasterArbitrationUpdate* arbitration);
  private:
  const ::p4::v1::MasterArbitrationUpdate& _internal_arbitration() const;
  ::p4::v1::MasterArbitrationUpdate* _internal_mutable_arbitration();
  public:
  void unsafe_arena_set_allocated_arbitration(
      ::p4::v1::MasterArbitrationUpdate* arbitration);
  ::p4::v1::MasterArbitrationUpdate* unsafe_arena_release_arbitration();

  // .p4.v1.PacketOut packet = 2;
  bool has_packet() const;
  private:
  bool _internal_has_packet() const;
  public:
  void clear_packet();
  const ::p4::v1::PacketOut& packet() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::PacketOut* release_packet();
  ::p4::v1::PacketOut* mutable_packet();
  void set_allocated_packet(::p4::v1::PacketOut* packet);
  private:
  const ::p4::v1::PacketOut& _internal_packet() const;
  ::p4::v1::PacketOut* _internal_mutable_packet();
  public:
  void unsafe_arena_set_allocated_packet(
      ::p4::v1::PacketOut* packet);
  ::p4::v1::PacketOut* unsafe_arena_release_packet();

  // .p4.v1.DigestListAck digest_ack = 3;
  bool has_digest_ack() const;
  private:
  bool _internal_has_digest_ack() const;
  public:
  void clear_digest_ack();
  const ::p4::v1::DigestListAck& digest_ack() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::DigestListAck* release_digest_ack();
  ::p4::v1::DigestListAck* mutable_digest_ack();
  void set_allocated_digest_ack(::p4::v1::DigestListAck* digest_ack);
  private:
  const ::p4::v1::DigestListAck& _internal_digest_ack() const;
  ::p4::v1::DigestListAck* _internal_mutable_digest_ack();
  public:
  void unsafe_arena_set_allocated_digest_ack(
      ::p4::v1::DigestListAck* digest_ack);
  ::p4::v1::DigestListAck* unsafe_arena_release_digest_ack();

  // .google.protobuf.Any other = 4;
  bool has_other() const;
  private:
  bool _internal_has_other() const;
  public:
  void clear_other();
  const ::PROTOBUF_NAMESPACE_ID::Any& other() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Any* release_other();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_other();
  void set_allocated_other(::PROTOBUF_NAMESPACE_ID::Any* other);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_other() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_other();
  public:
  void unsafe_arena_set_allocated_other(
      ::PROTOBUF_NAMESPACE_ID::Any* other);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_other();

  void clear_update();
  UpdateCase update_case() const;
  // @@protoc_insertion_point(class_scope:p4.v1.StreamMessageRequest)
 private:
  class _Internal;
  void set_has_arbitration();
  void set_has_packet();
  void set_has_digest_ack();
  void set_has_other();

  inline bool has_update() const;
  inline void clear_has_update();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union UpdateUnion {
    constexpr UpdateUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::p4::v1::MasterArbitrationUpdate* arbitration_;
    ::p4::v1::PacketOut* packet_;
    ::p4::v1::DigestListAck* digest_ack_;
    ::PROTOBUF_NAMESPACE_ID::Any* other_;
  } update_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class PacketOut final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.PacketOut) */ {
 public:
  inline PacketOut() : PacketOut(nullptr) {}
  ~PacketOut() override;
  explicit constexpr PacketOut(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PacketOut(const PacketOut& from);
  PacketOut(PacketOut&& from) noexcept
    : PacketOut() {
    *this = ::std::move(from);
  }

  inline PacketOut& operator=(const PacketOut& from) {
    CopyFrom(from);
    return *this;
  }
  inline PacketOut& operator=(PacketOut&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PacketOut& default_instance() {
    return *internal_default_instance();
  }
  static inline const PacketOut* internal_default_instance() {
    return reinterpret_cast<const PacketOut*>(
               &_PacketOut_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(PacketOut& a, PacketOut& b) {
    a.Swap(&b);
  }
  inline void Swap(PacketOut* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PacketOut* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PacketOut* New() const final {
    return new PacketOut();
  }

  PacketOut* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PacketOut>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PacketOut& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PacketOut& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PacketOut* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.PacketOut";
  }
  protected:
  explicit PacketOut(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 2,
    kPayloadFieldNumber = 1,
  };
  // repeated .p4.v1.PacketMetadata metadata = 2;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  ::p4::v1::PacketMetadata* mutable_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::PacketMetadata >*
      mutable_metadata();
  private:
  const ::p4::v1::PacketMetadata& _internal_metadata(int index) const;
  ::p4::v1::PacketMetadata* _internal_add_metadata();
  public:
  const ::p4::v1::PacketMetadata& metadata(int index) const;
  ::p4::v1::PacketMetadata* add_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::PacketMetadata >&
      metadata() const;

  // bytes payload = 1;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_MUST_USE_RESULT std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.PacketOut)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::PacketMetadata > metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class DigestListAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.DigestListAck) */ {
 public:
  inline DigestListAck() : DigestListAck(nullptr) {}
  ~DigestListAck() override;
  explicit constexpr DigestListAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DigestListAck(const DigestListAck& from);
  DigestListAck(DigestListAck&& from) noexcept
    : DigestListAck() {
    *this = ::std::move(from);
  }

  inline DigestListAck& operator=(const DigestListAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline DigestListAck& operator=(DigestListAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DigestListAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const DigestListAck* internal_default_instance() {
    return reinterpret_cast<const DigestListAck*>(
               &_DigestListAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(DigestListAck& a, DigestListAck& b) {
    a.Swap(&b);
  }
  inline void Swap(DigestListAck* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DigestListAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DigestListAck* New() const final {
    return new DigestListAck();
  }

  DigestListAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DigestListAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DigestListAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DigestListAck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DigestListAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.DigestListAck";
  }
  protected:
  explicit DigestListAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListIdFieldNumber = 2,
    kDigestIdFieldNumber = 1,
  };
  // uint64 list_id = 2;
  void clear_list_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 list_id() const;
  void set_list_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_list_id() const;
  void _internal_set_list_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 digest_id = 1;
  void clear_digest_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 digest_id() const;
  void set_digest_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_digest_id() const;
  void _internal_set_digest_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.DigestListAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 list_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 digest_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class StreamMessageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.StreamMessageResponse) */ {
 public:
  inline StreamMessageResponse() : StreamMessageResponse(nullptr) {}
  ~StreamMessageResponse() override;
  explicit constexpr StreamMessageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamMessageResponse(const StreamMessageResponse& from);
  StreamMessageResponse(StreamMessageResponse&& from) noexcept
    : StreamMessageResponse() {
    *this = ::std::move(from);
  }

  inline StreamMessageResponse& operator=(const StreamMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamMessageResponse& operator=(StreamMessageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamMessageResponse& default_instance() {
    return *internal_default_instance();
  }
  enum UpdateCase {
    kArbitration = 1,
    kPacket = 2,
    kDigest = 3,
    kIdleTimeoutNotification = 4,
    kOther = 5,
    kError = 6,
    UPDATE_NOT_SET = 0,
  };

  static inline const StreamMessageResponse* internal_default_instance() {
    return reinterpret_cast<const StreamMessageResponse*>(
               &_StreamMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(StreamMessageResponse& a, StreamMessageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamMessageResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamMessageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamMessageResponse* New() const final {
    return new StreamMessageResponse();
  }

  StreamMessageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamMessageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamMessageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StreamMessageResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamMessageResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.StreamMessageResponse";
  }
  protected:
  explicit StreamMessageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArbitrationFieldNumber = 1,
    kPacketFieldNumber = 2,
    kDigestFieldNumber = 3,
    kIdleTimeoutNotificationFieldNumber = 4,
    kOtherFieldNumber = 5,
    kErrorFieldNumber = 6,
  };
  // .p4.v1.MasterArbitrationUpdate arbitration = 1;
  bool has_arbitration() const;
  private:
  bool _internal_has_arbitration() const;
  public:
  void clear_arbitration();
  const ::p4::v1::MasterArbitrationUpdate& arbitration() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::MasterArbitrationUpdate* release_arbitration();
  ::p4::v1::MasterArbitrationUpdate* mutable_arbitration();
  void set_allocated_arbitration(::p4::v1::MasterArbitrationUpdate* arbitration);
  private:
  const ::p4::v1::MasterArbitrationUpdate& _internal_arbitration() const;
  ::p4::v1::MasterArbitrationUpdate* _internal_mutable_arbitration();
  public:
  void unsafe_arena_set_allocated_arbitration(
      ::p4::v1::MasterArbitrationUpdate* arbitration);
  ::p4::v1::MasterArbitrationUpdate* unsafe_arena_release_arbitration();

  // .p4.v1.PacketIn packet = 2;
  bool has_packet() const;
  private:
  bool _internal_has_packet() const;
  public:
  void clear_packet();
  const ::p4::v1::PacketIn& packet() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::PacketIn* release_packet();
  ::p4::v1::PacketIn* mutable_packet();
  void set_allocated_packet(::p4::v1::PacketIn* packet);
  private:
  const ::p4::v1::PacketIn& _internal_packet() const;
  ::p4::v1::PacketIn* _internal_mutable_packet();
  public:
  void unsafe_arena_set_allocated_packet(
      ::p4::v1::PacketIn* packet);
  ::p4::v1::PacketIn* unsafe_arena_release_packet();

  // .p4.v1.DigestList digest = 3;
  bool has_digest() const;
  private:
  bool _internal_has_digest() const;
  public:
  void clear_digest();
  const ::p4::v1::DigestList& digest() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::DigestList* release_digest();
  ::p4::v1::DigestList* mutable_digest();
  void set_allocated_digest(::p4::v1::DigestList* digest);
  private:
  const ::p4::v1::DigestList& _internal_digest() const;
  ::p4::v1::DigestList* _internal_mutable_digest();
  public:
  void unsafe_arena_set_allocated_digest(
      ::p4::v1::DigestList* digest);
  ::p4::v1::DigestList* unsafe_arena_release_digest();

  // .p4.v1.IdleTimeoutNotification idle_timeout_notification = 4;
  bool has_idle_timeout_notification() const;
  private:
  bool _internal_has_idle_timeout_notification() const;
  public:
  void clear_idle_timeout_notification();
  const ::p4::v1::IdleTimeoutNotification& idle_timeout_notification() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::IdleTimeoutNotification* release_idle_timeout_notification();
  ::p4::v1::IdleTimeoutNotification* mutable_idle_timeout_notification();
  void set_allocated_idle_timeout_notification(::p4::v1::IdleTimeoutNotification* idle_timeout_notification);
  private:
  const ::p4::v1::IdleTimeoutNotification& _internal_idle_timeout_notification() const;
  ::p4::v1::IdleTimeoutNotification* _internal_mutable_idle_timeout_notification();
  public:
  void unsafe_arena_set_allocated_idle_timeout_notification(
      ::p4::v1::IdleTimeoutNotification* idle_timeout_notification);
  ::p4::v1::IdleTimeoutNotification* unsafe_arena_release_idle_timeout_notification();

  // .google.protobuf.Any other = 5;
  bool has_other() const;
  private:
  bool _internal_has_other() const;
  public:
  void clear_other();
  const ::PROTOBUF_NAMESPACE_ID::Any& other() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Any* release_other();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_other();
  void set_allocated_other(::PROTOBUF_NAMESPACE_ID::Any* other);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_other() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_other();
  public:
  void unsafe_arena_set_allocated_other(
      ::PROTOBUF_NAMESPACE_ID::Any* other);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_other();

  // .p4.v1.StreamError error = 6;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::p4::v1::StreamError& error() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::StreamError* release_error();
  ::p4::v1::StreamError* mutable_error();
  void set_allocated_error(::p4::v1::StreamError* error);
  private:
  const ::p4::v1::StreamError& _internal_error() const;
  ::p4::v1::StreamError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::p4::v1::StreamError* error);
  ::p4::v1::StreamError* unsafe_arena_release_error();

  void clear_update();
  UpdateCase update_case() const;
  // @@protoc_insertion_point(class_scope:p4.v1.StreamMessageResponse)
 private:
  class _Internal;
  void set_has_arbitration();
  void set_has_packet();
  void set_has_digest();
  void set_has_idle_timeout_notification();
  void set_has_other();
  void set_has_error();

  inline bool has_update() const;
  inline void clear_has_update();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union UpdateUnion {
    constexpr UpdateUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::p4::v1::MasterArbitrationUpdate* arbitration_;
    ::p4::v1::PacketIn* packet_;
    ::p4::v1::DigestList* digest_;
    ::p4::v1::IdleTimeoutNotification* idle_timeout_notification_;
    ::PROTOBUF_NAMESPACE_ID::Any* other_;
    ::p4::v1::StreamError* error_;
  } update_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class PacketIn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.PacketIn) */ {
 public:
  inline PacketIn() : PacketIn(nullptr) {}
  ~PacketIn() override;
  explicit constexpr PacketIn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PacketIn(const PacketIn& from);
  PacketIn(PacketIn&& from) noexcept
    : PacketIn() {
    *this = ::std::move(from);
  }

  inline PacketIn& operator=(const PacketIn& from) {
    CopyFrom(from);
    return *this;
  }
  inline PacketIn& operator=(PacketIn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PacketIn& default_instance() {
    return *internal_default_instance();
  }
  static inline const PacketIn* internal_default_instance() {
    return reinterpret_cast<const PacketIn*>(
               &_PacketIn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(PacketIn& a, PacketIn& b) {
    a.Swap(&b);
  }
  inline void Swap(PacketIn* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PacketIn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PacketIn* New() const final {
    return new PacketIn();
  }

  PacketIn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PacketIn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PacketIn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PacketIn& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PacketIn* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.PacketIn";
  }
  protected:
  explicit PacketIn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 2,
    kPayloadFieldNumber = 1,
  };
  // repeated .p4.v1.PacketMetadata metadata = 2;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  ::p4::v1::PacketMetadata* mutable_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::PacketMetadata >*
      mutable_metadata();
  private:
  const ::p4::v1::PacketMetadata& _internal_metadata(int index) const;
  ::p4::v1::PacketMetadata* _internal_add_metadata();
  public:
  const ::p4::v1::PacketMetadata& metadata(int index) const;
  ::p4::v1::PacketMetadata* add_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::PacketMetadata >&
      metadata() const;

  // bytes payload = 1;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_MUST_USE_RESULT std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.PacketIn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::PacketMetadata > metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class DigestList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.DigestList) */ {
 public:
  inline DigestList() : DigestList(nullptr) {}
  ~DigestList() override;
  explicit constexpr DigestList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DigestList(const DigestList& from);
  DigestList(DigestList&& from) noexcept
    : DigestList() {
    *this = ::std::move(from);
  }

  inline DigestList& operator=(const DigestList& from) {
    CopyFrom(from);
    return *this;
  }
  inline DigestList& operator=(DigestList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DigestList& default_instance() {
    return *internal_default_instance();
  }
  static inline const DigestList* internal_default_instance() {
    return reinterpret_cast<const DigestList*>(
               &_DigestList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(DigestList& a, DigestList& b) {
    a.Swap(&b);
  }
  inline void Swap(DigestList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DigestList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DigestList* New() const final {
    return new DigestList();
  }

  DigestList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DigestList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DigestList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DigestList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DigestList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.DigestList";
  }
  protected:
  explicit DigestList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kListIdFieldNumber = 2,
    kTimestampFieldNumber = 4,
    kDigestIdFieldNumber = 1,
  };
  // repeated .p4.v1.P4Data data = 3;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::p4::v1::P4Data* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::P4Data >*
      mutable_data();
  private:
  const ::p4::v1::P4Data& _internal_data(int index) const;
  ::p4::v1::P4Data* _internal_add_data();
  public:
  const ::p4::v1::P4Data& data(int index) const;
  ::p4::v1::P4Data* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::P4Data >&
      data() const;

  // uint64 list_id = 2;
  void clear_list_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 list_id() const;
  void set_list_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_list_id() const;
  void _internal_set_list_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // int64 timestamp = 4;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // uint32 digest_id = 1;
  void clear_digest_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 digest_id() const;
  void set_digest_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_digest_id() const;
  void _internal_set_digest_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.DigestList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::P4Data > data_;
  ::PROTOBUF_NAMESPACE_ID::uint64 list_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint32 digest_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class PacketMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.PacketMetadata) */ {
 public:
  inline PacketMetadata() : PacketMetadata(nullptr) {}
  ~PacketMetadata() override;
  explicit constexpr PacketMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PacketMetadata(const PacketMetadata& from);
  PacketMetadata(PacketMetadata&& from) noexcept
    : PacketMetadata() {
    *this = ::std::move(from);
  }

  inline PacketMetadata& operator=(const PacketMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline PacketMetadata& operator=(PacketMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PacketMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const PacketMetadata* internal_default_instance() {
    return reinterpret_cast<const PacketMetadata*>(
               &_PacketMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(PacketMetadata& a, PacketMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(PacketMetadata* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PacketMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PacketMetadata* New() const final {
    return new PacketMetadata();
  }

  PacketMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PacketMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PacketMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PacketMetadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PacketMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.PacketMetadata";
  }
  protected:
  explicit PacketMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kMetadataIdFieldNumber = 1,
  };
  // bytes value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // uint32 metadata_id = 1;
  void clear_metadata_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 metadata_id() const;
  void set_metadata_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_metadata_id() const;
  void _internal_set_metadata_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.PacketMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::uint32 metadata_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class MasterArbitrationUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.MasterArbitrationUpdate) */ {
 public:
  inline MasterArbitrationUpdate() : MasterArbitrationUpdate(nullptr) {}
  ~MasterArbitrationUpdate() override;
  explicit constexpr MasterArbitrationUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MasterArbitrationUpdate(const MasterArbitrationUpdate& from);
  MasterArbitrationUpdate(MasterArbitrationUpdate&& from) noexcept
    : MasterArbitrationUpdate() {
    *this = ::std::move(from);
  }

  inline MasterArbitrationUpdate& operator=(const MasterArbitrationUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline MasterArbitrationUpdate& operator=(MasterArbitrationUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MasterArbitrationUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const MasterArbitrationUpdate* internal_default_instance() {
    return reinterpret_cast<const MasterArbitrationUpdate*>(
               &_MasterArbitrationUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(MasterArbitrationUpdate& a, MasterArbitrationUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(MasterArbitrationUpdate* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MasterArbitrationUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MasterArbitrationUpdate* New() const final {
    return new MasterArbitrationUpdate();
  }

  MasterArbitrationUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MasterArbitrationUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MasterArbitrationUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MasterArbitrationUpdate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MasterArbitrationUpdate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.MasterArbitrationUpdate";
  }
  protected:
  explicit MasterArbitrationUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleFieldNumber = 2,
    kElectionIdFieldNumber = 3,
    kStatusFieldNumber = 4,
    kDeviceIdFieldNumber = 1,
  };
  // .p4.v1.Role role = 2;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  const ::p4::v1::Role& role() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::Role* release_role();
  ::p4::v1::Role* mutable_role();
  void set_allocated_role(::p4::v1::Role* role);
  private:
  const ::p4::v1::Role& _internal_role() const;
  ::p4::v1::Role* _internal_mutable_role();
  public:
  void unsafe_arena_set_allocated_role(
      ::p4::v1::Role* role);
  ::p4::v1::Role* unsafe_arena_release_role();

  // .p4.v1.Uint128 election_id = 3;
  bool has_election_id() const;
  private:
  bool _internal_has_election_id() const;
  public:
  void clear_election_id();
  const ::p4::v1::Uint128& election_id() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::Uint128* release_election_id();
  ::p4::v1::Uint128* mutable_election_id();
  void set_allocated_election_id(::p4::v1::Uint128* election_id);
  private:
  const ::p4::v1::Uint128& _internal_election_id() const;
  ::p4::v1::Uint128* _internal_mutable_election_id();
  public:
  void unsafe_arena_set_allocated_election_id(
      ::p4::v1::Uint128* election_id);
  ::p4::v1::Uint128* unsafe_arena_release_election_id();

  // .google.rpc.Status status = 4;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::google::rpc::Status& status() const;
  PROTOBUF_MUST_USE_RESULT ::google::rpc::Status* release_status();
  ::google::rpc::Status* mutable_status();
  void set_allocated_status(::google::rpc::Status* status);
  private:
  const ::google::rpc::Status& _internal_status() const;
  ::google::rpc::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::google::rpc::Status* status);
  ::google::rpc::Status* unsafe_arena_release_status();

  // uint64 device_id = 1;
  void clear_device_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 device_id() const;
  void set_device_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_device_id() const;
  void _internal_set_device_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.MasterArbitrationUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::p4::v1::Role* role_;
  ::p4::v1::Uint128* election_id_;
  ::google::rpc::Status* status_;
  ::PROTOBUF_NAMESPACE_ID::uint64 device_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class Role final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.Role) */ {
 public:
  inline Role() : Role(nullptr) {}
  ~Role() override;
  explicit constexpr Role(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Role(const Role& from);
  Role(Role&& from) noexcept
    : Role() {
    *this = ::std::move(from);
  }

  inline Role& operator=(const Role& from) {
    CopyFrom(from);
    return *this;
  }
  inline Role& operator=(Role&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Role& default_instance() {
    return *internal_default_instance();
  }
  static inline const Role* internal_default_instance() {
    return reinterpret_cast<const Role*>(
               &_Role_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(Role& a, Role& b) {
    a.Swap(&b);
  }
  inline void Swap(Role* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Role* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Role* New() const final {
    return new Role();
  }

  Role* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Role>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Role& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Role& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Role* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.Role";
  }
  protected:
  explicit Role(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // .google.protobuf.Any config = 2;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::PROTOBUF_NAMESPACE_ID::Any& config() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Any* release_config();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_config();
  void set_allocated_config(::PROTOBUF_NAMESPACE_ID::Any* config);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_config() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::PROTOBUF_NAMESPACE_ID::Any* config);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_config();

  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.Role)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Any* config_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class IdleTimeoutNotification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.IdleTimeoutNotification) */ {
 public:
  inline IdleTimeoutNotification() : IdleTimeoutNotification(nullptr) {}
  ~IdleTimeoutNotification() override;
  explicit constexpr IdleTimeoutNotification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IdleTimeoutNotification(const IdleTimeoutNotification& from);
  IdleTimeoutNotification(IdleTimeoutNotification&& from) noexcept
    : IdleTimeoutNotification() {
    *this = ::std::move(from);
  }

  inline IdleTimeoutNotification& operator=(const IdleTimeoutNotification& from) {
    CopyFrom(from);
    return *this;
  }
  inline IdleTimeoutNotification& operator=(IdleTimeoutNotification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IdleTimeoutNotification& default_instance() {
    return *internal_default_instance();
  }
  static inline const IdleTimeoutNotification* internal_default_instance() {
    return reinterpret_cast<const IdleTimeoutNotification*>(
               &_IdleTimeoutNotification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(IdleTimeoutNotification& a, IdleTimeoutNotification& b) {
    a.Swap(&b);
  }
  inline void Swap(IdleTimeoutNotification* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IdleTimeoutNotification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IdleTimeoutNotification* New() const final {
    return new IdleTimeoutNotification();
  }

  IdleTimeoutNotification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IdleTimeoutNotification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IdleTimeoutNotification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IdleTimeoutNotification& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IdleTimeoutNotification* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.IdleTimeoutNotification";
  }
  protected:
  explicit IdleTimeoutNotification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableEntryFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // repeated .p4.v1.TableEntry table_entry = 1;
  int table_entry_size() const;
  private:
  int _internal_table_entry_size() const;
  public:
  void clear_table_entry();
  ::p4::v1::TableEntry* mutable_table_entry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::TableEntry >*
      mutable_table_entry();
  private:
  const ::p4::v1::TableEntry& _internal_table_entry(int index) const;
  ::p4::v1::TableEntry* _internal_add_table_entry();
  public:
  const ::p4::v1::TableEntry& table_entry(int index) const;
  ::p4::v1::TableEntry* add_table_entry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::TableEntry >&
      table_entry() const;

  // int64 timestamp = 2;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.IdleTimeoutNotification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::TableEntry > table_entry_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class StreamError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.StreamError) */ {
 public:
  inline StreamError() : StreamError(nullptr) {}
  ~StreamError() override;
  explicit constexpr StreamError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamError(const StreamError& from);
  StreamError(StreamError&& from) noexcept
    : StreamError() {
    *this = ::std::move(from);
  }

  inline StreamError& operator=(const StreamError& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamError& operator=(StreamError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamError& default_instance() {
    return *internal_default_instance();
  }
  enum DetailsCase {
    kPacketOut = 5,
    kDigestListAck = 6,
    kOther = 7,
    DETAILS_NOT_SET = 0,
  };

  static inline const StreamError* internal_default_instance() {
    return reinterpret_cast<const StreamError*>(
               &_StreamError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(StreamError& a, StreamError& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamError* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamError* New() const final {
    return new StreamError();
  }

  StreamError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StreamError& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.StreamError";
  }
  protected:
  explicit StreamError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSpaceFieldNumber = 3,
    kCanonicalCodeFieldNumber = 1,
    kCodeFieldNumber = 4,
    kPacketOutFieldNumber = 5,
    kDigestListAckFieldNumber = 6,
    kOtherFieldNumber = 7,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string space = 3;
  void clear_space();
  const std::string& space() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_space(ArgT0&& arg0, ArgT... args);
  std::string* mutable_space();
  PROTOBUF_MUST_USE_RESULT std::string* release_space();
  void set_allocated_space(std::string* space);
  private:
  const std::string& _internal_space() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_space(const std::string& value);
  std::string* _internal_mutable_space();
  public:

  // int32 canonical_code = 1;
  void clear_canonical_code();
  ::PROTOBUF_NAMESPACE_ID::int32 canonical_code() const;
  void set_canonical_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_canonical_code() const;
  void _internal_set_canonical_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 code = 4;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .p4.v1.PacketOutError packet_out = 5;
  bool has_packet_out() const;
  private:
  bool _internal_has_packet_out() const;
  public:
  void clear_packet_out();
  const ::p4::v1::PacketOutError& packet_out() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::PacketOutError* release_packet_out();
  ::p4::v1::PacketOutError* mutable_packet_out();
  void set_allocated_packet_out(::p4::v1::PacketOutError* packet_out);
  private:
  const ::p4::v1::PacketOutError& _internal_packet_out() const;
  ::p4::v1::PacketOutError* _internal_mutable_packet_out();
  public:
  void unsafe_arena_set_allocated_packet_out(
      ::p4::v1::PacketOutError* packet_out);
  ::p4::v1::PacketOutError* unsafe_arena_release_packet_out();

  // .p4.v1.DigestListAckError digest_list_ack = 6;
  bool has_digest_list_ack() const;
  private:
  bool _internal_has_digest_list_ack() const;
  public:
  void clear_digest_list_ack();
  const ::p4::v1::DigestListAckError& digest_list_ack() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::DigestListAckError* release_digest_list_ack();
  ::p4::v1::DigestListAckError* mutable_digest_list_ack();
  void set_allocated_digest_list_ack(::p4::v1::DigestListAckError* digest_list_ack);
  private:
  const ::p4::v1::DigestListAckError& _internal_digest_list_ack() const;
  ::p4::v1::DigestListAckError* _internal_mutable_digest_list_ack();
  public:
  void unsafe_arena_set_allocated_digest_list_ack(
      ::p4::v1::DigestListAckError* digest_list_ack);
  ::p4::v1::DigestListAckError* unsafe_arena_release_digest_list_ack();

  // .p4.v1.StreamOtherError other = 7;
  bool has_other() const;
  private:
  bool _internal_has_other() const;
  public:
  void clear_other();
  const ::p4::v1::StreamOtherError& other() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::StreamOtherError* release_other();
  ::p4::v1::StreamOtherError* mutable_other();
  void set_allocated_other(::p4::v1::StreamOtherError* other);
  private:
  const ::p4::v1::StreamOtherError& _internal_other() const;
  ::p4::v1::StreamOtherError* _internal_mutable_other();
  public:
  void unsafe_arena_set_allocated_other(
      ::p4::v1::StreamOtherError* other);
  ::p4::v1::StreamOtherError* unsafe_arena_release_other();

  void clear_details();
  DetailsCase details_case() const;
  // @@protoc_insertion_point(class_scope:p4.v1.StreamError)
 private:
  class _Internal;
  void set_has_packet_out();
  void set_has_digest_list_ack();
  void set_has_other();

  inline bool has_details() const;
  inline void clear_has_details();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr space_;
  ::PROTOBUF_NAMESPACE_ID::int32 canonical_code_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  union DetailsUnion {
    constexpr DetailsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::p4::v1::PacketOutError* packet_out_;
    ::p4::v1::DigestListAckError* digest_list_ack_;
    ::p4::v1::StreamOtherError* other_;
  } details_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class PacketOutError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.PacketOutError) */ {
 public:
  inline PacketOutError() : PacketOutError(nullptr) {}
  ~PacketOutError() override;
  explicit constexpr PacketOutError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PacketOutError(const PacketOutError& from);
  PacketOutError(PacketOutError&& from) noexcept
    : PacketOutError() {
    *this = ::std::move(from);
  }

  inline PacketOutError& operator=(const PacketOutError& from) {
    CopyFrom(from);
    return *this;
  }
  inline PacketOutError& operator=(PacketOutError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PacketOutError& default_instance() {
    return *internal_default_instance();
  }
  static inline const PacketOutError* internal_default_instance() {
    return reinterpret_cast<const PacketOutError*>(
               &_PacketOutError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(PacketOutError& a, PacketOutError& b) {
    a.Swap(&b);
  }
  inline void Swap(PacketOutError* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PacketOutError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PacketOutError* New() const final {
    return new PacketOutError();
  }

  PacketOutError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PacketOutError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PacketOutError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PacketOutError& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PacketOutError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.PacketOutError";
  }
  protected:
  explicit PacketOutError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPacketOutFieldNumber = 1,
  };
  // .p4.v1.PacketOut packet_out = 1;
  bool has_packet_out() const;
  private:
  bool _internal_has_packet_out() const;
  public:
  void clear_packet_out();
  const ::p4::v1::PacketOut& packet_out() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::PacketOut* release_packet_out();
  ::p4::v1::PacketOut* mutable_packet_out();
  void set_allocated_packet_out(::p4::v1::PacketOut* packet_out);
  private:
  const ::p4::v1::PacketOut& _internal_packet_out() const;
  ::p4::v1::PacketOut* _internal_mutable_packet_out();
  public:
  void unsafe_arena_set_allocated_packet_out(
      ::p4::v1::PacketOut* packet_out);
  ::p4::v1::PacketOut* unsafe_arena_release_packet_out();

  // @@protoc_insertion_point(class_scope:p4.v1.PacketOutError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::p4::v1::PacketOut* packet_out_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class DigestListAckError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.DigestListAckError) */ {
 public:
  inline DigestListAckError() : DigestListAckError(nullptr) {}
  ~DigestListAckError() override;
  explicit constexpr DigestListAckError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DigestListAckError(const DigestListAckError& from);
  DigestListAckError(DigestListAckError&& from) noexcept
    : DigestListAckError() {
    *this = ::std::move(from);
  }

  inline DigestListAckError& operator=(const DigestListAckError& from) {
    CopyFrom(from);
    return *this;
  }
  inline DigestListAckError& operator=(DigestListAckError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DigestListAckError& default_instance() {
    return *internal_default_instance();
  }
  static inline const DigestListAckError* internal_default_instance() {
    return reinterpret_cast<const DigestListAckError*>(
               &_DigestListAckError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(DigestListAckError& a, DigestListAckError& b) {
    a.Swap(&b);
  }
  inline void Swap(DigestListAckError* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DigestListAckError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DigestListAckError* New() const final {
    return new DigestListAckError();
  }

  DigestListAckError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DigestListAckError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DigestListAckError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DigestListAckError& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DigestListAckError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.DigestListAckError";
  }
  protected:
  explicit DigestListAckError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDigestListAckFieldNumber = 1,
  };
  // .p4.v1.DigestListAck digest_list_ack = 1;
  bool has_digest_list_ack() const;
  private:
  bool _internal_has_digest_list_ack() const;
  public:
  void clear_digest_list_ack();
  const ::p4::v1::DigestListAck& digest_list_ack() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::DigestListAck* release_digest_list_ack();
  ::p4::v1::DigestListAck* mutable_digest_list_ack();
  void set_allocated_digest_list_ack(::p4::v1::DigestListAck* digest_list_ack);
  private:
  const ::p4::v1::DigestListAck& _internal_digest_list_ack() const;
  ::p4::v1::DigestListAck* _internal_mutable_digest_list_ack();
  public:
  void unsafe_arena_set_allocated_digest_list_ack(
      ::p4::v1::DigestListAck* digest_list_ack);
  ::p4::v1::DigestListAck* unsafe_arena_release_digest_list_ack();

  // @@protoc_insertion_point(class_scope:p4.v1.DigestListAckError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::p4::v1::DigestListAck* digest_list_ack_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class StreamOtherError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.StreamOtherError) */ {
 public:
  inline StreamOtherError() : StreamOtherError(nullptr) {}
  ~StreamOtherError() override;
  explicit constexpr StreamOtherError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOtherError(const StreamOtherError& from);
  StreamOtherError(StreamOtherError&& from) noexcept
    : StreamOtherError() {
    *this = ::std::move(from);
  }

  inline StreamOtherError& operator=(const StreamOtherError& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOtherError& operator=(StreamOtherError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOtherError& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOtherError* internal_default_instance() {
    return reinterpret_cast<const StreamOtherError*>(
               &_StreamOtherError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(StreamOtherError& a, StreamOtherError& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOtherError* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOtherError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamOtherError* New() const final {
    return new StreamOtherError();
  }

  StreamOtherError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamOtherError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOtherError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StreamOtherError& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOtherError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.StreamOtherError";
  }
  protected:
  explicit StreamOtherError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOtherFieldNumber = 1,
  };
  // .google.protobuf.Any other = 1;
  bool has_other() const;
  private:
  bool _internal_has_other() const;
  public:
  void clear_other();
  const ::PROTOBUF_NAMESPACE_ID::Any& other() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Any* release_other();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_other();
  void set_allocated_other(::PROTOBUF_NAMESPACE_ID::Any* other);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_other() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_other();
  public:
  void unsafe_arena_set_allocated_other(
      ::PROTOBUF_NAMESPACE_ID::Any* other);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_other();

  // @@protoc_insertion_point(class_scope:p4.v1.StreamOtherError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Any* other_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class Uint128 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.Uint128) */ {
 public:
  inline Uint128() : Uint128(nullptr) {}
  ~Uint128() override;
  explicit constexpr Uint128(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Uint128(const Uint128& from);
  Uint128(Uint128&& from) noexcept
    : Uint128() {
    *this = ::std::move(from);
  }

  inline Uint128& operator=(const Uint128& from) {
    CopyFrom(from);
    return *this;
  }
  inline Uint128& operator=(Uint128&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Uint128& default_instance() {
    return *internal_default_instance();
  }
  static inline const Uint128* internal_default_instance() {
    return reinterpret_cast<const Uint128*>(
               &_Uint128_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(Uint128& a, Uint128& b) {
    a.Swap(&b);
  }
  inline void Swap(Uint128* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Uint128* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Uint128* New() const final {
    return new Uint128();
  }

  Uint128* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Uint128>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Uint128& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Uint128& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Uint128* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.Uint128";
  }
  protected:
  explicit Uint128(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHighFieldNumber = 1,
    kLowFieldNumber = 2,
  };
  // uint64 high = 1;
  void clear_high();
  ::PROTOBUF_NAMESPACE_ID::uint64 high() const;
  void set_high(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_high() const;
  void _internal_set_high(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 low = 2;
  void clear_low();
  ::PROTOBUF_NAMESPACE_ID::uint64 low() const;
  void set_low(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_low() const;
  void _internal_set_low(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.Uint128)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 high_;
  ::PROTOBUF_NAMESPACE_ID::uint64 low_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class SetForwardingPipelineConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.SetForwardingPipelineConfigRequest) */ {
 public:
  inline SetForwardingPipelineConfigRequest() : SetForwardingPipelineConfigRequest(nullptr) {}
  ~SetForwardingPipelineConfigRequest() override;
  explicit constexpr SetForwardingPipelineConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetForwardingPipelineConfigRequest(const SetForwardingPipelineConfigRequest& from);
  SetForwardingPipelineConfigRequest(SetForwardingPipelineConfigRequest&& from) noexcept
    : SetForwardingPipelineConfigRequest() {
    *this = ::std::move(from);
  }

  inline SetForwardingPipelineConfigRequest& operator=(const SetForwardingPipelineConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetForwardingPipelineConfigRequest& operator=(SetForwardingPipelineConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetForwardingPipelineConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetForwardingPipelineConfigRequest* internal_default_instance() {
    return reinterpret_cast<const SetForwardingPipelineConfigRequest*>(
               &_SetForwardingPipelineConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(SetForwardingPipelineConfigRequest& a, SetForwardingPipelineConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetForwardingPipelineConfigRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetForwardingPipelineConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetForwardingPipelineConfigRequest* New() const final {
    return new SetForwardingPipelineConfigRequest();
  }

  SetForwardingPipelineConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetForwardingPipelineConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetForwardingPipelineConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetForwardingPipelineConfigRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetForwardingPipelineConfigRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.SetForwardingPipelineConfigRequest";
  }
  protected:
  explicit SetForwardingPipelineConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SetForwardingPipelineConfigRequest_Action Action;
  static constexpr Action UNSPECIFIED =
    SetForwardingPipelineConfigRequest_Action_UNSPECIFIED;
  static constexpr Action VERIFY =
    SetForwardingPipelineConfigRequest_Action_VERIFY;
  static constexpr Action VERIFY_AND_SAVE =
    SetForwardingPipelineConfigRequest_Action_VERIFY_AND_SAVE;
  static constexpr Action VERIFY_AND_COMMIT =
    SetForwardingPipelineConfigRequest_Action_VERIFY_AND_COMMIT;
  static constexpr Action COMMIT =
    SetForwardingPipelineConfigRequest_Action_COMMIT;
  static constexpr Action RECONCILE_AND_COMMIT =
    SetForwardingPipelineConfigRequest_Action_RECONCILE_AND_COMMIT;
  static inline bool Action_IsValid(int value) {
    return SetForwardingPipelineConfigRequest_Action_IsValid(value);
  }
  static constexpr Action Action_MIN =
    SetForwardingPipelineConfigRequest_Action_Action_MIN;
  static constexpr Action Action_MAX =
    SetForwardingPipelineConfigRequest_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE =
    SetForwardingPipelineConfigRequest_Action_Action_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Action_descriptor() {
    return SetForwardingPipelineConfigRequest_Action_descriptor();
  }
  template<typename T>
  static inline const std::string& Action_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Action>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Action_Name.");
    return SetForwardingPipelineConfigRequest_Action_Name(enum_t_value);
  }
  static inline bool Action_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Action* value) {
    return SetForwardingPipelineConfigRequest_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kElectionIdFieldNumber = 3,
    kConfigFieldNumber = 5,
    kDeviceIdFieldNumber = 1,
    kRoleIdFieldNumber = 2,
    kActionFieldNumber = 4,
  };
  // .p4.v1.Uint128 election_id = 3;
  bool has_election_id() const;
  private:
  bool _internal_has_election_id() const;
  public:
  void clear_election_id();
  const ::p4::v1::Uint128& election_id() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::Uint128* release_election_id();
  ::p4::v1::Uint128* mutable_election_id();
  void set_allocated_election_id(::p4::v1::Uint128* election_id);
  private:
  const ::p4::v1::Uint128& _internal_election_id() const;
  ::p4::v1::Uint128* _internal_mutable_election_id();
  public:
  void unsafe_arena_set_allocated_election_id(
      ::p4::v1::Uint128* election_id);
  ::p4::v1::Uint128* unsafe_arena_release_election_id();

  // .p4.v1.ForwardingPipelineConfig config = 5;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::p4::v1::ForwardingPipelineConfig& config() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::ForwardingPipelineConfig* release_config();
  ::p4::v1::ForwardingPipelineConfig* mutable_config();
  void set_allocated_config(::p4::v1::ForwardingPipelineConfig* config);
  private:
  const ::p4::v1::ForwardingPipelineConfig& _internal_config() const;
  ::p4::v1::ForwardingPipelineConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::p4::v1::ForwardingPipelineConfig* config);
  ::p4::v1::ForwardingPipelineConfig* unsafe_arena_release_config();

  // uint64 device_id = 1;
  void clear_device_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 device_id() const;
  void set_device_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_device_id() const;
  void _internal_set_device_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 role_id = 2;
  void clear_role_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 role_id() const;
  void set_role_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_role_id() const;
  void _internal_set_role_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .p4.v1.SetForwardingPipelineConfigRequest.Action action = 4;
  void clear_action();
  ::p4::v1::SetForwardingPipelineConfigRequest_Action action() const;
  void set_action(::p4::v1::SetForwardingPipelineConfigRequest_Action value);
  private:
  ::p4::v1::SetForwardingPipelineConfigRequest_Action _internal_action() const;
  void _internal_set_action(::p4::v1::SetForwardingPipelineConfigRequest_Action value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.SetForwardingPipelineConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::p4::v1::Uint128* election_id_;
  ::p4::v1::ForwardingPipelineConfig* config_;
  ::PROTOBUF_NAMESPACE_ID::uint64 device_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 role_id_;
  int action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class SetForwardingPipelineConfigResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:p4.v1.SetForwardingPipelineConfigResponse) */ {
 public:
  inline SetForwardingPipelineConfigResponse() : SetForwardingPipelineConfigResponse(nullptr) {}
  explicit constexpr SetForwardingPipelineConfigResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetForwardingPipelineConfigResponse(const SetForwardingPipelineConfigResponse& from);
  SetForwardingPipelineConfigResponse(SetForwardingPipelineConfigResponse&& from) noexcept
    : SetForwardingPipelineConfigResponse() {
    *this = ::std::move(from);
  }

  inline SetForwardingPipelineConfigResponse& operator=(const SetForwardingPipelineConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetForwardingPipelineConfigResponse& operator=(SetForwardingPipelineConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetForwardingPipelineConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetForwardingPipelineConfigResponse* internal_default_instance() {
    return reinterpret_cast<const SetForwardingPipelineConfigResponse*>(
               &_SetForwardingPipelineConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(SetForwardingPipelineConfigResponse& a, SetForwardingPipelineConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetForwardingPipelineConfigResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetForwardingPipelineConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetForwardingPipelineConfigResponse* New() const final {
    return new SetForwardingPipelineConfigResponse();
  }

  SetForwardingPipelineConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetForwardingPipelineConfigResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetForwardingPipelineConfigResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetForwardingPipelineConfigResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.SetForwardingPipelineConfigResponse";
  }
  protected:
  explicit SetForwardingPipelineConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:p4.v1.SetForwardingPipelineConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class ForwardingPipelineConfig_Cookie final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.ForwardingPipelineConfig.Cookie) */ {
 public:
  inline ForwardingPipelineConfig_Cookie() : ForwardingPipelineConfig_Cookie(nullptr) {}
  ~ForwardingPipelineConfig_Cookie() override;
  explicit constexpr ForwardingPipelineConfig_Cookie(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForwardingPipelineConfig_Cookie(const ForwardingPipelineConfig_Cookie& from);
  ForwardingPipelineConfig_Cookie(ForwardingPipelineConfig_Cookie&& from) noexcept
    : ForwardingPipelineConfig_Cookie() {
    *this = ::std::move(from);
  }

  inline ForwardingPipelineConfig_Cookie& operator=(const ForwardingPipelineConfig_Cookie& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForwardingPipelineConfig_Cookie& operator=(ForwardingPipelineConfig_Cookie&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForwardingPipelineConfig_Cookie& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForwardingPipelineConfig_Cookie* internal_default_instance() {
    return reinterpret_cast<const ForwardingPipelineConfig_Cookie*>(
               &_ForwardingPipelineConfig_Cookie_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(ForwardingPipelineConfig_Cookie& a, ForwardingPipelineConfig_Cookie& b) {
    a.Swap(&b);
  }
  inline void Swap(ForwardingPipelineConfig_Cookie* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForwardingPipelineConfig_Cookie* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ForwardingPipelineConfig_Cookie* New() const final {
    return new ForwardingPipelineConfig_Cookie();
  }

  ForwardingPipelineConfig_Cookie* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ForwardingPipelineConfig_Cookie>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForwardingPipelineConfig_Cookie& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ForwardingPipelineConfig_Cookie& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForwardingPipelineConfig_Cookie* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.ForwardingPipelineConfig.Cookie";
  }
  protected:
  explicit ForwardingPipelineConfig_Cookie(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCookieFieldNumber = 1,
  };
  // uint64 cookie = 1;
  void clear_cookie();
  ::PROTOBUF_NAMESPACE_ID::uint64 cookie() const;
  void set_cookie(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_cookie() const;
  void _internal_set_cookie(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.ForwardingPipelineConfig.Cookie)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 cookie_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class ForwardingPipelineConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.ForwardingPipelineConfig) */ {
 public:
  inline ForwardingPipelineConfig() : ForwardingPipelineConfig(nullptr) {}
  ~ForwardingPipelineConfig() override;
  explicit constexpr ForwardingPipelineConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForwardingPipelineConfig(const ForwardingPipelineConfig& from);
  ForwardingPipelineConfig(ForwardingPipelineConfig&& from) noexcept
    : ForwardingPipelineConfig() {
    *this = ::std::move(from);
  }

  inline ForwardingPipelineConfig& operator=(const ForwardingPipelineConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForwardingPipelineConfig& operator=(ForwardingPipelineConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForwardingPipelineConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForwardingPipelineConfig* internal_default_instance() {
    return reinterpret_cast<const ForwardingPipelineConfig*>(
               &_ForwardingPipelineConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(ForwardingPipelineConfig& a, ForwardingPipelineConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ForwardingPipelineConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForwardingPipelineConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ForwardingPipelineConfig* New() const final {
    return new ForwardingPipelineConfig();
  }

  ForwardingPipelineConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ForwardingPipelineConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForwardingPipelineConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ForwardingPipelineConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForwardingPipelineConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.ForwardingPipelineConfig";
  }
  protected:
  explicit ForwardingPipelineConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ForwardingPipelineConfig_Cookie Cookie;

  // accessors -------------------------------------------------------

  enum : int {
    kP4DeviceConfigFieldNumber = 2,
    kP4InfoFieldNumber = 1,
    kCookieFieldNumber = 3,
  };
  // bytes p4_device_config = 2;
  void clear_p4_device_config();
  const std::string& p4_device_config() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_p4_device_config(ArgT0&& arg0, ArgT... args);
  std::string* mutable_p4_device_config();
  PROTOBUF_MUST_USE_RESULT std::string* release_p4_device_config();
  void set_allocated_p4_device_config(std::string* p4_device_config);
  private:
  const std::string& _internal_p4_device_config() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_p4_device_config(const std::string& value);
  std::string* _internal_mutable_p4_device_config();
  public:

  // .p4.config.v1.P4Info p4info = 1;
  bool has_p4info() const;
  private:
  bool _internal_has_p4info() const;
  public:
  void clear_p4info();
  const ::p4::config::v1::P4Info& p4info() const;
  PROTOBUF_MUST_USE_RESULT ::p4::config::v1::P4Info* release_p4info();
  ::p4::config::v1::P4Info* mutable_p4info();
  void set_allocated_p4info(::p4::config::v1::P4Info* p4info);
  private:
  const ::p4::config::v1::P4Info& _internal_p4info() const;
  ::p4::config::v1::P4Info* _internal_mutable_p4info();
  public:
  void unsafe_arena_set_allocated_p4info(
      ::p4::config::v1::P4Info* p4info);
  ::p4::config::v1::P4Info* unsafe_arena_release_p4info();

  // .p4.v1.ForwardingPipelineConfig.Cookie cookie = 3;
  bool has_cookie() const;
  private:
  bool _internal_has_cookie() const;
  public:
  void clear_cookie();
  const ::p4::v1::ForwardingPipelineConfig_Cookie& cookie() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::ForwardingPipelineConfig_Cookie* release_cookie();
  ::p4::v1::ForwardingPipelineConfig_Cookie* mutable_cookie();
  void set_allocated_cookie(::p4::v1::ForwardingPipelineConfig_Cookie* cookie);
  private:
  const ::p4::v1::ForwardingPipelineConfig_Cookie& _internal_cookie() const;
  ::p4::v1::ForwardingPipelineConfig_Cookie* _internal_mutable_cookie();
  public:
  void unsafe_arena_set_allocated_cookie(
      ::p4::v1::ForwardingPipelineConfig_Cookie* cookie);
  ::p4::v1::ForwardingPipelineConfig_Cookie* unsafe_arena_release_cookie();

  // @@protoc_insertion_point(class_scope:p4.v1.ForwardingPipelineConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr p4_device_config_;
  ::p4::config::v1::P4Info* p4info_;
  ::p4::v1::ForwardingPipelineConfig_Cookie* cookie_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class GetForwardingPipelineConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.GetForwardingPipelineConfigRequest) */ {
 public:
  inline GetForwardingPipelineConfigRequest() : GetForwardingPipelineConfigRequest(nullptr) {}
  ~GetForwardingPipelineConfigRequest() override;
  explicit constexpr GetForwardingPipelineConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetForwardingPipelineConfigRequest(const GetForwardingPipelineConfigRequest& from);
  GetForwardingPipelineConfigRequest(GetForwardingPipelineConfigRequest&& from) noexcept
    : GetForwardingPipelineConfigRequest() {
    *this = ::std::move(from);
  }

  inline GetForwardingPipelineConfigRequest& operator=(const GetForwardingPipelineConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetForwardingPipelineConfigRequest& operator=(GetForwardingPipelineConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetForwardingPipelineConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetForwardingPipelineConfigRequest* internal_default_instance() {
    return reinterpret_cast<const GetForwardingPipelineConfigRequest*>(
               &_GetForwardingPipelineConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(GetForwardingPipelineConfigRequest& a, GetForwardingPipelineConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetForwardingPipelineConfigRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetForwardingPipelineConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetForwardingPipelineConfigRequest* New() const final {
    return new GetForwardingPipelineConfigRequest();
  }

  GetForwardingPipelineConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetForwardingPipelineConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetForwardingPipelineConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetForwardingPipelineConfigRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetForwardingPipelineConfigRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.GetForwardingPipelineConfigRequest";
  }
  protected:
  explicit GetForwardingPipelineConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetForwardingPipelineConfigRequest_ResponseType ResponseType;
  static constexpr ResponseType ALL =
    GetForwardingPipelineConfigRequest_ResponseType_ALL;
  static constexpr ResponseType COOKIE_ONLY =
    GetForwardingPipelineConfigRequest_ResponseType_COOKIE_ONLY;
  static constexpr ResponseType P4INFO_AND_COOKIE =
    GetForwardingPipelineConfigRequest_ResponseType_P4INFO_AND_COOKIE;
  static constexpr ResponseType DEVICE_CONFIG_AND_COOKIE =
    GetForwardingPipelineConfigRequest_ResponseType_DEVICE_CONFIG_AND_COOKIE;
  static inline bool ResponseType_IsValid(int value) {
    return GetForwardingPipelineConfigRequest_ResponseType_IsValid(value);
  }
  static constexpr ResponseType ResponseType_MIN =
    GetForwardingPipelineConfigRequest_ResponseType_ResponseType_MIN;
  static constexpr ResponseType ResponseType_MAX =
    GetForwardingPipelineConfigRequest_ResponseType_ResponseType_MAX;
  static constexpr int ResponseType_ARRAYSIZE =
    GetForwardingPipelineConfigRequest_ResponseType_ResponseType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ResponseType_descriptor() {
    return GetForwardingPipelineConfigRequest_ResponseType_descriptor();
  }
  template<typename T>
  static inline const std::string& ResponseType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ResponseType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ResponseType_Name.");
    return GetForwardingPipelineConfigRequest_ResponseType_Name(enum_t_value);
  }
  static inline bool ResponseType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ResponseType* value) {
    return GetForwardingPipelineConfigRequest_ResponseType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceIdFieldNumber = 1,
    kResponseTypeFieldNumber = 2,
  };
  // uint64 device_id = 1;
  void clear_device_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 device_id() const;
  void set_device_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_device_id() const;
  void _internal_set_device_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .p4.v1.GetForwardingPipelineConfigRequest.ResponseType response_type = 2;
  void clear_response_type();
  ::p4::v1::GetForwardingPipelineConfigRequest_ResponseType response_type() const;
  void set_response_type(::p4::v1::GetForwardingPipelineConfigRequest_ResponseType value);
  private:
  ::p4::v1::GetForwardingPipelineConfigRequest_ResponseType _internal_response_type() const;
  void _internal_set_response_type(::p4::v1::GetForwardingPipelineConfigRequest_ResponseType value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.GetForwardingPipelineConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 device_id_;
  int response_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class GetForwardingPipelineConfigResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.GetForwardingPipelineConfigResponse) */ {
 public:
  inline GetForwardingPipelineConfigResponse() : GetForwardingPipelineConfigResponse(nullptr) {}
  ~GetForwardingPipelineConfigResponse() override;
  explicit constexpr GetForwardingPipelineConfigResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetForwardingPipelineConfigResponse(const GetForwardingPipelineConfigResponse& from);
  GetForwardingPipelineConfigResponse(GetForwardingPipelineConfigResponse&& from) noexcept
    : GetForwardingPipelineConfigResponse() {
    *this = ::std::move(from);
  }

  inline GetForwardingPipelineConfigResponse& operator=(const GetForwardingPipelineConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetForwardingPipelineConfigResponse& operator=(GetForwardingPipelineConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetForwardingPipelineConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetForwardingPipelineConfigResponse* internal_default_instance() {
    return reinterpret_cast<const GetForwardingPipelineConfigResponse*>(
               &_GetForwardingPipelineConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(GetForwardingPipelineConfigResponse& a, GetForwardingPipelineConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetForwardingPipelineConfigResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetForwardingPipelineConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetForwardingPipelineConfigResponse* New() const final {
    return new GetForwardingPipelineConfigResponse();
  }

  GetForwardingPipelineConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetForwardingPipelineConfigResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetForwardingPipelineConfigResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetForwardingPipelineConfigResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetForwardingPipelineConfigResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.GetForwardingPipelineConfigResponse";
  }
  protected:
  explicit GetForwardingPipelineConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
  };
  // .p4.v1.ForwardingPipelineConfig config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::p4::v1::ForwardingPipelineConfig& config() const;
  PROTOBUF_MUST_USE_RESULT ::p4::v1::ForwardingPipelineConfig* release_config();
  ::p4::v1::ForwardingPipelineConfig* mutable_config();
  void set_allocated_config(::p4::v1::ForwardingPipelineConfig* config);
  private:
  const ::p4::v1::ForwardingPipelineConfig& _internal_config() const;
  ::p4::v1::ForwardingPipelineConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::p4::v1::ForwardingPipelineConfig* config);
  ::p4::v1::ForwardingPipelineConfig* unsafe_arena_release_config();

  // @@protoc_insertion_point(class_scope:p4.v1.GetForwardingPipelineConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::p4::v1::ForwardingPipelineConfig* config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.Error) */ {
 public:
  inline Error() : Error(nullptr) {}
  ~Error() override;
  explicit constexpr Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Error(const Error& from);
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }
  inline void Swap(Error* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const final {
    return new Error();
  }

  Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Error& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Error& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.Error";
  }
  protected:
  explicit Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSpaceFieldNumber = 3,
    kDetailsFieldNumber = 5,
    kCanonicalCodeFieldNumber = 1,
    kCodeFieldNumber = 4,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string space = 3;
  void clear_space();
  const std::string& space() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_space(ArgT0&& arg0, ArgT... args);
  std::string* mutable_space();
  PROTOBUF_MUST_USE_RESULT std::string* release_space();
  void set_allocated_space(std::string* space);
  private:
  const std::string& _internal_space() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_space(const std::string& value);
  std::string* _internal_mutable_space();
  public:

  // .google.protobuf.Any details = 5;
  bool has_details() const;
  private:
  bool _internal_has_details() const;
  public:
  void clear_details();
  const ::PROTOBUF_NAMESPACE_ID::Any& details() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Any* release_details();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_details();
  void set_allocated_details(::PROTOBUF_NAMESPACE_ID::Any* details);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_details() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_details();
  public:
  void unsafe_arena_set_allocated_details(
      ::PROTOBUF_NAMESPACE_ID::Any* details);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_details();

  // int32 canonical_code = 1;
  void clear_canonical_code();
  ::PROTOBUF_NAMESPACE_ID::int32 canonical_code() const;
  void set_canonical_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_canonical_code() const;
  void _internal_set_canonical_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 code = 4;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr space_;
  ::PROTOBUF_NAMESPACE_ID::Any* details_;
  ::PROTOBUF_NAMESPACE_ID::int32 canonical_code_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class CapabilitiesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:p4.v1.CapabilitiesRequest) */ {
 public:
  inline CapabilitiesRequest() : CapabilitiesRequest(nullptr) {}
  explicit constexpr CapabilitiesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CapabilitiesRequest(const CapabilitiesRequest& from);
  CapabilitiesRequest(CapabilitiesRequest&& from) noexcept
    : CapabilitiesRequest() {
    *this = ::std::move(from);
  }

  inline CapabilitiesRequest& operator=(const CapabilitiesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapabilitiesRequest& operator=(CapabilitiesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapabilitiesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CapabilitiesRequest* internal_default_instance() {
    return reinterpret_cast<const CapabilitiesRequest*>(
               &_CapabilitiesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(CapabilitiesRequest& a, CapabilitiesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CapabilitiesRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapabilitiesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CapabilitiesRequest* New() const final {
    return new CapabilitiesRequest();
  }

  CapabilitiesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CapabilitiesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CapabilitiesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CapabilitiesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.CapabilitiesRequest";
  }
  protected:
  explicit CapabilitiesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:p4.v1.CapabilitiesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// -------------------------------------------------------------------

class CapabilitiesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p4.v1.CapabilitiesResponse) */ {
 public:
  inline CapabilitiesResponse() : CapabilitiesResponse(nullptr) {}
  ~CapabilitiesResponse() override;
  explicit constexpr CapabilitiesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CapabilitiesResponse(const CapabilitiesResponse& from);
  CapabilitiesResponse(CapabilitiesResponse&& from) noexcept
    : CapabilitiesResponse() {
    *this = ::std::move(from);
  }

  inline CapabilitiesResponse& operator=(const CapabilitiesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapabilitiesResponse& operator=(CapabilitiesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapabilitiesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CapabilitiesResponse* internal_default_instance() {
    return reinterpret_cast<const CapabilitiesResponse*>(
               &_CapabilitiesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(CapabilitiesResponse& a, CapabilitiesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CapabilitiesResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapabilitiesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CapabilitiesResponse* New() const final {
    return new CapabilitiesResponse();
  }

  CapabilitiesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CapabilitiesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CapabilitiesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CapabilitiesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CapabilitiesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p4.v1.CapabilitiesResponse";
  }
  protected:
  explicit CapabilitiesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kP4RuntimeApiVersionFieldNumber = 1,
  };
  // string p4runtime_api_version = 1;
  void clear_p4runtime_api_version();
  const std::string& p4runtime_api_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_p4runtime_api_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_p4runtime_api_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_p4runtime_api_version();
  void set_allocated_p4runtime_api_version(std::string* p4runtime_api_version);
  private:
  const std::string& _internal_p4runtime_api_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_p4runtime_api_version(const std::string& value);
  std::string* _internal_mutable_p4runtime_api_version();
  public:

  // @@protoc_insertion_point(class_scope:p4.v1.CapabilitiesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr p4runtime_api_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_p4_2fv1_2fp4runtime_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// WriteRequest

// uint64 device_id = 1;
inline void WriteRequest::clear_device_id() {
  device_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WriteRequest::_internal_device_id() const {
  return device_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WriteRequest::device_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.WriteRequest.device_id)
  return _internal_device_id();
}
inline void WriteRequest::_internal_set_device_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  device_id_ = value;
}
inline void WriteRequest::set_device_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.WriteRequest.device_id)
}

// uint64 role_id = 2;
inline void WriteRequest::clear_role_id() {
  role_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WriteRequest::_internal_role_id() const {
  return role_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WriteRequest::role_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.WriteRequest.role_id)
  return _internal_role_id();
}
inline void WriteRequest::_internal_set_role_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  role_id_ = value;
}
inline void WriteRequest::set_role_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_role_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.WriteRequest.role_id)
}

// .p4.v1.Uint128 election_id = 3;
inline bool WriteRequest::_internal_has_election_id() const {
  return this != internal_default_instance() && election_id_ != nullptr;
}
inline bool WriteRequest::has_election_id() const {
  return _internal_has_election_id();
}
inline void WriteRequest::clear_election_id() {
  if (GetArenaForAllocation() == nullptr && election_id_ != nullptr) {
    delete election_id_;
  }
  election_id_ = nullptr;
}
inline const ::p4::v1::Uint128& WriteRequest::_internal_election_id() const {
  const ::p4::v1::Uint128* p = election_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::Uint128&>(
      ::p4::v1::_Uint128_default_instance_);
}
inline const ::p4::v1::Uint128& WriteRequest::election_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.WriteRequest.election_id)
  return _internal_election_id();
}
inline void WriteRequest::unsafe_arena_set_allocated_election_id(
    ::p4::v1::Uint128* election_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(election_id_);
  }
  election_id_ = election_id;
  if (election_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.WriteRequest.election_id)
}
inline ::p4::v1::Uint128* WriteRequest::release_election_id() {
  
  ::p4::v1::Uint128* temp = election_id_;
  election_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::Uint128* WriteRequest::unsafe_arena_release_election_id() {
  // @@protoc_insertion_point(field_release:p4.v1.WriteRequest.election_id)
  
  ::p4::v1::Uint128* temp = election_id_;
  election_id_ = nullptr;
  return temp;
}
inline ::p4::v1::Uint128* WriteRequest::_internal_mutable_election_id() {
  
  if (election_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::Uint128>(GetArenaForAllocation());
    election_id_ = p;
  }
  return election_id_;
}
inline ::p4::v1::Uint128* WriteRequest::mutable_election_id() {
  ::p4::v1::Uint128* _msg = _internal_mutable_election_id();
  // @@protoc_insertion_point(field_mutable:p4.v1.WriteRequest.election_id)
  return _msg;
}
inline void WriteRequest::set_allocated_election_id(::p4::v1::Uint128* election_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete election_id_;
  }
  if (election_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::Uint128>::GetOwningArena(election_id);
    if (message_arena != submessage_arena) {
      election_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, election_id, submessage_arena);
    }
    
  } else {
    
  }
  election_id_ = election_id;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.WriteRequest.election_id)
}

// repeated .p4.v1.Update updates = 4;
inline int WriteRequest::_internal_updates_size() const {
  return updates_.size();
}
inline int WriteRequest::updates_size() const {
  return _internal_updates_size();
}
inline void WriteRequest::clear_updates() {
  updates_.Clear();
}
inline ::p4::v1::Update* WriteRequest::mutable_updates(int index) {
  // @@protoc_insertion_point(field_mutable:p4.v1.WriteRequest.updates)
  return updates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Update >*
WriteRequest::mutable_updates() {
  // @@protoc_insertion_point(field_mutable_list:p4.v1.WriteRequest.updates)
  return &updates_;
}
inline const ::p4::v1::Update& WriteRequest::_internal_updates(int index) const {
  return updates_.Get(index);
}
inline const ::p4::v1::Update& WriteRequest::updates(int index) const {
  // @@protoc_insertion_point(field_get:p4.v1.WriteRequest.updates)
  return _internal_updates(index);
}
inline ::p4::v1::Update* WriteRequest::_internal_add_updates() {
  return updates_.Add();
}
inline ::p4::v1::Update* WriteRequest::add_updates() {
  ::p4::v1::Update* _add = _internal_add_updates();
  // @@protoc_insertion_point(field_add:p4.v1.WriteRequest.updates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Update >&
WriteRequest::updates() const {
  // @@protoc_insertion_point(field_list:p4.v1.WriteRequest.updates)
  return updates_;
}

// .p4.v1.WriteRequest.Atomicity atomicity = 5;
inline void WriteRequest::clear_atomicity() {
  atomicity_ = 0;
}
inline ::p4::v1::WriteRequest_Atomicity WriteRequest::_internal_atomicity() const {
  return static_cast< ::p4::v1::WriteRequest_Atomicity >(atomicity_);
}
inline ::p4::v1::WriteRequest_Atomicity WriteRequest::atomicity() const {
  // @@protoc_insertion_point(field_get:p4.v1.WriteRequest.atomicity)
  return _internal_atomicity();
}
inline void WriteRequest::_internal_set_atomicity(::p4::v1::WriteRequest_Atomicity value) {
  
  atomicity_ = value;
}
inline void WriteRequest::set_atomicity(::p4::v1::WriteRequest_Atomicity value) {
  _internal_set_atomicity(value);
  // @@protoc_insertion_point(field_set:p4.v1.WriteRequest.atomicity)
}

// -------------------------------------------------------------------

// WriteResponse

// -------------------------------------------------------------------

// ReadRequest

// uint64 device_id = 1;
inline void ReadRequest::clear_device_id() {
  device_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ReadRequest::_internal_device_id() const {
  return device_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ReadRequest::device_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.ReadRequest.device_id)
  return _internal_device_id();
}
inline void ReadRequest::_internal_set_device_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  device_id_ = value;
}
inline void ReadRequest::set_device_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.ReadRequest.device_id)
}

// repeated .p4.v1.Entity entities = 2;
inline int ReadRequest::_internal_entities_size() const {
  return entities_.size();
}
inline int ReadRequest::entities_size() const {
  return _internal_entities_size();
}
inline void ReadRequest::clear_entities() {
  entities_.Clear();
}
inline ::p4::v1::Entity* ReadRequest::mutable_entities(int index) {
  // @@protoc_insertion_point(field_mutable:p4.v1.ReadRequest.entities)
  return entities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Entity >*
ReadRequest::mutable_entities() {
  // @@protoc_insertion_point(field_mutable_list:p4.v1.ReadRequest.entities)
  return &entities_;
}
inline const ::p4::v1::Entity& ReadRequest::_internal_entities(int index) const {
  return entities_.Get(index);
}
inline const ::p4::v1::Entity& ReadRequest::entities(int index) const {
  // @@protoc_insertion_point(field_get:p4.v1.ReadRequest.entities)
  return _internal_entities(index);
}
inline ::p4::v1::Entity* ReadRequest::_internal_add_entities() {
  return entities_.Add();
}
inline ::p4::v1::Entity* ReadRequest::add_entities() {
  ::p4::v1::Entity* _add = _internal_add_entities();
  // @@protoc_insertion_point(field_add:p4.v1.ReadRequest.entities)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Entity >&
ReadRequest::entities() const {
  // @@protoc_insertion_point(field_list:p4.v1.ReadRequest.entities)
  return entities_;
}

// -------------------------------------------------------------------

// ReadResponse

// repeated .p4.v1.Entity entities = 1;
inline int ReadResponse::_internal_entities_size() const {
  return entities_.size();
}
inline int ReadResponse::entities_size() const {
  return _internal_entities_size();
}
inline void ReadResponse::clear_entities() {
  entities_.Clear();
}
inline ::p4::v1::Entity* ReadResponse::mutable_entities(int index) {
  // @@protoc_insertion_point(field_mutable:p4.v1.ReadResponse.entities)
  return entities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Entity >*
ReadResponse::mutable_entities() {
  // @@protoc_insertion_point(field_mutable_list:p4.v1.ReadResponse.entities)
  return &entities_;
}
inline const ::p4::v1::Entity& ReadResponse::_internal_entities(int index) const {
  return entities_.Get(index);
}
inline const ::p4::v1::Entity& ReadResponse::entities(int index) const {
  // @@protoc_insertion_point(field_get:p4.v1.ReadResponse.entities)
  return _internal_entities(index);
}
inline ::p4::v1::Entity* ReadResponse::_internal_add_entities() {
  return entities_.Add();
}
inline ::p4::v1::Entity* ReadResponse::add_entities() {
  ::p4::v1::Entity* _add = _internal_add_entities();
  // @@protoc_insertion_point(field_add:p4.v1.ReadResponse.entities)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Entity >&
ReadResponse::entities() const {
  // @@protoc_insertion_point(field_list:p4.v1.ReadResponse.entities)
  return entities_;
}

// -------------------------------------------------------------------

// Update

// .p4.v1.Update.Type type = 1;
inline void Update::clear_type() {
  type_ = 0;
}
inline ::p4::v1::Update_Type Update::_internal_type() const {
  return static_cast< ::p4::v1::Update_Type >(type_);
}
inline ::p4::v1::Update_Type Update::type() const {
  // @@protoc_insertion_point(field_get:p4.v1.Update.type)
  return _internal_type();
}
inline void Update::_internal_set_type(::p4::v1::Update_Type value) {
  
  type_ = value;
}
inline void Update::set_type(::p4::v1::Update_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:p4.v1.Update.type)
}

// .p4.v1.Entity entity = 2;
inline bool Update::_internal_has_entity() const {
  return this != internal_default_instance() && entity_ != nullptr;
}
inline bool Update::has_entity() const {
  return _internal_has_entity();
}
inline void Update::clear_entity() {
  if (GetArenaForAllocation() == nullptr && entity_ != nullptr) {
    delete entity_;
  }
  entity_ = nullptr;
}
inline const ::p4::v1::Entity& Update::_internal_entity() const {
  const ::p4::v1::Entity* p = entity_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::Entity&>(
      ::p4::v1::_Entity_default_instance_);
}
inline const ::p4::v1::Entity& Update::entity() const {
  // @@protoc_insertion_point(field_get:p4.v1.Update.entity)
  return _internal_entity();
}
inline void Update::unsafe_arena_set_allocated_entity(
    ::p4::v1::Entity* entity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(entity_);
  }
  entity_ = entity;
  if (entity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.Update.entity)
}
inline ::p4::v1::Entity* Update::release_entity() {
  
  ::p4::v1::Entity* temp = entity_;
  entity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::Entity* Update::unsafe_arena_release_entity() {
  // @@protoc_insertion_point(field_release:p4.v1.Update.entity)
  
  ::p4::v1::Entity* temp = entity_;
  entity_ = nullptr;
  return temp;
}
inline ::p4::v1::Entity* Update::_internal_mutable_entity() {
  
  if (entity_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::Entity>(GetArenaForAllocation());
    entity_ = p;
  }
  return entity_;
}
inline ::p4::v1::Entity* Update::mutable_entity() {
  ::p4::v1::Entity* _msg = _internal_mutable_entity();
  // @@protoc_insertion_point(field_mutable:p4.v1.Update.entity)
  return _msg;
}
inline void Update::set_allocated_entity(::p4::v1::Entity* entity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete entity_;
  }
  if (entity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::Entity>::GetOwningArena(entity);
    if (message_arena != submessage_arena) {
      entity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, entity, submessage_arena);
    }
    
  } else {
    
  }
  entity_ = entity;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.Update.entity)
}

// -------------------------------------------------------------------

// Entity

// .p4.v1.ExternEntry extern_entry = 1;
inline bool Entity::_internal_has_extern_entry() const {
  return entity_case() == kExternEntry;
}
inline bool Entity::has_extern_entry() const {
  return _internal_has_extern_entry();
}
inline void Entity::set_has_extern_entry() {
  _oneof_case_[0] = kExternEntry;
}
inline void Entity::clear_extern_entry() {
  if (_internal_has_extern_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete entity_.extern_entry_;
    }
    clear_has_entity();
  }
}
inline ::p4::v1::ExternEntry* Entity::release_extern_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.Entity.extern_entry)
  if (_internal_has_extern_entry()) {
    clear_has_entity();
      ::p4::v1::ExternEntry* temp = entity_.extern_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_.extern_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::ExternEntry& Entity::_internal_extern_entry() const {
  return _internal_has_extern_entry()
      ? *entity_.extern_entry_
      : reinterpret_cast< ::p4::v1::ExternEntry&>(::p4::v1::_ExternEntry_default_instance_);
}
inline const ::p4::v1::ExternEntry& Entity::extern_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.Entity.extern_entry)
  return _internal_extern_entry();
}
inline ::p4::v1::ExternEntry* Entity::unsafe_arena_release_extern_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.Entity.extern_entry)
  if (_internal_has_extern_entry()) {
    clear_has_entity();
    ::p4::v1::ExternEntry* temp = entity_.extern_entry_;
    entity_.extern_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_extern_entry(::p4::v1::ExternEntry* extern_entry) {
  clear_entity();
  if (extern_entry) {
    set_has_extern_entry();
    entity_.extern_entry_ = extern_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.Entity.extern_entry)
}
inline ::p4::v1::ExternEntry* Entity::_internal_mutable_extern_entry() {
  if (!_internal_has_extern_entry()) {
    clear_entity();
    set_has_extern_entry();
    entity_.extern_entry_ = CreateMaybeMessage< ::p4::v1::ExternEntry >(GetArenaForAllocation());
  }
  return entity_.extern_entry_;
}
inline ::p4::v1::ExternEntry* Entity::mutable_extern_entry() {
  ::p4::v1::ExternEntry* _msg = _internal_mutable_extern_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.Entity.extern_entry)
  return _msg;
}

// .p4.v1.TableEntry table_entry = 2;
inline bool Entity::_internal_has_table_entry() const {
  return entity_case() == kTableEntry;
}
inline bool Entity::has_table_entry() const {
  return _internal_has_table_entry();
}
inline void Entity::set_has_table_entry() {
  _oneof_case_[0] = kTableEntry;
}
inline void Entity::clear_table_entry() {
  if (_internal_has_table_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete entity_.table_entry_;
    }
    clear_has_entity();
  }
}
inline ::p4::v1::TableEntry* Entity::release_table_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.Entity.table_entry)
  if (_internal_has_table_entry()) {
    clear_has_entity();
      ::p4::v1::TableEntry* temp = entity_.table_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_.table_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::TableEntry& Entity::_internal_table_entry() const {
  return _internal_has_table_entry()
      ? *entity_.table_entry_
      : reinterpret_cast< ::p4::v1::TableEntry&>(::p4::v1::_TableEntry_default_instance_);
}
inline const ::p4::v1::TableEntry& Entity::table_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.Entity.table_entry)
  return _internal_table_entry();
}
inline ::p4::v1::TableEntry* Entity::unsafe_arena_release_table_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.Entity.table_entry)
  if (_internal_has_table_entry()) {
    clear_has_entity();
    ::p4::v1::TableEntry* temp = entity_.table_entry_;
    entity_.table_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_table_entry(::p4::v1::TableEntry* table_entry) {
  clear_entity();
  if (table_entry) {
    set_has_table_entry();
    entity_.table_entry_ = table_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.Entity.table_entry)
}
inline ::p4::v1::TableEntry* Entity::_internal_mutable_table_entry() {
  if (!_internal_has_table_entry()) {
    clear_entity();
    set_has_table_entry();
    entity_.table_entry_ = CreateMaybeMessage< ::p4::v1::TableEntry >(GetArenaForAllocation());
  }
  return entity_.table_entry_;
}
inline ::p4::v1::TableEntry* Entity::mutable_table_entry() {
  ::p4::v1::TableEntry* _msg = _internal_mutable_table_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.Entity.table_entry)
  return _msg;
}

// .p4.v1.ActionProfileMember action_profile_member = 3;
inline bool Entity::_internal_has_action_profile_member() const {
  return entity_case() == kActionProfileMember;
}
inline bool Entity::has_action_profile_member() const {
  return _internal_has_action_profile_member();
}
inline void Entity::set_has_action_profile_member() {
  _oneof_case_[0] = kActionProfileMember;
}
inline void Entity::clear_action_profile_member() {
  if (_internal_has_action_profile_member()) {
    if (GetArenaForAllocation() == nullptr) {
      delete entity_.action_profile_member_;
    }
    clear_has_entity();
  }
}
inline ::p4::v1::ActionProfileMember* Entity::release_action_profile_member() {
  // @@protoc_insertion_point(field_release:p4.v1.Entity.action_profile_member)
  if (_internal_has_action_profile_member()) {
    clear_has_entity();
      ::p4::v1::ActionProfileMember* temp = entity_.action_profile_member_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_.action_profile_member_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::ActionProfileMember& Entity::_internal_action_profile_member() const {
  return _internal_has_action_profile_member()
      ? *entity_.action_profile_member_
      : reinterpret_cast< ::p4::v1::ActionProfileMember&>(::p4::v1::_ActionProfileMember_default_instance_);
}
inline const ::p4::v1::ActionProfileMember& Entity::action_profile_member() const {
  // @@protoc_insertion_point(field_get:p4.v1.Entity.action_profile_member)
  return _internal_action_profile_member();
}
inline ::p4::v1::ActionProfileMember* Entity::unsafe_arena_release_action_profile_member() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.Entity.action_profile_member)
  if (_internal_has_action_profile_member()) {
    clear_has_entity();
    ::p4::v1::ActionProfileMember* temp = entity_.action_profile_member_;
    entity_.action_profile_member_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_action_profile_member(::p4::v1::ActionProfileMember* action_profile_member) {
  clear_entity();
  if (action_profile_member) {
    set_has_action_profile_member();
    entity_.action_profile_member_ = action_profile_member;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.Entity.action_profile_member)
}
inline ::p4::v1::ActionProfileMember* Entity::_internal_mutable_action_profile_member() {
  if (!_internal_has_action_profile_member()) {
    clear_entity();
    set_has_action_profile_member();
    entity_.action_profile_member_ = CreateMaybeMessage< ::p4::v1::ActionProfileMember >(GetArenaForAllocation());
  }
  return entity_.action_profile_member_;
}
inline ::p4::v1::ActionProfileMember* Entity::mutable_action_profile_member() {
  ::p4::v1::ActionProfileMember* _msg = _internal_mutable_action_profile_member();
  // @@protoc_insertion_point(field_mutable:p4.v1.Entity.action_profile_member)
  return _msg;
}

// .p4.v1.ActionProfileGroup action_profile_group = 4;
inline bool Entity::_internal_has_action_profile_group() const {
  return entity_case() == kActionProfileGroup;
}
inline bool Entity::has_action_profile_group() const {
  return _internal_has_action_profile_group();
}
inline void Entity::set_has_action_profile_group() {
  _oneof_case_[0] = kActionProfileGroup;
}
inline void Entity::clear_action_profile_group() {
  if (_internal_has_action_profile_group()) {
    if (GetArenaForAllocation() == nullptr) {
      delete entity_.action_profile_group_;
    }
    clear_has_entity();
  }
}
inline ::p4::v1::ActionProfileGroup* Entity::release_action_profile_group() {
  // @@protoc_insertion_point(field_release:p4.v1.Entity.action_profile_group)
  if (_internal_has_action_profile_group()) {
    clear_has_entity();
      ::p4::v1::ActionProfileGroup* temp = entity_.action_profile_group_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_.action_profile_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::ActionProfileGroup& Entity::_internal_action_profile_group() const {
  return _internal_has_action_profile_group()
      ? *entity_.action_profile_group_
      : reinterpret_cast< ::p4::v1::ActionProfileGroup&>(::p4::v1::_ActionProfileGroup_default_instance_);
}
inline const ::p4::v1::ActionProfileGroup& Entity::action_profile_group() const {
  // @@protoc_insertion_point(field_get:p4.v1.Entity.action_profile_group)
  return _internal_action_profile_group();
}
inline ::p4::v1::ActionProfileGroup* Entity::unsafe_arena_release_action_profile_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.Entity.action_profile_group)
  if (_internal_has_action_profile_group()) {
    clear_has_entity();
    ::p4::v1::ActionProfileGroup* temp = entity_.action_profile_group_;
    entity_.action_profile_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_action_profile_group(::p4::v1::ActionProfileGroup* action_profile_group) {
  clear_entity();
  if (action_profile_group) {
    set_has_action_profile_group();
    entity_.action_profile_group_ = action_profile_group;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.Entity.action_profile_group)
}
inline ::p4::v1::ActionProfileGroup* Entity::_internal_mutable_action_profile_group() {
  if (!_internal_has_action_profile_group()) {
    clear_entity();
    set_has_action_profile_group();
    entity_.action_profile_group_ = CreateMaybeMessage< ::p4::v1::ActionProfileGroup >(GetArenaForAllocation());
  }
  return entity_.action_profile_group_;
}
inline ::p4::v1::ActionProfileGroup* Entity::mutable_action_profile_group() {
  ::p4::v1::ActionProfileGroup* _msg = _internal_mutable_action_profile_group();
  // @@protoc_insertion_point(field_mutable:p4.v1.Entity.action_profile_group)
  return _msg;
}

// .p4.v1.MeterEntry meter_entry = 5;
inline bool Entity::_internal_has_meter_entry() const {
  return entity_case() == kMeterEntry;
}
inline bool Entity::has_meter_entry() const {
  return _internal_has_meter_entry();
}
inline void Entity::set_has_meter_entry() {
  _oneof_case_[0] = kMeterEntry;
}
inline void Entity::clear_meter_entry() {
  if (_internal_has_meter_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete entity_.meter_entry_;
    }
    clear_has_entity();
  }
}
inline ::p4::v1::MeterEntry* Entity::release_meter_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.Entity.meter_entry)
  if (_internal_has_meter_entry()) {
    clear_has_entity();
      ::p4::v1::MeterEntry* temp = entity_.meter_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_.meter_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::MeterEntry& Entity::_internal_meter_entry() const {
  return _internal_has_meter_entry()
      ? *entity_.meter_entry_
      : reinterpret_cast< ::p4::v1::MeterEntry&>(::p4::v1::_MeterEntry_default_instance_);
}
inline const ::p4::v1::MeterEntry& Entity::meter_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.Entity.meter_entry)
  return _internal_meter_entry();
}
inline ::p4::v1::MeterEntry* Entity::unsafe_arena_release_meter_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.Entity.meter_entry)
  if (_internal_has_meter_entry()) {
    clear_has_entity();
    ::p4::v1::MeterEntry* temp = entity_.meter_entry_;
    entity_.meter_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_meter_entry(::p4::v1::MeterEntry* meter_entry) {
  clear_entity();
  if (meter_entry) {
    set_has_meter_entry();
    entity_.meter_entry_ = meter_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.Entity.meter_entry)
}
inline ::p4::v1::MeterEntry* Entity::_internal_mutable_meter_entry() {
  if (!_internal_has_meter_entry()) {
    clear_entity();
    set_has_meter_entry();
    entity_.meter_entry_ = CreateMaybeMessage< ::p4::v1::MeterEntry >(GetArenaForAllocation());
  }
  return entity_.meter_entry_;
}
inline ::p4::v1::MeterEntry* Entity::mutable_meter_entry() {
  ::p4::v1::MeterEntry* _msg = _internal_mutable_meter_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.Entity.meter_entry)
  return _msg;
}

// .p4.v1.DirectMeterEntry direct_meter_entry = 6;
inline bool Entity::_internal_has_direct_meter_entry() const {
  return entity_case() == kDirectMeterEntry;
}
inline bool Entity::has_direct_meter_entry() const {
  return _internal_has_direct_meter_entry();
}
inline void Entity::set_has_direct_meter_entry() {
  _oneof_case_[0] = kDirectMeterEntry;
}
inline void Entity::clear_direct_meter_entry() {
  if (_internal_has_direct_meter_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete entity_.direct_meter_entry_;
    }
    clear_has_entity();
  }
}
inline ::p4::v1::DirectMeterEntry* Entity::release_direct_meter_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.Entity.direct_meter_entry)
  if (_internal_has_direct_meter_entry()) {
    clear_has_entity();
      ::p4::v1::DirectMeterEntry* temp = entity_.direct_meter_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_.direct_meter_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::DirectMeterEntry& Entity::_internal_direct_meter_entry() const {
  return _internal_has_direct_meter_entry()
      ? *entity_.direct_meter_entry_
      : reinterpret_cast< ::p4::v1::DirectMeterEntry&>(::p4::v1::_DirectMeterEntry_default_instance_);
}
inline const ::p4::v1::DirectMeterEntry& Entity::direct_meter_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.Entity.direct_meter_entry)
  return _internal_direct_meter_entry();
}
inline ::p4::v1::DirectMeterEntry* Entity::unsafe_arena_release_direct_meter_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.Entity.direct_meter_entry)
  if (_internal_has_direct_meter_entry()) {
    clear_has_entity();
    ::p4::v1::DirectMeterEntry* temp = entity_.direct_meter_entry_;
    entity_.direct_meter_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_direct_meter_entry(::p4::v1::DirectMeterEntry* direct_meter_entry) {
  clear_entity();
  if (direct_meter_entry) {
    set_has_direct_meter_entry();
    entity_.direct_meter_entry_ = direct_meter_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.Entity.direct_meter_entry)
}
inline ::p4::v1::DirectMeterEntry* Entity::_internal_mutable_direct_meter_entry() {
  if (!_internal_has_direct_meter_entry()) {
    clear_entity();
    set_has_direct_meter_entry();
    entity_.direct_meter_entry_ = CreateMaybeMessage< ::p4::v1::DirectMeterEntry >(GetArenaForAllocation());
  }
  return entity_.direct_meter_entry_;
}
inline ::p4::v1::DirectMeterEntry* Entity::mutable_direct_meter_entry() {
  ::p4::v1::DirectMeterEntry* _msg = _internal_mutable_direct_meter_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.Entity.direct_meter_entry)
  return _msg;
}

// .p4.v1.CounterEntry counter_entry = 7;
inline bool Entity::_internal_has_counter_entry() const {
  return entity_case() == kCounterEntry;
}
inline bool Entity::has_counter_entry() const {
  return _internal_has_counter_entry();
}
inline void Entity::set_has_counter_entry() {
  _oneof_case_[0] = kCounterEntry;
}
inline void Entity::clear_counter_entry() {
  if (_internal_has_counter_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete entity_.counter_entry_;
    }
    clear_has_entity();
  }
}
inline ::p4::v1::CounterEntry* Entity::release_counter_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.Entity.counter_entry)
  if (_internal_has_counter_entry()) {
    clear_has_entity();
      ::p4::v1::CounterEntry* temp = entity_.counter_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_.counter_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::CounterEntry& Entity::_internal_counter_entry() const {
  return _internal_has_counter_entry()
      ? *entity_.counter_entry_
      : reinterpret_cast< ::p4::v1::CounterEntry&>(::p4::v1::_CounterEntry_default_instance_);
}
inline const ::p4::v1::CounterEntry& Entity::counter_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.Entity.counter_entry)
  return _internal_counter_entry();
}
inline ::p4::v1::CounterEntry* Entity::unsafe_arena_release_counter_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.Entity.counter_entry)
  if (_internal_has_counter_entry()) {
    clear_has_entity();
    ::p4::v1::CounterEntry* temp = entity_.counter_entry_;
    entity_.counter_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_counter_entry(::p4::v1::CounterEntry* counter_entry) {
  clear_entity();
  if (counter_entry) {
    set_has_counter_entry();
    entity_.counter_entry_ = counter_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.Entity.counter_entry)
}
inline ::p4::v1::CounterEntry* Entity::_internal_mutable_counter_entry() {
  if (!_internal_has_counter_entry()) {
    clear_entity();
    set_has_counter_entry();
    entity_.counter_entry_ = CreateMaybeMessage< ::p4::v1::CounterEntry >(GetArenaForAllocation());
  }
  return entity_.counter_entry_;
}
inline ::p4::v1::CounterEntry* Entity::mutable_counter_entry() {
  ::p4::v1::CounterEntry* _msg = _internal_mutable_counter_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.Entity.counter_entry)
  return _msg;
}

// .p4.v1.DirectCounterEntry direct_counter_entry = 8;
inline bool Entity::_internal_has_direct_counter_entry() const {
  return entity_case() == kDirectCounterEntry;
}
inline bool Entity::has_direct_counter_entry() const {
  return _internal_has_direct_counter_entry();
}
inline void Entity::set_has_direct_counter_entry() {
  _oneof_case_[0] = kDirectCounterEntry;
}
inline void Entity::clear_direct_counter_entry() {
  if (_internal_has_direct_counter_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete entity_.direct_counter_entry_;
    }
    clear_has_entity();
  }
}
inline ::p4::v1::DirectCounterEntry* Entity::release_direct_counter_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.Entity.direct_counter_entry)
  if (_internal_has_direct_counter_entry()) {
    clear_has_entity();
      ::p4::v1::DirectCounterEntry* temp = entity_.direct_counter_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_.direct_counter_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::DirectCounterEntry& Entity::_internal_direct_counter_entry() const {
  return _internal_has_direct_counter_entry()
      ? *entity_.direct_counter_entry_
      : reinterpret_cast< ::p4::v1::DirectCounterEntry&>(::p4::v1::_DirectCounterEntry_default_instance_);
}
inline const ::p4::v1::DirectCounterEntry& Entity::direct_counter_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.Entity.direct_counter_entry)
  return _internal_direct_counter_entry();
}
inline ::p4::v1::DirectCounterEntry* Entity::unsafe_arena_release_direct_counter_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.Entity.direct_counter_entry)
  if (_internal_has_direct_counter_entry()) {
    clear_has_entity();
    ::p4::v1::DirectCounterEntry* temp = entity_.direct_counter_entry_;
    entity_.direct_counter_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_direct_counter_entry(::p4::v1::DirectCounterEntry* direct_counter_entry) {
  clear_entity();
  if (direct_counter_entry) {
    set_has_direct_counter_entry();
    entity_.direct_counter_entry_ = direct_counter_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.Entity.direct_counter_entry)
}
inline ::p4::v1::DirectCounterEntry* Entity::_internal_mutable_direct_counter_entry() {
  if (!_internal_has_direct_counter_entry()) {
    clear_entity();
    set_has_direct_counter_entry();
    entity_.direct_counter_entry_ = CreateMaybeMessage< ::p4::v1::DirectCounterEntry >(GetArenaForAllocation());
  }
  return entity_.direct_counter_entry_;
}
inline ::p4::v1::DirectCounterEntry* Entity::mutable_direct_counter_entry() {
  ::p4::v1::DirectCounterEntry* _msg = _internal_mutable_direct_counter_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.Entity.direct_counter_entry)
  return _msg;
}

// .p4.v1.PacketReplicationEngineEntry packet_replication_engine_entry = 9;
inline bool Entity::_internal_has_packet_replication_engine_entry() const {
  return entity_case() == kPacketReplicationEngineEntry;
}
inline bool Entity::has_packet_replication_engine_entry() const {
  return _internal_has_packet_replication_engine_entry();
}
inline void Entity::set_has_packet_replication_engine_entry() {
  _oneof_case_[0] = kPacketReplicationEngineEntry;
}
inline void Entity::clear_packet_replication_engine_entry() {
  if (_internal_has_packet_replication_engine_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete entity_.packet_replication_engine_entry_;
    }
    clear_has_entity();
  }
}
inline ::p4::v1::PacketReplicationEngineEntry* Entity::release_packet_replication_engine_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.Entity.packet_replication_engine_entry)
  if (_internal_has_packet_replication_engine_entry()) {
    clear_has_entity();
      ::p4::v1::PacketReplicationEngineEntry* temp = entity_.packet_replication_engine_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_.packet_replication_engine_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::PacketReplicationEngineEntry& Entity::_internal_packet_replication_engine_entry() const {
  return _internal_has_packet_replication_engine_entry()
      ? *entity_.packet_replication_engine_entry_
      : reinterpret_cast< ::p4::v1::PacketReplicationEngineEntry&>(::p4::v1::_PacketReplicationEngineEntry_default_instance_);
}
inline const ::p4::v1::PacketReplicationEngineEntry& Entity::packet_replication_engine_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.Entity.packet_replication_engine_entry)
  return _internal_packet_replication_engine_entry();
}
inline ::p4::v1::PacketReplicationEngineEntry* Entity::unsafe_arena_release_packet_replication_engine_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.Entity.packet_replication_engine_entry)
  if (_internal_has_packet_replication_engine_entry()) {
    clear_has_entity();
    ::p4::v1::PacketReplicationEngineEntry* temp = entity_.packet_replication_engine_entry_;
    entity_.packet_replication_engine_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_packet_replication_engine_entry(::p4::v1::PacketReplicationEngineEntry* packet_replication_engine_entry) {
  clear_entity();
  if (packet_replication_engine_entry) {
    set_has_packet_replication_engine_entry();
    entity_.packet_replication_engine_entry_ = packet_replication_engine_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.Entity.packet_replication_engine_entry)
}
inline ::p4::v1::PacketReplicationEngineEntry* Entity::_internal_mutable_packet_replication_engine_entry() {
  if (!_internal_has_packet_replication_engine_entry()) {
    clear_entity();
    set_has_packet_replication_engine_entry();
    entity_.packet_replication_engine_entry_ = CreateMaybeMessage< ::p4::v1::PacketReplicationEngineEntry >(GetArenaForAllocation());
  }
  return entity_.packet_replication_engine_entry_;
}
inline ::p4::v1::PacketReplicationEngineEntry* Entity::mutable_packet_replication_engine_entry() {
  ::p4::v1::PacketReplicationEngineEntry* _msg = _internal_mutable_packet_replication_engine_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.Entity.packet_replication_engine_entry)
  return _msg;
}

// .p4.v1.ValueSetEntry value_set_entry = 10;
inline bool Entity::_internal_has_value_set_entry() const {
  return entity_case() == kValueSetEntry;
}
inline bool Entity::has_value_set_entry() const {
  return _internal_has_value_set_entry();
}
inline void Entity::set_has_value_set_entry() {
  _oneof_case_[0] = kValueSetEntry;
}
inline void Entity::clear_value_set_entry() {
  if (_internal_has_value_set_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete entity_.value_set_entry_;
    }
    clear_has_entity();
  }
}
inline ::p4::v1::ValueSetEntry* Entity::release_value_set_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.Entity.value_set_entry)
  if (_internal_has_value_set_entry()) {
    clear_has_entity();
      ::p4::v1::ValueSetEntry* temp = entity_.value_set_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_.value_set_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::ValueSetEntry& Entity::_internal_value_set_entry() const {
  return _internal_has_value_set_entry()
      ? *entity_.value_set_entry_
      : reinterpret_cast< ::p4::v1::ValueSetEntry&>(::p4::v1::_ValueSetEntry_default_instance_);
}
inline const ::p4::v1::ValueSetEntry& Entity::value_set_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.Entity.value_set_entry)
  return _internal_value_set_entry();
}
inline ::p4::v1::ValueSetEntry* Entity::unsafe_arena_release_value_set_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.Entity.value_set_entry)
  if (_internal_has_value_set_entry()) {
    clear_has_entity();
    ::p4::v1::ValueSetEntry* temp = entity_.value_set_entry_;
    entity_.value_set_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_value_set_entry(::p4::v1::ValueSetEntry* value_set_entry) {
  clear_entity();
  if (value_set_entry) {
    set_has_value_set_entry();
    entity_.value_set_entry_ = value_set_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.Entity.value_set_entry)
}
inline ::p4::v1::ValueSetEntry* Entity::_internal_mutable_value_set_entry() {
  if (!_internal_has_value_set_entry()) {
    clear_entity();
    set_has_value_set_entry();
    entity_.value_set_entry_ = CreateMaybeMessage< ::p4::v1::ValueSetEntry >(GetArenaForAllocation());
  }
  return entity_.value_set_entry_;
}
inline ::p4::v1::ValueSetEntry* Entity::mutable_value_set_entry() {
  ::p4::v1::ValueSetEntry* _msg = _internal_mutable_value_set_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.Entity.value_set_entry)
  return _msg;
}

// .p4.v1.RegisterEntry register_entry = 11;
inline bool Entity::_internal_has_register_entry() const {
  return entity_case() == kRegisterEntry;
}
inline bool Entity::has_register_entry() const {
  return _internal_has_register_entry();
}
inline void Entity::set_has_register_entry() {
  _oneof_case_[0] = kRegisterEntry;
}
inline void Entity::clear_register_entry() {
  if (_internal_has_register_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete entity_.register_entry_;
    }
    clear_has_entity();
  }
}
inline ::p4::v1::RegisterEntry* Entity::release_register_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.Entity.register_entry)
  if (_internal_has_register_entry()) {
    clear_has_entity();
      ::p4::v1::RegisterEntry* temp = entity_.register_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_.register_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::RegisterEntry& Entity::_internal_register_entry() const {
  return _internal_has_register_entry()
      ? *entity_.register_entry_
      : reinterpret_cast< ::p4::v1::RegisterEntry&>(::p4::v1::_RegisterEntry_default_instance_);
}
inline const ::p4::v1::RegisterEntry& Entity::register_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.Entity.register_entry)
  return _internal_register_entry();
}
inline ::p4::v1::RegisterEntry* Entity::unsafe_arena_release_register_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.Entity.register_entry)
  if (_internal_has_register_entry()) {
    clear_has_entity();
    ::p4::v1::RegisterEntry* temp = entity_.register_entry_;
    entity_.register_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_register_entry(::p4::v1::RegisterEntry* register_entry) {
  clear_entity();
  if (register_entry) {
    set_has_register_entry();
    entity_.register_entry_ = register_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.Entity.register_entry)
}
inline ::p4::v1::RegisterEntry* Entity::_internal_mutable_register_entry() {
  if (!_internal_has_register_entry()) {
    clear_entity();
    set_has_register_entry();
    entity_.register_entry_ = CreateMaybeMessage< ::p4::v1::RegisterEntry >(GetArenaForAllocation());
  }
  return entity_.register_entry_;
}
inline ::p4::v1::RegisterEntry* Entity::mutable_register_entry() {
  ::p4::v1::RegisterEntry* _msg = _internal_mutable_register_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.Entity.register_entry)
  return _msg;
}

// .p4.v1.DigestEntry digest_entry = 12;
inline bool Entity::_internal_has_digest_entry() const {
  return entity_case() == kDigestEntry;
}
inline bool Entity::has_digest_entry() const {
  return _internal_has_digest_entry();
}
inline void Entity::set_has_digest_entry() {
  _oneof_case_[0] = kDigestEntry;
}
inline void Entity::clear_digest_entry() {
  if (_internal_has_digest_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete entity_.digest_entry_;
    }
    clear_has_entity();
  }
}
inline ::p4::v1::DigestEntry* Entity::release_digest_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.Entity.digest_entry)
  if (_internal_has_digest_entry()) {
    clear_has_entity();
      ::p4::v1::DigestEntry* temp = entity_.digest_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_.digest_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::DigestEntry& Entity::_internal_digest_entry() const {
  return _internal_has_digest_entry()
      ? *entity_.digest_entry_
      : reinterpret_cast< ::p4::v1::DigestEntry&>(::p4::v1::_DigestEntry_default_instance_);
}
inline const ::p4::v1::DigestEntry& Entity::digest_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.Entity.digest_entry)
  return _internal_digest_entry();
}
inline ::p4::v1::DigestEntry* Entity::unsafe_arena_release_digest_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.Entity.digest_entry)
  if (_internal_has_digest_entry()) {
    clear_has_entity();
    ::p4::v1::DigestEntry* temp = entity_.digest_entry_;
    entity_.digest_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_digest_entry(::p4::v1::DigestEntry* digest_entry) {
  clear_entity();
  if (digest_entry) {
    set_has_digest_entry();
    entity_.digest_entry_ = digest_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.Entity.digest_entry)
}
inline ::p4::v1::DigestEntry* Entity::_internal_mutable_digest_entry() {
  if (!_internal_has_digest_entry()) {
    clear_entity();
    set_has_digest_entry();
    entity_.digest_entry_ = CreateMaybeMessage< ::p4::v1::DigestEntry >(GetArenaForAllocation());
  }
  return entity_.digest_entry_;
}
inline ::p4::v1::DigestEntry* Entity::mutable_digest_entry() {
  ::p4::v1::DigestEntry* _msg = _internal_mutable_digest_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.Entity.digest_entry)
  return _msg;
}

// .p4.v1.RuntimeReconfigEntry runtime_reconfig_entry = 13;
inline bool Entity::_internal_has_runtime_reconfig_entry() const {
  return entity_case() == kRuntimeReconfigEntry;
}
inline bool Entity::has_runtime_reconfig_entry() const {
  return _internal_has_runtime_reconfig_entry();
}
inline void Entity::set_has_runtime_reconfig_entry() {
  _oneof_case_[0] = kRuntimeReconfigEntry;
}
inline void Entity::clear_runtime_reconfig_entry() {
  if (_internal_has_runtime_reconfig_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete entity_.runtime_reconfig_entry_;
    }
    clear_has_entity();
  }
}
inline ::p4::v1::RuntimeReconfigEntry* Entity::release_runtime_reconfig_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.Entity.runtime_reconfig_entry)
  if (_internal_has_runtime_reconfig_entry()) {
    clear_has_entity();
      ::p4::v1::RuntimeReconfigEntry* temp = entity_.runtime_reconfig_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entity_.runtime_reconfig_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::RuntimeReconfigEntry& Entity::_internal_runtime_reconfig_entry() const {
  return _internal_has_runtime_reconfig_entry()
      ? *entity_.runtime_reconfig_entry_
      : reinterpret_cast< ::p4::v1::RuntimeReconfigEntry&>(::p4::v1::_RuntimeReconfigEntry_default_instance_);
}
inline const ::p4::v1::RuntimeReconfigEntry& Entity::runtime_reconfig_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.Entity.runtime_reconfig_entry)
  return _internal_runtime_reconfig_entry();
}
inline ::p4::v1::RuntimeReconfigEntry* Entity::unsafe_arena_release_runtime_reconfig_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.Entity.runtime_reconfig_entry)
  if (_internal_has_runtime_reconfig_entry()) {
    clear_has_entity();
    ::p4::v1::RuntimeReconfigEntry* temp = entity_.runtime_reconfig_entry_;
    entity_.runtime_reconfig_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_runtime_reconfig_entry(::p4::v1::RuntimeReconfigEntry* runtime_reconfig_entry) {
  clear_entity();
  if (runtime_reconfig_entry) {
    set_has_runtime_reconfig_entry();
    entity_.runtime_reconfig_entry_ = runtime_reconfig_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.Entity.runtime_reconfig_entry)
}
inline ::p4::v1::RuntimeReconfigEntry* Entity::_internal_mutable_runtime_reconfig_entry() {
  if (!_internal_has_runtime_reconfig_entry()) {
    clear_entity();
    set_has_runtime_reconfig_entry();
    entity_.runtime_reconfig_entry_ = CreateMaybeMessage< ::p4::v1::RuntimeReconfigEntry >(GetArenaForAllocation());
  }
  return entity_.runtime_reconfig_entry_;
}
inline ::p4::v1::RuntimeReconfigEntry* Entity::mutable_runtime_reconfig_entry() {
  ::p4::v1::RuntimeReconfigEntry* _msg = _internal_mutable_runtime_reconfig_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.Entity.runtime_reconfig_entry)
  return _msg;
}

inline bool Entity::has_entity() const {
  return entity_case() != ENTITY_NOT_SET;
}
inline void Entity::clear_has_entity() {
  _oneof_case_[0] = ENTITY_NOT_SET;
}
inline Entity::EntityCase Entity::entity_case() const {
  return Entity::EntityCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RuntimeReconfigEntry

// .p4.v1.RuntimeReconfigEntry.RuntimeReconfigType runtime_reconfig_type = 1;
inline void RuntimeReconfigEntry::clear_runtime_reconfig_type() {
  runtime_reconfig_type_ = 0;
}
inline ::p4::v1::RuntimeReconfigEntry_RuntimeReconfigType RuntimeReconfigEntry::_internal_runtime_reconfig_type() const {
  return static_cast< ::p4::v1::RuntimeReconfigEntry_RuntimeReconfigType >(runtime_reconfig_type_);
}
inline ::p4::v1::RuntimeReconfigEntry_RuntimeReconfigType RuntimeReconfigEntry::runtime_reconfig_type() const {
  // @@protoc_insertion_point(field_get:p4.v1.RuntimeReconfigEntry.runtime_reconfig_type)
  return _internal_runtime_reconfig_type();
}
inline void RuntimeReconfigEntry::_internal_set_runtime_reconfig_type(::p4::v1::RuntimeReconfigEntry_RuntimeReconfigType value) {
  
  runtime_reconfig_type_ = value;
}
inline void RuntimeReconfigEntry::set_runtime_reconfig_type(::p4::v1::RuntimeReconfigEntry_RuntimeReconfigType value) {
  _internal_set_runtime_reconfig_type(value);
  // @@protoc_insertion_point(field_set:p4.v1.RuntimeReconfigEntry.runtime_reconfig_type)
}

// .p4.v1.RuntimeReconfigContent runtime_reconfig_content = 2;
inline bool RuntimeReconfigEntry::_internal_has_runtime_reconfig_content() const {
  return this != internal_default_instance() && runtime_reconfig_content_ != nullptr;
}
inline bool RuntimeReconfigEntry::has_runtime_reconfig_content() const {
  return _internal_has_runtime_reconfig_content();
}
inline void RuntimeReconfigEntry::clear_runtime_reconfig_content() {
  if (GetArenaForAllocation() == nullptr && runtime_reconfig_content_ != nullptr) {
    delete runtime_reconfig_content_;
  }
  runtime_reconfig_content_ = nullptr;
}
inline const ::p4::v1::RuntimeReconfigContent& RuntimeReconfigEntry::_internal_runtime_reconfig_content() const {
  const ::p4::v1::RuntimeReconfigContent* p = runtime_reconfig_content_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::RuntimeReconfigContent&>(
      ::p4::v1::_RuntimeReconfigContent_default_instance_);
}
inline const ::p4::v1::RuntimeReconfigContent& RuntimeReconfigEntry::runtime_reconfig_content() const {
  // @@protoc_insertion_point(field_get:p4.v1.RuntimeReconfigEntry.runtime_reconfig_content)
  return _internal_runtime_reconfig_content();
}
inline void RuntimeReconfigEntry::unsafe_arena_set_allocated_runtime_reconfig_content(
    ::p4::v1::RuntimeReconfigContent* runtime_reconfig_content) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(runtime_reconfig_content_);
  }
  runtime_reconfig_content_ = runtime_reconfig_content;
  if (runtime_reconfig_content) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.RuntimeReconfigEntry.runtime_reconfig_content)
}
inline ::p4::v1::RuntimeReconfigContent* RuntimeReconfigEntry::release_runtime_reconfig_content() {
  
  ::p4::v1::RuntimeReconfigContent* temp = runtime_reconfig_content_;
  runtime_reconfig_content_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::RuntimeReconfigContent* RuntimeReconfigEntry::unsafe_arena_release_runtime_reconfig_content() {
  // @@protoc_insertion_point(field_release:p4.v1.RuntimeReconfigEntry.runtime_reconfig_content)
  
  ::p4::v1::RuntimeReconfigContent* temp = runtime_reconfig_content_;
  runtime_reconfig_content_ = nullptr;
  return temp;
}
inline ::p4::v1::RuntimeReconfigContent* RuntimeReconfigEntry::_internal_mutable_runtime_reconfig_content() {
  
  if (runtime_reconfig_content_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::RuntimeReconfigContent>(GetArenaForAllocation());
    runtime_reconfig_content_ = p;
  }
  return runtime_reconfig_content_;
}
inline ::p4::v1::RuntimeReconfigContent* RuntimeReconfigEntry::mutable_runtime_reconfig_content() {
  ::p4::v1::RuntimeReconfigContent* _msg = _internal_mutable_runtime_reconfig_content();
  // @@protoc_insertion_point(field_mutable:p4.v1.RuntimeReconfigEntry.runtime_reconfig_content)
  return _msg;
}
inline void RuntimeReconfigEntry::set_allocated_runtime_reconfig_content(::p4::v1::RuntimeReconfigContent* runtime_reconfig_content) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete runtime_reconfig_content_;
  }
  if (runtime_reconfig_content) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::RuntimeReconfigContent>::GetOwningArena(runtime_reconfig_content);
    if (message_arena != submessage_arena) {
      runtime_reconfig_content = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, runtime_reconfig_content, submessage_arena);
    }
    
  } else {
    
  }
  runtime_reconfig_content_ = runtime_reconfig_content;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.RuntimeReconfigEntry.runtime_reconfig_content)
}

// -------------------------------------------------------------------

// RuntimeReconfigContent

// .p4.v1.InitP4ObjectsNewEntry init_p4objects_new_entry = 1;
inline bool RuntimeReconfigContent::_internal_has_init_p4objects_new_entry() const {
  return content_case() == kInitP4ObjectsNewEntry;
}
inline bool RuntimeReconfigContent::has_init_p4objects_new_entry() const {
  return _internal_has_init_p4objects_new_entry();
}
inline void RuntimeReconfigContent::set_has_init_p4objects_new_entry() {
  _oneof_case_[0] = kInitP4ObjectsNewEntry;
}
inline void RuntimeReconfigContent::clear_init_p4objects_new_entry() {
  if (_internal_has_init_p4objects_new_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete content_.init_p4objects_new_entry_;
    }
    clear_has_content();
  }
}
inline ::p4::v1::InitP4ObjectsNewEntry* RuntimeReconfigContent::release_init_p4objects_new_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.RuntimeReconfigContent.init_p4objects_new_entry)
  if (_internal_has_init_p4objects_new_entry()) {
    clear_has_content();
      ::p4::v1::InitP4ObjectsNewEntry* temp = content_.init_p4objects_new_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    content_.init_p4objects_new_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::InitP4ObjectsNewEntry& RuntimeReconfigContent::_internal_init_p4objects_new_entry() const {
  return _internal_has_init_p4objects_new_entry()
      ? *content_.init_p4objects_new_entry_
      : reinterpret_cast< ::p4::v1::InitP4ObjectsNewEntry&>(::p4::v1::_InitP4ObjectsNewEntry_default_instance_);
}
inline const ::p4::v1::InitP4ObjectsNewEntry& RuntimeReconfigContent::init_p4objects_new_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.RuntimeReconfigContent.init_p4objects_new_entry)
  return _internal_init_p4objects_new_entry();
}
inline ::p4::v1::InitP4ObjectsNewEntry* RuntimeReconfigContent::unsafe_arena_release_init_p4objects_new_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.RuntimeReconfigContent.init_p4objects_new_entry)
  if (_internal_has_init_p4objects_new_entry()) {
    clear_has_content();
    ::p4::v1::InitP4ObjectsNewEntry* temp = content_.init_p4objects_new_entry_;
    content_.init_p4objects_new_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuntimeReconfigContent::unsafe_arena_set_allocated_init_p4objects_new_entry(::p4::v1::InitP4ObjectsNewEntry* init_p4objects_new_entry) {
  clear_content();
  if (init_p4objects_new_entry) {
    set_has_init_p4objects_new_entry();
    content_.init_p4objects_new_entry_ = init_p4objects_new_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.RuntimeReconfigContent.init_p4objects_new_entry)
}
inline ::p4::v1::InitP4ObjectsNewEntry* RuntimeReconfigContent::_internal_mutable_init_p4objects_new_entry() {
  if (!_internal_has_init_p4objects_new_entry()) {
    clear_content();
    set_has_init_p4objects_new_entry();
    content_.init_p4objects_new_entry_ = CreateMaybeMessage< ::p4::v1::InitP4ObjectsNewEntry >(GetArenaForAllocation());
  }
  return content_.init_p4objects_new_entry_;
}
inline ::p4::v1::InitP4ObjectsNewEntry* RuntimeReconfigContent::mutable_init_p4objects_new_entry() {
  ::p4::v1::InitP4ObjectsNewEntry* _msg = _internal_mutable_init_p4objects_new_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.RuntimeReconfigContent.init_p4objects_new_entry)
  return _msg;
}

// .p4.v1.InsertTableEntry insert_table_entry = 2;
inline bool RuntimeReconfigContent::_internal_has_insert_table_entry() const {
  return content_case() == kInsertTableEntry;
}
inline bool RuntimeReconfigContent::has_insert_table_entry() const {
  return _internal_has_insert_table_entry();
}
inline void RuntimeReconfigContent::set_has_insert_table_entry() {
  _oneof_case_[0] = kInsertTableEntry;
}
inline void RuntimeReconfigContent::clear_insert_table_entry() {
  if (_internal_has_insert_table_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete content_.insert_table_entry_;
    }
    clear_has_content();
  }
}
inline ::p4::v1::InsertTableEntry* RuntimeReconfigContent::release_insert_table_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.RuntimeReconfigContent.insert_table_entry)
  if (_internal_has_insert_table_entry()) {
    clear_has_content();
      ::p4::v1::InsertTableEntry* temp = content_.insert_table_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    content_.insert_table_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::InsertTableEntry& RuntimeReconfigContent::_internal_insert_table_entry() const {
  return _internal_has_insert_table_entry()
      ? *content_.insert_table_entry_
      : reinterpret_cast< ::p4::v1::InsertTableEntry&>(::p4::v1::_InsertTableEntry_default_instance_);
}
inline const ::p4::v1::InsertTableEntry& RuntimeReconfigContent::insert_table_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.RuntimeReconfigContent.insert_table_entry)
  return _internal_insert_table_entry();
}
inline ::p4::v1::InsertTableEntry* RuntimeReconfigContent::unsafe_arena_release_insert_table_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.RuntimeReconfigContent.insert_table_entry)
  if (_internal_has_insert_table_entry()) {
    clear_has_content();
    ::p4::v1::InsertTableEntry* temp = content_.insert_table_entry_;
    content_.insert_table_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuntimeReconfigContent::unsafe_arena_set_allocated_insert_table_entry(::p4::v1::InsertTableEntry* insert_table_entry) {
  clear_content();
  if (insert_table_entry) {
    set_has_insert_table_entry();
    content_.insert_table_entry_ = insert_table_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.RuntimeReconfigContent.insert_table_entry)
}
inline ::p4::v1::InsertTableEntry* RuntimeReconfigContent::_internal_mutable_insert_table_entry() {
  if (!_internal_has_insert_table_entry()) {
    clear_content();
    set_has_insert_table_entry();
    content_.insert_table_entry_ = CreateMaybeMessage< ::p4::v1::InsertTableEntry >(GetArenaForAllocation());
  }
  return content_.insert_table_entry_;
}
inline ::p4::v1::InsertTableEntry* RuntimeReconfigContent::mutable_insert_table_entry() {
  ::p4::v1::InsertTableEntry* _msg = _internal_mutable_insert_table_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.RuntimeReconfigContent.insert_table_entry)
  return _msg;
}

// .p4.v1.ChangeTableEntry change_table_entry = 3;
inline bool RuntimeReconfigContent::_internal_has_change_table_entry() const {
  return content_case() == kChangeTableEntry;
}
inline bool RuntimeReconfigContent::has_change_table_entry() const {
  return _internal_has_change_table_entry();
}
inline void RuntimeReconfigContent::set_has_change_table_entry() {
  _oneof_case_[0] = kChangeTableEntry;
}
inline void RuntimeReconfigContent::clear_change_table_entry() {
  if (_internal_has_change_table_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete content_.change_table_entry_;
    }
    clear_has_content();
  }
}
inline ::p4::v1::ChangeTableEntry* RuntimeReconfigContent::release_change_table_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.RuntimeReconfigContent.change_table_entry)
  if (_internal_has_change_table_entry()) {
    clear_has_content();
      ::p4::v1::ChangeTableEntry* temp = content_.change_table_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    content_.change_table_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::ChangeTableEntry& RuntimeReconfigContent::_internal_change_table_entry() const {
  return _internal_has_change_table_entry()
      ? *content_.change_table_entry_
      : reinterpret_cast< ::p4::v1::ChangeTableEntry&>(::p4::v1::_ChangeTableEntry_default_instance_);
}
inline const ::p4::v1::ChangeTableEntry& RuntimeReconfigContent::change_table_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.RuntimeReconfigContent.change_table_entry)
  return _internal_change_table_entry();
}
inline ::p4::v1::ChangeTableEntry* RuntimeReconfigContent::unsafe_arena_release_change_table_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.RuntimeReconfigContent.change_table_entry)
  if (_internal_has_change_table_entry()) {
    clear_has_content();
    ::p4::v1::ChangeTableEntry* temp = content_.change_table_entry_;
    content_.change_table_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuntimeReconfigContent::unsafe_arena_set_allocated_change_table_entry(::p4::v1::ChangeTableEntry* change_table_entry) {
  clear_content();
  if (change_table_entry) {
    set_has_change_table_entry();
    content_.change_table_entry_ = change_table_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.RuntimeReconfigContent.change_table_entry)
}
inline ::p4::v1::ChangeTableEntry* RuntimeReconfigContent::_internal_mutable_change_table_entry() {
  if (!_internal_has_change_table_entry()) {
    clear_content();
    set_has_change_table_entry();
    content_.change_table_entry_ = CreateMaybeMessage< ::p4::v1::ChangeTableEntry >(GetArenaForAllocation());
  }
  return content_.change_table_entry_;
}
inline ::p4::v1::ChangeTableEntry* RuntimeReconfigContent::mutable_change_table_entry() {
  ::p4::v1::ChangeTableEntry* _msg = _internal_mutable_change_table_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.RuntimeReconfigContent.change_table_entry)
  return _msg;
}

// .p4.v1.DeleteTableEntry delete_table_entry = 4;
inline bool RuntimeReconfigContent::_internal_has_delete_table_entry() const {
  return content_case() == kDeleteTableEntry;
}
inline bool RuntimeReconfigContent::has_delete_table_entry() const {
  return _internal_has_delete_table_entry();
}
inline void RuntimeReconfigContent::set_has_delete_table_entry() {
  _oneof_case_[0] = kDeleteTableEntry;
}
inline void RuntimeReconfigContent::clear_delete_table_entry() {
  if (_internal_has_delete_table_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete content_.delete_table_entry_;
    }
    clear_has_content();
  }
}
inline ::p4::v1::DeleteTableEntry* RuntimeReconfigContent::release_delete_table_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.RuntimeReconfigContent.delete_table_entry)
  if (_internal_has_delete_table_entry()) {
    clear_has_content();
      ::p4::v1::DeleteTableEntry* temp = content_.delete_table_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    content_.delete_table_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::DeleteTableEntry& RuntimeReconfigContent::_internal_delete_table_entry() const {
  return _internal_has_delete_table_entry()
      ? *content_.delete_table_entry_
      : reinterpret_cast< ::p4::v1::DeleteTableEntry&>(::p4::v1::_DeleteTableEntry_default_instance_);
}
inline const ::p4::v1::DeleteTableEntry& RuntimeReconfigContent::delete_table_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.RuntimeReconfigContent.delete_table_entry)
  return _internal_delete_table_entry();
}
inline ::p4::v1::DeleteTableEntry* RuntimeReconfigContent::unsafe_arena_release_delete_table_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.RuntimeReconfigContent.delete_table_entry)
  if (_internal_has_delete_table_entry()) {
    clear_has_content();
    ::p4::v1::DeleteTableEntry* temp = content_.delete_table_entry_;
    content_.delete_table_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuntimeReconfigContent::unsafe_arena_set_allocated_delete_table_entry(::p4::v1::DeleteTableEntry* delete_table_entry) {
  clear_content();
  if (delete_table_entry) {
    set_has_delete_table_entry();
    content_.delete_table_entry_ = delete_table_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.RuntimeReconfigContent.delete_table_entry)
}
inline ::p4::v1::DeleteTableEntry* RuntimeReconfigContent::_internal_mutable_delete_table_entry() {
  if (!_internal_has_delete_table_entry()) {
    clear_content();
    set_has_delete_table_entry();
    content_.delete_table_entry_ = CreateMaybeMessage< ::p4::v1::DeleteTableEntry >(GetArenaForAllocation());
  }
  return content_.delete_table_entry_;
}
inline ::p4::v1::DeleteTableEntry* RuntimeReconfigContent::mutable_delete_table_entry() {
  ::p4::v1::DeleteTableEntry* _msg = _internal_mutable_delete_table_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.RuntimeReconfigContent.delete_table_entry)
  return _msg;
}

// .p4.v1.InsertConditionalEntry insert_conditional_entry = 5;
inline bool RuntimeReconfigContent::_internal_has_insert_conditional_entry() const {
  return content_case() == kInsertConditionalEntry;
}
inline bool RuntimeReconfigContent::has_insert_conditional_entry() const {
  return _internal_has_insert_conditional_entry();
}
inline void RuntimeReconfigContent::set_has_insert_conditional_entry() {
  _oneof_case_[0] = kInsertConditionalEntry;
}
inline void RuntimeReconfigContent::clear_insert_conditional_entry() {
  if (_internal_has_insert_conditional_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete content_.insert_conditional_entry_;
    }
    clear_has_content();
  }
}
inline ::p4::v1::InsertConditionalEntry* RuntimeReconfigContent::release_insert_conditional_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.RuntimeReconfigContent.insert_conditional_entry)
  if (_internal_has_insert_conditional_entry()) {
    clear_has_content();
      ::p4::v1::InsertConditionalEntry* temp = content_.insert_conditional_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    content_.insert_conditional_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::InsertConditionalEntry& RuntimeReconfigContent::_internal_insert_conditional_entry() const {
  return _internal_has_insert_conditional_entry()
      ? *content_.insert_conditional_entry_
      : reinterpret_cast< ::p4::v1::InsertConditionalEntry&>(::p4::v1::_InsertConditionalEntry_default_instance_);
}
inline const ::p4::v1::InsertConditionalEntry& RuntimeReconfigContent::insert_conditional_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.RuntimeReconfigContent.insert_conditional_entry)
  return _internal_insert_conditional_entry();
}
inline ::p4::v1::InsertConditionalEntry* RuntimeReconfigContent::unsafe_arena_release_insert_conditional_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.RuntimeReconfigContent.insert_conditional_entry)
  if (_internal_has_insert_conditional_entry()) {
    clear_has_content();
    ::p4::v1::InsertConditionalEntry* temp = content_.insert_conditional_entry_;
    content_.insert_conditional_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuntimeReconfigContent::unsafe_arena_set_allocated_insert_conditional_entry(::p4::v1::InsertConditionalEntry* insert_conditional_entry) {
  clear_content();
  if (insert_conditional_entry) {
    set_has_insert_conditional_entry();
    content_.insert_conditional_entry_ = insert_conditional_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.RuntimeReconfigContent.insert_conditional_entry)
}
inline ::p4::v1::InsertConditionalEntry* RuntimeReconfigContent::_internal_mutable_insert_conditional_entry() {
  if (!_internal_has_insert_conditional_entry()) {
    clear_content();
    set_has_insert_conditional_entry();
    content_.insert_conditional_entry_ = CreateMaybeMessage< ::p4::v1::InsertConditionalEntry >(GetArenaForAllocation());
  }
  return content_.insert_conditional_entry_;
}
inline ::p4::v1::InsertConditionalEntry* RuntimeReconfigContent::mutable_insert_conditional_entry() {
  ::p4::v1::InsertConditionalEntry* _msg = _internal_mutable_insert_conditional_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.RuntimeReconfigContent.insert_conditional_entry)
  return _msg;
}

// .p4.v1.ChangeConditionalEntry change_conditional_entry = 6;
inline bool RuntimeReconfigContent::_internal_has_change_conditional_entry() const {
  return content_case() == kChangeConditionalEntry;
}
inline bool RuntimeReconfigContent::has_change_conditional_entry() const {
  return _internal_has_change_conditional_entry();
}
inline void RuntimeReconfigContent::set_has_change_conditional_entry() {
  _oneof_case_[0] = kChangeConditionalEntry;
}
inline void RuntimeReconfigContent::clear_change_conditional_entry() {
  if (_internal_has_change_conditional_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete content_.change_conditional_entry_;
    }
    clear_has_content();
  }
}
inline ::p4::v1::ChangeConditionalEntry* RuntimeReconfigContent::release_change_conditional_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.RuntimeReconfigContent.change_conditional_entry)
  if (_internal_has_change_conditional_entry()) {
    clear_has_content();
      ::p4::v1::ChangeConditionalEntry* temp = content_.change_conditional_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    content_.change_conditional_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::ChangeConditionalEntry& RuntimeReconfigContent::_internal_change_conditional_entry() const {
  return _internal_has_change_conditional_entry()
      ? *content_.change_conditional_entry_
      : reinterpret_cast< ::p4::v1::ChangeConditionalEntry&>(::p4::v1::_ChangeConditionalEntry_default_instance_);
}
inline const ::p4::v1::ChangeConditionalEntry& RuntimeReconfigContent::change_conditional_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.RuntimeReconfigContent.change_conditional_entry)
  return _internal_change_conditional_entry();
}
inline ::p4::v1::ChangeConditionalEntry* RuntimeReconfigContent::unsafe_arena_release_change_conditional_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.RuntimeReconfigContent.change_conditional_entry)
  if (_internal_has_change_conditional_entry()) {
    clear_has_content();
    ::p4::v1::ChangeConditionalEntry* temp = content_.change_conditional_entry_;
    content_.change_conditional_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuntimeReconfigContent::unsafe_arena_set_allocated_change_conditional_entry(::p4::v1::ChangeConditionalEntry* change_conditional_entry) {
  clear_content();
  if (change_conditional_entry) {
    set_has_change_conditional_entry();
    content_.change_conditional_entry_ = change_conditional_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.RuntimeReconfigContent.change_conditional_entry)
}
inline ::p4::v1::ChangeConditionalEntry* RuntimeReconfigContent::_internal_mutable_change_conditional_entry() {
  if (!_internal_has_change_conditional_entry()) {
    clear_content();
    set_has_change_conditional_entry();
    content_.change_conditional_entry_ = CreateMaybeMessage< ::p4::v1::ChangeConditionalEntry >(GetArenaForAllocation());
  }
  return content_.change_conditional_entry_;
}
inline ::p4::v1::ChangeConditionalEntry* RuntimeReconfigContent::mutable_change_conditional_entry() {
  ::p4::v1::ChangeConditionalEntry* _msg = _internal_mutable_change_conditional_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.RuntimeReconfigContent.change_conditional_entry)
  return _msg;
}

// .p4.v1.DeleteConditionalEntry delete_conditional_entry = 7;
inline bool RuntimeReconfigContent::_internal_has_delete_conditional_entry() const {
  return content_case() == kDeleteConditionalEntry;
}
inline bool RuntimeReconfigContent::has_delete_conditional_entry() const {
  return _internal_has_delete_conditional_entry();
}
inline void RuntimeReconfigContent::set_has_delete_conditional_entry() {
  _oneof_case_[0] = kDeleteConditionalEntry;
}
inline void RuntimeReconfigContent::clear_delete_conditional_entry() {
  if (_internal_has_delete_conditional_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete content_.delete_conditional_entry_;
    }
    clear_has_content();
  }
}
inline ::p4::v1::DeleteConditionalEntry* RuntimeReconfigContent::release_delete_conditional_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.RuntimeReconfigContent.delete_conditional_entry)
  if (_internal_has_delete_conditional_entry()) {
    clear_has_content();
      ::p4::v1::DeleteConditionalEntry* temp = content_.delete_conditional_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    content_.delete_conditional_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::DeleteConditionalEntry& RuntimeReconfigContent::_internal_delete_conditional_entry() const {
  return _internal_has_delete_conditional_entry()
      ? *content_.delete_conditional_entry_
      : reinterpret_cast< ::p4::v1::DeleteConditionalEntry&>(::p4::v1::_DeleteConditionalEntry_default_instance_);
}
inline const ::p4::v1::DeleteConditionalEntry& RuntimeReconfigContent::delete_conditional_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.RuntimeReconfigContent.delete_conditional_entry)
  return _internal_delete_conditional_entry();
}
inline ::p4::v1::DeleteConditionalEntry* RuntimeReconfigContent::unsafe_arena_release_delete_conditional_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.RuntimeReconfigContent.delete_conditional_entry)
  if (_internal_has_delete_conditional_entry()) {
    clear_has_content();
    ::p4::v1::DeleteConditionalEntry* temp = content_.delete_conditional_entry_;
    content_.delete_conditional_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuntimeReconfigContent::unsafe_arena_set_allocated_delete_conditional_entry(::p4::v1::DeleteConditionalEntry* delete_conditional_entry) {
  clear_content();
  if (delete_conditional_entry) {
    set_has_delete_conditional_entry();
    content_.delete_conditional_entry_ = delete_conditional_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.RuntimeReconfigContent.delete_conditional_entry)
}
inline ::p4::v1::DeleteConditionalEntry* RuntimeReconfigContent::_internal_mutable_delete_conditional_entry() {
  if (!_internal_has_delete_conditional_entry()) {
    clear_content();
    set_has_delete_conditional_entry();
    content_.delete_conditional_entry_ = CreateMaybeMessage< ::p4::v1::DeleteConditionalEntry >(GetArenaForAllocation());
  }
  return content_.delete_conditional_entry_;
}
inline ::p4::v1::DeleteConditionalEntry* RuntimeReconfigContent::mutable_delete_conditional_entry() {
  ::p4::v1::DeleteConditionalEntry* _msg = _internal_mutable_delete_conditional_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.RuntimeReconfigContent.delete_conditional_entry)
  return _msg;
}

// .p4.v1.InsertFlexEntry insert_flex_entry = 8;
inline bool RuntimeReconfigContent::_internal_has_insert_flex_entry() const {
  return content_case() == kInsertFlexEntry;
}
inline bool RuntimeReconfigContent::has_insert_flex_entry() const {
  return _internal_has_insert_flex_entry();
}
inline void RuntimeReconfigContent::set_has_insert_flex_entry() {
  _oneof_case_[0] = kInsertFlexEntry;
}
inline void RuntimeReconfigContent::clear_insert_flex_entry() {
  if (_internal_has_insert_flex_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete content_.insert_flex_entry_;
    }
    clear_has_content();
  }
}
inline ::p4::v1::InsertFlexEntry* RuntimeReconfigContent::release_insert_flex_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.RuntimeReconfigContent.insert_flex_entry)
  if (_internal_has_insert_flex_entry()) {
    clear_has_content();
      ::p4::v1::InsertFlexEntry* temp = content_.insert_flex_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    content_.insert_flex_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::InsertFlexEntry& RuntimeReconfigContent::_internal_insert_flex_entry() const {
  return _internal_has_insert_flex_entry()
      ? *content_.insert_flex_entry_
      : reinterpret_cast< ::p4::v1::InsertFlexEntry&>(::p4::v1::_InsertFlexEntry_default_instance_);
}
inline const ::p4::v1::InsertFlexEntry& RuntimeReconfigContent::insert_flex_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.RuntimeReconfigContent.insert_flex_entry)
  return _internal_insert_flex_entry();
}
inline ::p4::v1::InsertFlexEntry* RuntimeReconfigContent::unsafe_arena_release_insert_flex_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.RuntimeReconfigContent.insert_flex_entry)
  if (_internal_has_insert_flex_entry()) {
    clear_has_content();
    ::p4::v1::InsertFlexEntry* temp = content_.insert_flex_entry_;
    content_.insert_flex_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuntimeReconfigContent::unsafe_arena_set_allocated_insert_flex_entry(::p4::v1::InsertFlexEntry* insert_flex_entry) {
  clear_content();
  if (insert_flex_entry) {
    set_has_insert_flex_entry();
    content_.insert_flex_entry_ = insert_flex_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.RuntimeReconfigContent.insert_flex_entry)
}
inline ::p4::v1::InsertFlexEntry* RuntimeReconfigContent::_internal_mutable_insert_flex_entry() {
  if (!_internal_has_insert_flex_entry()) {
    clear_content();
    set_has_insert_flex_entry();
    content_.insert_flex_entry_ = CreateMaybeMessage< ::p4::v1::InsertFlexEntry >(GetArenaForAllocation());
  }
  return content_.insert_flex_entry_;
}
inline ::p4::v1::InsertFlexEntry* RuntimeReconfigContent::mutable_insert_flex_entry() {
  ::p4::v1::InsertFlexEntry* _msg = _internal_mutable_insert_flex_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.RuntimeReconfigContent.insert_flex_entry)
  return _msg;
}

// .p4.v1.ChangeFlexEntry change_flex_entry = 9;
inline bool RuntimeReconfigContent::_internal_has_change_flex_entry() const {
  return content_case() == kChangeFlexEntry;
}
inline bool RuntimeReconfigContent::has_change_flex_entry() const {
  return _internal_has_change_flex_entry();
}
inline void RuntimeReconfigContent::set_has_change_flex_entry() {
  _oneof_case_[0] = kChangeFlexEntry;
}
inline void RuntimeReconfigContent::clear_change_flex_entry() {
  if (_internal_has_change_flex_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete content_.change_flex_entry_;
    }
    clear_has_content();
  }
}
inline ::p4::v1::ChangeFlexEntry* RuntimeReconfigContent::release_change_flex_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.RuntimeReconfigContent.change_flex_entry)
  if (_internal_has_change_flex_entry()) {
    clear_has_content();
      ::p4::v1::ChangeFlexEntry* temp = content_.change_flex_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    content_.change_flex_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::ChangeFlexEntry& RuntimeReconfigContent::_internal_change_flex_entry() const {
  return _internal_has_change_flex_entry()
      ? *content_.change_flex_entry_
      : reinterpret_cast< ::p4::v1::ChangeFlexEntry&>(::p4::v1::_ChangeFlexEntry_default_instance_);
}
inline const ::p4::v1::ChangeFlexEntry& RuntimeReconfigContent::change_flex_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.RuntimeReconfigContent.change_flex_entry)
  return _internal_change_flex_entry();
}
inline ::p4::v1::ChangeFlexEntry* RuntimeReconfigContent::unsafe_arena_release_change_flex_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.RuntimeReconfigContent.change_flex_entry)
  if (_internal_has_change_flex_entry()) {
    clear_has_content();
    ::p4::v1::ChangeFlexEntry* temp = content_.change_flex_entry_;
    content_.change_flex_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuntimeReconfigContent::unsafe_arena_set_allocated_change_flex_entry(::p4::v1::ChangeFlexEntry* change_flex_entry) {
  clear_content();
  if (change_flex_entry) {
    set_has_change_flex_entry();
    content_.change_flex_entry_ = change_flex_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.RuntimeReconfigContent.change_flex_entry)
}
inline ::p4::v1::ChangeFlexEntry* RuntimeReconfigContent::_internal_mutable_change_flex_entry() {
  if (!_internal_has_change_flex_entry()) {
    clear_content();
    set_has_change_flex_entry();
    content_.change_flex_entry_ = CreateMaybeMessage< ::p4::v1::ChangeFlexEntry >(GetArenaForAllocation());
  }
  return content_.change_flex_entry_;
}
inline ::p4::v1::ChangeFlexEntry* RuntimeReconfigContent::mutable_change_flex_entry() {
  ::p4::v1::ChangeFlexEntry* _msg = _internal_mutable_change_flex_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.RuntimeReconfigContent.change_flex_entry)
  return _msg;
}

// .p4.v1.DeleteFlexEntry delete_flex_entry = 10;
inline bool RuntimeReconfigContent::_internal_has_delete_flex_entry() const {
  return content_case() == kDeleteFlexEntry;
}
inline bool RuntimeReconfigContent::has_delete_flex_entry() const {
  return _internal_has_delete_flex_entry();
}
inline void RuntimeReconfigContent::set_has_delete_flex_entry() {
  _oneof_case_[0] = kDeleteFlexEntry;
}
inline void RuntimeReconfigContent::clear_delete_flex_entry() {
  if (_internal_has_delete_flex_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete content_.delete_flex_entry_;
    }
    clear_has_content();
  }
}
inline ::p4::v1::DeleteFlexEntry* RuntimeReconfigContent::release_delete_flex_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.RuntimeReconfigContent.delete_flex_entry)
  if (_internal_has_delete_flex_entry()) {
    clear_has_content();
      ::p4::v1::DeleteFlexEntry* temp = content_.delete_flex_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    content_.delete_flex_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::DeleteFlexEntry& RuntimeReconfigContent::_internal_delete_flex_entry() const {
  return _internal_has_delete_flex_entry()
      ? *content_.delete_flex_entry_
      : reinterpret_cast< ::p4::v1::DeleteFlexEntry&>(::p4::v1::_DeleteFlexEntry_default_instance_);
}
inline const ::p4::v1::DeleteFlexEntry& RuntimeReconfigContent::delete_flex_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.RuntimeReconfigContent.delete_flex_entry)
  return _internal_delete_flex_entry();
}
inline ::p4::v1::DeleteFlexEntry* RuntimeReconfigContent::unsafe_arena_release_delete_flex_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.RuntimeReconfigContent.delete_flex_entry)
  if (_internal_has_delete_flex_entry()) {
    clear_has_content();
    ::p4::v1::DeleteFlexEntry* temp = content_.delete_flex_entry_;
    content_.delete_flex_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuntimeReconfigContent::unsafe_arena_set_allocated_delete_flex_entry(::p4::v1::DeleteFlexEntry* delete_flex_entry) {
  clear_content();
  if (delete_flex_entry) {
    set_has_delete_flex_entry();
    content_.delete_flex_entry_ = delete_flex_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.RuntimeReconfigContent.delete_flex_entry)
}
inline ::p4::v1::DeleteFlexEntry* RuntimeReconfigContent::_internal_mutable_delete_flex_entry() {
  if (!_internal_has_delete_flex_entry()) {
    clear_content();
    set_has_delete_flex_entry();
    content_.delete_flex_entry_ = CreateMaybeMessage< ::p4::v1::DeleteFlexEntry >(GetArenaForAllocation());
  }
  return content_.delete_flex_entry_;
}
inline ::p4::v1::DeleteFlexEntry* RuntimeReconfigContent::mutable_delete_flex_entry() {
  ::p4::v1::DeleteFlexEntry* _msg = _internal_mutable_delete_flex_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.RuntimeReconfigContent.delete_flex_entry)
  return _msg;
}

// .p4.v1.InsertRegisterArrayEntry insert_register_array_entry = 11;
inline bool RuntimeReconfigContent::_internal_has_insert_register_array_entry() const {
  return content_case() == kInsertRegisterArrayEntry;
}
inline bool RuntimeReconfigContent::has_insert_register_array_entry() const {
  return _internal_has_insert_register_array_entry();
}
inline void RuntimeReconfigContent::set_has_insert_register_array_entry() {
  _oneof_case_[0] = kInsertRegisterArrayEntry;
}
inline void RuntimeReconfigContent::clear_insert_register_array_entry() {
  if (_internal_has_insert_register_array_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete content_.insert_register_array_entry_;
    }
    clear_has_content();
  }
}
inline ::p4::v1::InsertRegisterArrayEntry* RuntimeReconfigContent::release_insert_register_array_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.RuntimeReconfigContent.insert_register_array_entry)
  if (_internal_has_insert_register_array_entry()) {
    clear_has_content();
      ::p4::v1::InsertRegisterArrayEntry* temp = content_.insert_register_array_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    content_.insert_register_array_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::InsertRegisterArrayEntry& RuntimeReconfigContent::_internal_insert_register_array_entry() const {
  return _internal_has_insert_register_array_entry()
      ? *content_.insert_register_array_entry_
      : reinterpret_cast< ::p4::v1::InsertRegisterArrayEntry&>(::p4::v1::_InsertRegisterArrayEntry_default_instance_);
}
inline const ::p4::v1::InsertRegisterArrayEntry& RuntimeReconfigContent::insert_register_array_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.RuntimeReconfigContent.insert_register_array_entry)
  return _internal_insert_register_array_entry();
}
inline ::p4::v1::InsertRegisterArrayEntry* RuntimeReconfigContent::unsafe_arena_release_insert_register_array_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.RuntimeReconfigContent.insert_register_array_entry)
  if (_internal_has_insert_register_array_entry()) {
    clear_has_content();
    ::p4::v1::InsertRegisterArrayEntry* temp = content_.insert_register_array_entry_;
    content_.insert_register_array_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuntimeReconfigContent::unsafe_arena_set_allocated_insert_register_array_entry(::p4::v1::InsertRegisterArrayEntry* insert_register_array_entry) {
  clear_content();
  if (insert_register_array_entry) {
    set_has_insert_register_array_entry();
    content_.insert_register_array_entry_ = insert_register_array_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.RuntimeReconfigContent.insert_register_array_entry)
}
inline ::p4::v1::InsertRegisterArrayEntry* RuntimeReconfigContent::_internal_mutable_insert_register_array_entry() {
  if (!_internal_has_insert_register_array_entry()) {
    clear_content();
    set_has_insert_register_array_entry();
    content_.insert_register_array_entry_ = CreateMaybeMessage< ::p4::v1::InsertRegisterArrayEntry >(GetArenaForAllocation());
  }
  return content_.insert_register_array_entry_;
}
inline ::p4::v1::InsertRegisterArrayEntry* RuntimeReconfigContent::mutable_insert_register_array_entry() {
  ::p4::v1::InsertRegisterArrayEntry* _msg = _internal_mutable_insert_register_array_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.RuntimeReconfigContent.insert_register_array_entry)
  return _msg;
}

// .p4.v1.ChangeRegisterArrayEntry change_register_array_entry = 12;
inline bool RuntimeReconfigContent::_internal_has_change_register_array_entry() const {
  return content_case() == kChangeRegisterArrayEntry;
}
inline bool RuntimeReconfigContent::has_change_register_array_entry() const {
  return _internal_has_change_register_array_entry();
}
inline void RuntimeReconfigContent::set_has_change_register_array_entry() {
  _oneof_case_[0] = kChangeRegisterArrayEntry;
}
inline void RuntimeReconfigContent::clear_change_register_array_entry() {
  if (_internal_has_change_register_array_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete content_.change_register_array_entry_;
    }
    clear_has_content();
  }
}
inline ::p4::v1::ChangeRegisterArrayEntry* RuntimeReconfigContent::release_change_register_array_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.RuntimeReconfigContent.change_register_array_entry)
  if (_internal_has_change_register_array_entry()) {
    clear_has_content();
      ::p4::v1::ChangeRegisterArrayEntry* temp = content_.change_register_array_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    content_.change_register_array_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::ChangeRegisterArrayEntry& RuntimeReconfigContent::_internal_change_register_array_entry() const {
  return _internal_has_change_register_array_entry()
      ? *content_.change_register_array_entry_
      : reinterpret_cast< ::p4::v1::ChangeRegisterArrayEntry&>(::p4::v1::_ChangeRegisterArrayEntry_default_instance_);
}
inline const ::p4::v1::ChangeRegisterArrayEntry& RuntimeReconfigContent::change_register_array_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.RuntimeReconfigContent.change_register_array_entry)
  return _internal_change_register_array_entry();
}
inline ::p4::v1::ChangeRegisterArrayEntry* RuntimeReconfigContent::unsafe_arena_release_change_register_array_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.RuntimeReconfigContent.change_register_array_entry)
  if (_internal_has_change_register_array_entry()) {
    clear_has_content();
    ::p4::v1::ChangeRegisterArrayEntry* temp = content_.change_register_array_entry_;
    content_.change_register_array_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuntimeReconfigContent::unsafe_arena_set_allocated_change_register_array_entry(::p4::v1::ChangeRegisterArrayEntry* change_register_array_entry) {
  clear_content();
  if (change_register_array_entry) {
    set_has_change_register_array_entry();
    content_.change_register_array_entry_ = change_register_array_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.RuntimeReconfigContent.change_register_array_entry)
}
inline ::p4::v1::ChangeRegisterArrayEntry* RuntimeReconfigContent::_internal_mutable_change_register_array_entry() {
  if (!_internal_has_change_register_array_entry()) {
    clear_content();
    set_has_change_register_array_entry();
    content_.change_register_array_entry_ = CreateMaybeMessage< ::p4::v1::ChangeRegisterArrayEntry >(GetArenaForAllocation());
  }
  return content_.change_register_array_entry_;
}
inline ::p4::v1::ChangeRegisterArrayEntry* RuntimeReconfigContent::mutable_change_register_array_entry() {
  ::p4::v1::ChangeRegisterArrayEntry* _msg = _internal_mutable_change_register_array_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.RuntimeReconfigContent.change_register_array_entry)
  return _msg;
}

// .p4.v1.DeleteRegisterArrayEntry delete_register_array_entry = 13;
inline bool RuntimeReconfigContent::_internal_has_delete_register_array_entry() const {
  return content_case() == kDeleteRegisterArrayEntry;
}
inline bool RuntimeReconfigContent::has_delete_register_array_entry() const {
  return _internal_has_delete_register_array_entry();
}
inline void RuntimeReconfigContent::set_has_delete_register_array_entry() {
  _oneof_case_[0] = kDeleteRegisterArrayEntry;
}
inline void RuntimeReconfigContent::clear_delete_register_array_entry() {
  if (_internal_has_delete_register_array_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete content_.delete_register_array_entry_;
    }
    clear_has_content();
  }
}
inline ::p4::v1::DeleteRegisterArrayEntry* RuntimeReconfigContent::release_delete_register_array_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.RuntimeReconfigContent.delete_register_array_entry)
  if (_internal_has_delete_register_array_entry()) {
    clear_has_content();
      ::p4::v1::DeleteRegisterArrayEntry* temp = content_.delete_register_array_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    content_.delete_register_array_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::DeleteRegisterArrayEntry& RuntimeReconfigContent::_internal_delete_register_array_entry() const {
  return _internal_has_delete_register_array_entry()
      ? *content_.delete_register_array_entry_
      : reinterpret_cast< ::p4::v1::DeleteRegisterArrayEntry&>(::p4::v1::_DeleteRegisterArrayEntry_default_instance_);
}
inline const ::p4::v1::DeleteRegisterArrayEntry& RuntimeReconfigContent::delete_register_array_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.RuntimeReconfigContent.delete_register_array_entry)
  return _internal_delete_register_array_entry();
}
inline ::p4::v1::DeleteRegisterArrayEntry* RuntimeReconfigContent::unsafe_arena_release_delete_register_array_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.RuntimeReconfigContent.delete_register_array_entry)
  if (_internal_has_delete_register_array_entry()) {
    clear_has_content();
    ::p4::v1::DeleteRegisterArrayEntry* temp = content_.delete_register_array_entry_;
    content_.delete_register_array_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuntimeReconfigContent::unsafe_arena_set_allocated_delete_register_array_entry(::p4::v1::DeleteRegisterArrayEntry* delete_register_array_entry) {
  clear_content();
  if (delete_register_array_entry) {
    set_has_delete_register_array_entry();
    content_.delete_register_array_entry_ = delete_register_array_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.RuntimeReconfigContent.delete_register_array_entry)
}
inline ::p4::v1::DeleteRegisterArrayEntry* RuntimeReconfigContent::_internal_mutable_delete_register_array_entry() {
  if (!_internal_has_delete_register_array_entry()) {
    clear_content();
    set_has_delete_register_array_entry();
    content_.delete_register_array_entry_ = CreateMaybeMessage< ::p4::v1::DeleteRegisterArrayEntry >(GetArenaForAllocation());
  }
  return content_.delete_register_array_entry_;
}
inline ::p4::v1::DeleteRegisterArrayEntry* RuntimeReconfigContent::mutable_delete_register_array_entry() {
  ::p4::v1::DeleteRegisterArrayEntry* _msg = _internal_mutable_delete_register_array_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.RuntimeReconfigContent.delete_register_array_entry)
  return _msg;
}

// .p4.v1.TriggerEntry trigger_entry = 14;
inline bool RuntimeReconfigContent::_internal_has_trigger_entry() const {
  return content_case() == kTriggerEntry;
}
inline bool RuntimeReconfigContent::has_trigger_entry() const {
  return _internal_has_trigger_entry();
}
inline void RuntimeReconfigContent::set_has_trigger_entry() {
  _oneof_case_[0] = kTriggerEntry;
}
inline void RuntimeReconfigContent::clear_trigger_entry() {
  if (_internal_has_trigger_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete content_.trigger_entry_;
    }
    clear_has_content();
  }
}
inline ::p4::v1::TriggerEntry* RuntimeReconfigContent::release_trigger_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.RuntimeReconfigContent.trigger_entry)
  if (_internal_has_trigger_entry()) {
    clear_has_content();
      ::p4::v1::TriggerEntry* temp = content_.trigger_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    content_.trigger_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::TriggerEntry& RuntimeReconfigContent::_internal_trigger_entry() const {
  return _internal_has_trigger_entry()
      ? *content_.trigger_entry_
      : reinterpret_cast< ::p4::v1::TriggerEntry&>(::p4::v1::_TriggerEntry_default_instance_);
}
inline const ::p4::v1::TriggerEntry& RuntimeReconfigContent::trigger_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.RuntimeReconfigContent.trigger_entry)
  return _internal_trigger_entry();
}
inline ::p4::v1::TriggerEntry* RuntimeReconfigContent::unsafe_arena_release_trigger_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.RuntimeReconfigContent.trigger_entry)
  if (_internal_has_trigger_entry()) {
    clear_has_content();
    ::p4::v1::TriggerEntry* temp = content_.trigger_entry_;
    content_.trigger_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuntimeReconfigContent::unsafe_arena_set_allocated_trigger_entry(::p4::v1::TriggerEntry* trigger_entry) {
  clear_content();
  if (trigger_entry) {
    set_has_trigger_entry();
    content_.trigger_entry_ = trigger_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.RuntimeReconfigContent.trigger_entry)
}
inline ::p4::v1::TriggerEntry* RuntimeReconfigContent::_internal_mutable_trigger_entry() {
  if (!_internal_has_trigger_entry()) {
    clear_content();
    set_has_trigger_entry();
    content_.trigger_entry_ = CreateMaybeMessage< ::p4::v1::TriggerEntry >(GetArenaForAllocation());
  }
  return content_.trigger_entry_;
}
inline ::p4::v1::TriggerEntry* RuntimeReconfigContent::mutable_trigger_entry() {
  ::p4::v1::TriggerEntry* _msg = _internal_mutable_trigger_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.RuntimeReconfigContent.trigger_entry)
  return _msg;
}

// .p4.v1.ChangeInitEntry change_init_entry = 15;
inline bool RuntimeReconfigContent::_internal_has_change_init_entry() const {
  return content_case() == kChangeInitEntry;
}
inline bool RuntimeReconfigContent::has_change_init_entry() const {
  return _internal_has_change_init_entry();
}
inline void RuntimeReconfigContent::set_has_change_init_entry() {
  _oneof_case_[0] = kChangeInitEntry;
}
inline void RuntimeReconfigContent::clear_change_init_entry() {
  if (_internal_has_change_init_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete content_.change_init_entry_;
    }
    clear_has_content();
  }
}
inline ::p4::v1::ChangeInitEntry* RuntimeReconfigContent::release_change_init_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.RuntimeReconfigContent.change_init_entry)
  if (_internal_has_change_init_entry()) {
    clear_has_content();
      ::p4::v1::ChangeInitEntry* temp = content_.change_init_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    content_.change_init_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::ChangeInitEntry& RuntimeReconfigContent::_internal_change_init_entry() const {
  return _internal_has_change_init_entry()
      ? *content_.change_init_entry_
      : reinterpret_cast< ::p4::v1::ChangeInitEntry&>(::p4::v1::_ChangeInitEntry_default_instance_);
}
inline const ::p4::v1::ChangeInitEntry& RuntimeReconfigContent::change_init_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.RuntimeReconfigContent.change_init_entry)
  return _internal_change_init_entry();
}
inline ::p4::v1::ChangeInitEntry* RuntimeReconfigContent::unsafe_arena_release_change_init_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.RuntimeReconfigContent.change_init_entry)
  if (_internal_has_change_init_entry()) {
    clear_has_content();
    ::p4::v1::ChangeInitEntry* temp = content_.change_init_entry_;
    content_.change_init_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuntimeReconfigContent::unsafe_arena_set_allocated_change_init_entry(::p4::v1::ChangeInitEntry* change_init_entry) {
  clear_content();
  if (change_init_entry) {
    set_has_change_init_entry();
    content_.change_init_entry_ = change_init_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.RuntimeReconfigContent.change_init_entry)
}
inline ::p4::v1::ChangeInitEntry* RuntimeReconfigContent::_internal_mutable_change_init_entry() {
  if (!_internal_has_change_init_entry()) {
    clear_content();
    set_has_change_init_entry();
    content_.change_init_entry_ = CreateMaybeMessage< ::p4::v1::ChangeInitEntry >(GetArenaForAllocation());
  }
  return content_.change_init_entry_;
}
inline ::p4::v1::ChangeInitEntry* RuntimeReconfigContent::mutable_change_init_entry() {
  ::p4::v1::ChangeInitEntry* _msg = _internal_mutable_change_init_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.RuntimeReconfigContent.change_init_entry)
  return _msg;
}

inline bool RuntimeReconfigContent::has_content() const {
  return content_case() != CONTENT_NOT_SET;
}
inline void RuntimeReconfigContent::clear_has_content() {
  _oneof_case_[0] = CONTENT_NOT_SET;
}
inline RuntimeReconfigContent::ContentCase RuntimeReconfigContent::content_case() const {
  return RuntimeReconfigContent::ContentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InitP4ObjectsNewEntry

// bytes p4objects_new_json = 1;
inline void InitP4ObjectsNewEntry::clear_p4objects_new_json() {
  p4objects_new_json_.ClearToEmpty();
}
inline const std::string& InitP4ObjectsNewEntry::p4objects_new_json() const {
  // @@protoc_insertion_point(field_get:p4.v1.InitP4ObjectsNewEntry.p4objects_new_json)
  return _internal_p4objects_new_json();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitP4ObjectsNewEntry::set_p4objects_new_json(ArgT0&& arg0, ArgT... args) {
 
 p4objects_new_json_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.InitP4ObjectsNewEntry.p4objects_new_json)
}
inline std::string* InitP4ObjectsNewEntry::mutable_p4objects_new_json() {
  std::string* _s = _internal_mutable_p4objects_new_json();
  // @@protoc_insertion_point(field_mutable:p4.v1.InitP4ObjectsNewEntry.p4objects_new_json)
  return _s;
}
inline const std::string& InitP4ObjectsNewEntry::_internal_p4objects_new_json() const {
  return p4objects_new_json_.Get();
}
inline void InitP4ObjectsNewEntry::_internal_set_p4objects_new_json(const std::string& value) {
  
  p4objects_new_json_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InitP4ObjectsNewEntry::_internal_mutable_p4objects_new_json() {
  
  return p4objects_new_json_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InitP4ObjectsNewEntry::release_p4objects_new_json() {
  // @@protoc_insertion_point(field_release:p4.v1.InitP4ObjectsNewEntry.p4objects_new_json)
  return p4objects_new_json_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InitP4ObjectsNewEntry::set_allocated_p4objects_new_json(std::string* p4objects_new_json) {
  if (p4objects_new_json != nullptr) {
    
  } else {
    
  }
  p4objects_new_json_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), p4objects_new_json,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.InitP4ObjectsNewEntry.p4objects_new_json)
}

// -------------------------------------------------------------------

// InsertTableEntry

// string pipeline_name = 1;
inline void InsertTableEntry::clear_pipeline_name() {
  pipeline_name_.ClearToEmpty();
}
inline const std::string& InsertTableEntry::pipeline_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.InsertTableEntry.pipeline_name)
  return _internal_pipeline_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertTableEntry::set_pipeline_name(ArgT0&& arg0, ArgT... args) {
 
 pipeline_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.InsertTableEntry.pipeline_name)
}
inline std::string* InsertTableEntry::mutable_pipeline_name() {
  std::string* _s = _internal_mutable_pipeline_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.InsertTableEntry.pipeline_name)
  return _s;
}
inline const std::string& InsertTableEntry::_internal_pipeline_name() const {
  return pipeline_name_.Get();
}
inline void InsertTableEntry::_internal_set_pipeline_name(const std::string& value) {
  
  pipeline_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InsertTableEntry::_internal_mutable_pipeline_name() {
  
  return pipeline_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InsertTableEntry::release_pipeline_name() {
  // @@protoc_insertion_point(field_release:p4.v1.InsertTableEntry.pipeline_name)
  return pipeline_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InsertTableEntry::set_allocated_pipeline_name(std::string* pipeline_name) {
  if (pipeline_name != nullptr) {
    
  } else {
    
  }
  pipeline_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pipeline_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.InsertTableEntry.pipeline_name)
}

// string table_name = 2;
inline void InsertTableEntry::clear_table_name() {
  table_name_.ClearToEmpty();
}
inline const std::string& InsertTableEntry::table_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.InsertTableEntry.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertTableEntry::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.InsertTableEntry.table_name)
}
inline std::string* InsertTableEntry::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.InsertTableEntry.table_name)
  return _s;
}
inline const std::string& InsertTableEntry::_internal_table_name() const {
  return table_name_.Get();
}
inline void InsertTableEntry::_internal_set_table_name(const std::string& value) {
  
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InsertTableEntry::_internal_mutable_table_name() {
  
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InsertTableEntry::release_table_name() {
  // @@protoc_insertion_point(field_release:p4.v1.InsertTableEntry.table_name)
  return table_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InsertTableEntry::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.InsertTableEntry.table_name)
}

// -------------------------------------------------------------------

// ChangeTableEntry

// string pipeline_name = 1;
inline void ChangeTableEntry::clear_pipeline_name() {
  pipeline_name_.ClearToEmpty();
}
inline const std::string& ChangeTableEntry::pipeline_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.ChangeTableEntry.pipeline_name)
  return _internal_pipeline_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeTableEntry::set_pipeline_name(ArgT0&& arg0, ArgT... args) {
 
 pipeline_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.ChangeTableEntry.pipeline_name)
}
inline std::string* ChangeTableEntry::mutable_pipeline_name() {
  std::string* _s = _internal_mutable_pipeline_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.ChangeTableEntry.pipeline_name)
  return _s;
}
inline const std::string& ChangeTableEntry::_internal_pipeline_name() const {
  return pipeline_name_.Get();
}
inline void ChangeTableEntry::_internal_set_pipeline_name(const std::string& value) {
  
  pipeline_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeTableEntry::_internal_mutable_pipeline_name() {
  
  return pipeline_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeTableEntry::release_pipeline_name() {
  // @@protoc_insertion_point(field_release:p4.v1.ChangeTableEntry.pipeline_name)
  return pipeline_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeTableEntry::set_allocated_pipeline_name(std::string* pipeline_name) {
  if (pipeline_name != nullptr) {
    
  } else {
    
  }
  pipeline_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pipeline_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.ChangeTableEntry.pipeline_name)
}

// string table_name = 2;
inline void ChangeTableEntry::clear_table_name() {
  table_name_.ClearToEmpty();
}
inline const std::string& ChangeTableEntry::table_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.ChangeTableEntry.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeTableEntry::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.ChangeTableEntry.table_name)
}
inline std::string* ChangeTableEntry::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.ChangeTableEntry.table_name)
  return _s;
}
inline const std::string& ChangeTableEntry::_internal_table_name() const {
  return table_name_.Get();
}
inline void ChangeTableEntry::_internal_set_table_name(const std::string& value) {
  
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeTableEntry::_internal_mutable_table_name() {
  
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeTableEntry::release_table_name() {
  // @@protoc_insertion_point(field_release:p4.v1.ChangeTableEntry.table_name)
  return table_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeTableEntry::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.ChangeTableEntry.table_name)
}

// string edge_name = 3;
inline void ChangeTableEntry::clear_edge_name() {
  edge_name_.ClearToEmpty();
}
inline const std::string& ChangeTableEntry::edge_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.ChangeTableEntry.edge_name)
  return _internal_edge_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeTableEntry::set_edge_name(ArgT0&& arg0, ArgT... args) {
 
 edge_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.ChangeTableEntry.edge_name)
}
inline std::string* ChangeTableEntry::mutable_edge_name() {
  std::string* _s = _internal_mutable_edge_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.ChangeTableEntry.edge_name)
  return _s;
}
inline const std::string& ChangeTableEntry::_internal_edge_name() const {
  return edge_name_.Get();
}
inline void ChangeTableEntry::_internal_set_edge_name(const std::string& value) {
  
  edge_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeTableEntry::_internal_mutable_edge_name() {
  
  return edge_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeTableEntry::release_edge_name() {
  // @@protoc_insertion_point(field_release:p4.v1.ChangeTableEntry.edge_name)
  return edge_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeTableEntry::set_allocated_edge_name(std::string* edge_name) {
  if (edge_name != nullptr) {
    
  } else {
    
  }
  edge_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), edge_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.ChangeTableEntry.edge_name)
}

// string table_name_next = 4;
inline void ChangeTableEntry::clear_table_name_next() {
  table_name_next_.ClearToEmpty();
}
inline const std::string& ChangeTableEntry::table_name_next() const {
  // @@protoc_insertion_point(field_get:p4.v1.ChangeTableEntry.table_name_next)
  return _internal_table_name_next();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeTableEntry::set_table_name_next(ArgT0&& arg0, ArgT... args) {
 
 table_name_next_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.ChangeTableEntry.table_name_next)
}
inline std::string* ChangeTableEntry::mutable_table_name_next() {
  std::string* _s = _internal_mutable_table_name_next();
  // @@protoc_insertion_point(field_mutable:p4.v1.ChangeTableEntry.table_name_next)
  return _s;
}
inline const std::string& ChangeTableEntry::_internal_table_name_next() const {
  return table_name_next_.Get();
}
inline void ChangeTableEntry::_internal_set_table_name_next(const std::string& value) {
  
  table_name_next_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeTableEntry::_internal_mutable_table_name_next() {
  
  return table_name_next_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeTableEntry::release_table_name_next() {
  // @@protoc_insertion_point(field_release:p4.v1.ChangeTableEntry.table_name_next)
  return table_name_next_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeTableEntry::set_allocated_table_name_next(std::string* table_name_next) {
  if (table_name_next != nullptr) {
    
  } else {
    
  }
  table_name_next_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name_next,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.ChangeTableEntry.table_name_next)
}

// -------------------------------------------------------------------

// DeleteTableEntry

// string pipeline_name = 1;
inline void DeleteTableEntry::clear_pipeline_name() {
  pipeline_name_.ClearToEmpty();
}
inline const std::string& DeleteTableEntry::pipeline_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.DeleteTableEntry.pipeline_name)
  return _internal_pipeline_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteTableEntry::set_pipeline_name(ArgT0&& arg0, ArgT... args) {
 
 pipeline_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.DeleteTableEntry.pipeline_name)
}
inline std::string* DeleteTableEntry::mutable_pipeline_name() {
  std::string* _s = _internal_mutable_pipeline_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.DeleteTableEntry.pipeline_name)
  return _s;
}
inline const std::string& DeleteTableEntry::_internal_pipeline_name() const {
  return pipeline_name_.Get();
}
inline void DeleteTableEntry::_internal_set_pipeline_name(const std::string& value) {
  
  pipeline_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteTableEntry::_internal_mutable_pipeline_name() {
  
  return pipeline_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteTableEntry::release_pipeline_name() {
  // @@protoc_insertion_point(field_release:p4.v1.DeleteTableEntry.pipeline_name)
  return pipeline_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteTableEntry::set_allocated_pipeline_name(std::string* pipeline_name) {
  if (pipeline_name != nullptr) {
    
  } else {
    
  }
  pipeline_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pipeline_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.DeleteTableEntry.pipeline_name)
}

// string table_name = 2;
inline void DeleteTableEntry::clear_table_name() {
  table_name_.ClearToEmpty();
}
inline const std::string& DeleteTableEntry::table_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.DeleteTableEntry.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteTableEntry::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.DeleteTableEntry.table_name)
}
inline std::string* DeleteTableEntry::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.DeleteTableEntry.table_name)
  return _s;
}
inline const std::string& DeleteTableEntry::_internal_table_name() const {
  return table_name_.Get();
}
inline void DeleteTableEntry::_internal_set_table_name(const std::string& value) {
  
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteTableEntry::_internal_mutable_table_name() {
  
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteTableEntry::release_table_name() {
  // @@protoc_insertion_point(field_release:p4.v1.DeleteTableEntry.table_name)
  return table_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteTableEntry::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.DeleteTableEntry.table_name)
}

// -------------------------------------------------------------------

// InsertConditionalEntry

// string pipeline_name = 1;
inline void InsertConditionalEntry::clear_pipeline_name() {
  pipeline_name_.ClearToEmpty();
}
inline const std::string& InsertConditionalEntry::pipeline_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.InsertConditionalEntry.pipeline_name)
  return _internal_pipeline_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertConditionalEntry::set_pipeline_name(ArgT0&& arg0, ArgT... args) {
 
 pipeline_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.InsertConditionalEntry.pipeline_name)
}
inline std::string* InsertConditionalEntry::mutable_pipeline_name() {
  std::string* _s = _internal_mutable_pipeline_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.InsertConditionalEntry.pipeline_name)
  return _s;
}
inline const std::string& InsertConditionalEntry::_internal_pipeline_name() const {
  return pipeline_name_.Get();
}
inline void InsertConditionalEntry::_internal_set_pipeline_name(const std::string& value) {
  
  pipeline_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InsertConditionalEntry::_internal_mutable_pipeline_name() {
  
  return pipeline_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InsertConditionalEntry::release_pipeline_name() {
  // @@protoc_insertion_point(field_release:p4.v1.InsertConditionalEntry.pipeline_name)
  return pipeline_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InsertConditionalEntry::set_allocated_pipeline_name(std::string* pipeline_name) {
  if (pipeline_name != nullptr) {
    
  } else {
    
  }
  pipeline_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pipeline_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.InsertConditionalEntry.pipeline_name)
}

// string branch_name = 2;
inline void InsertConditionalEntry::clear_branch_name() {
  branch_name_.ClearToEmpty();
}
inline const std::string& InsertConditionalEntry::branch_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.InsertConditionalEntry.branch_name)
  return _internal_branch_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertConditionalEntry::set_branch_name(ArgT0&& arg0, ArgT... args) {
 
 branch_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.InsertConditionalEntry.branch_name)
}
inline std::string* InsertConditionalEntry::mutable_branch_name() {
  std::string* _s = _internal_mutable_branch_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.InsertConditionalEntry.branch_name)
  return _s;
}
inline const std::string& InsertConditionalEntry::_internal_branch_name() const {
  return branch_name_.Get();
}
inline void InsertConditionalEntry::_internal_set_branch_name(const std::string& value) {
  
  branch_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InsertConditionalEntry::_internal_mutable_branch_name() {
  
  return branch_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InsertConditionalEntry::release_branch_name() {
  // @@protoc_insertion_point(field_release:p4.v1.InsertConditionalEntry.branch_name)
  return branch_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InsertConditionalEntry::set_allocated_branch_name(std::string* branch_name) {
  if (branch_name != nullptr) {
    
  } else {
    
  }
  branch_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), branch_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.InsertConditionalEntry.branch_name)
}

// -------------------------------------------------------------------

// ChangeConditionalEntry

// string pipeline_name = 1;
inline void ChangeConditionalEntry::clear_pipeline_name() {
  pipeline_name_.ClearToEmpty();
}
inline const std::string& ChangeConditionalEntry::pipeline_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.ChangeConditionalEntry.pipeline_name)
  return _internal_pipeline_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeConditionalEntry::set_pipeline_name(ArgT0&& arg0, ArgT... args) {
 
 pipeline_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.ChangeConditionalEntry.pipeline_name)
}
inline std::string* ChangeConditionalEntry::mutable_pipeline_name() {
  std::string* _s = _internal_mutable_pipeline_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.ChangeConditionalEntry.pipeline_name)
  return _s;
}
inline const std::string& ChangeConditionalEntry::_internal_pipeline_name() const {
  return pipeline_name_.Get();
}
inline void ChangeConditionalEntry::_internal_set_pipeline_name(const std::string& value) {
  
  pipeline_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeConditionalEntry::_internal_mutable_pipeline_name() {
  
  return pipeline_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeConditionalEntry::release_pipeline_name() {
  // @@protoc_insertion_point(field_release:p4.v1.ChangeConditionalEntry.pipeline_name)
  return pipeline_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeConditionalEntry::set_allocated_pipeline_name(std::string* pipeline_name) {
  if (pipeline_name != nullptr) {
    
  } else {
    
  }
  pipeline_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pipeline_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.ChangeConditionalEntry.pipeline_name)
}

// string branch_name = 2;
inline void ChangeConditionalEntry::clear_branch_name() {
  branch_name_.ClearToEmpty();
}
inline const std::string& ChangeConditionalEntry::branch_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.ChangeConditionalEntry.branch_name)
  return _internal_branch_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeConditionalEntry::set_branch_name(ArgT0&& arg0, ArgT... args) {
 
 branch_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.ChangeConditionalEntry.branch_name)
}
inline std::string* ChangeConditionalEntry::mutable_branch_name() {
  std::string* _s = _internal_mutable_branch_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.ChangeConditionalEntry.branch_name)
  return _s;
}
inline const std::string& ChangeConditionalEntry::_internal_branch_name() const {
  return branch_name_.Get();
}
inline void ChangeConditionalEntry::_internal_set_branch_name(const std::string& value) {
  
  branch_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeConditionalEntry::_internal_mutable_branch_name() {
  
  return branch_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeConditionalEntry::release_branch_name() {
  // @@protoc_insertion_point(field_release:p4.v1.ChangeConditionalEntry.branch_name)
  return branch_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeConditionalEntry::set_allocated_branch_name(std::string* branch_name) {
  if (branch_name != nullptr) {
    
  } else {
    
  }
  branch_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), branch_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.ChangeConditionalEntry.branch_name)
}

// bool true_or_false_next = 3;
inline void ChangeConditionalEntry::clear_true_or_false_next() {
  true_or_false_next_ = false;
}
inline bool ChangeConditionalEntry::_internal_true_or_false_next() const {
  return true_or_false_next_;
}
inline bool ChangeConditionalEntry::true_or_false_next() const {
  // @@protoc_insertion_point(field_get:p4.v1.ChangeConditionalEntry.true_or_false_next)
  return _internal_true_or_false_next();
}
inline void ChangeConditionalEntry::_internal_set_true_or_false_next(bool value) {
  
  true_or_false_next_ = value;
}
inline void ChangeConditionalEntry::set_true_or_false_next(bool value) {
  _internal_set_true_or_false_next(value);
  // @@protoc_insertion_point(field_set:p4.v1.ChangeConditionalEntry.true_or_false_next)
}

// string node_name = 4;
inline void ChangeConditionalEntry::clear_node_name() {
  node_name_.ClearToEmpty();
}
inline const std::string& ChangeConditionalEntry::node_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.ChangeConditionalEntry.node_name)
  return _internal_node_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeConditionalEntry::set_node_name(ArgT0&& arg0, ArgT... args) {
 
 node_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.ChangeConditionalEntry.node_name)
}
inline std::string* ChangeConditionalEntry::mutable_node_name() {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.ChangeConditionalEntry.node_name)
  return _s;
}
inline const std::string& ChangeConditionalEntry::_internal_node_name() const {
  return node_name_.Get();
}
inline void ChangeConditionalEntry::_internal_set_node_name(const std::string& value) {
  
  node_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeConditionalEntry::_internal_mutable_node_name() {
  
  return node_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeConditionalEntry::release_node_name() {
  // @@protoc_insertion_point(field_release:p4.v1.ChangeConditionalEntry.node_name)
  return node_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeConditionalEntry::set_allocated_node_name(std::string* node_name) {
  if (node_name != nullptr) {
    
  } else {
    
  }
  node_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.ChangeConditionalEntry.node_name)
}

// -------------------------------------------------------------------

// DeleteConditionalEntry

// string pipeline_name = 1;
inline void DeleteConditionalEntry::clear_pipeline_name() {
  pipeline_name_.ClearToEmpty();
}
inline const std::string& DeleteConditionalEntry::pipeline_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.DeleteConditionalEntry.pipeline_name)
  return _internal_pipeline_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteConditionalEntry::set_pipeline_name(ArgT0&& arg0, ArgT... args) {
 
 pipeline_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.DeleteConditionalEntry.pipeline_name)
}
inline std::string* DeleteConditionalEntry::mutable_pipeline_name() {
  std::string* _s = _internal_mutable_pipeline_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.DeleteConditionalEntry.pipeline_name)
  return _s;
}
inline const std::string& DeleteConditionalEntry::_internal_pipeline_name() const {
  return pipeline_name_.Get();
}
inline void DeleteConditionalEntry::_internal_set_pipeline_name(const std::string& value) {
  
  pipeline_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteConditionalEntry::_internal_mutable_pipeline_name() {
  
  return pipeline_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteConditionalEntry::release_pipeline_name() {
  // @@protoc_insertion_point(field_release:p4.v1.DeleteConditionalEntry.pipeline_name)
  return pipeline_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteConditionalEntry::set_allocated_pipeline_name(std::string* pipeline_name) {
  if (pipeline_name != nullptr) {
    
  } else {
    
  }
  pipeline_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pipeline_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.DeleteConditionalEntry.pipeline_name)
}

// string branch_name = 2;
inline void DeleteConditionalEntry::clear_branch_name() {
  branch_name_.ClearToEmpty();
}
inline const std::string& DeleteConditionalEntry::branch_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.DeleteConditionalEntry.branch_name)
  return _internal_branch_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteConditionalEntry::set_branch_name(ArgT0&& arg0, ArgT... args) {
 
 branch_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.DeleteConditionalEntry.branch_name)
}
inline std::string* DeleteConditionalEntry::mutable_branch_name() {
  std::string* _s = _internal_mutable_branch_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.DeleteConditionalEntry.branch_name)
  return _s;
}
inline const std::string& DeleteConditionalEntry::_internal_branch_name() const {
  return branch_name_.Get();
}
inline void DeleteConditionalEntry::_internal_set_branch_name(const std::string& value) {
  
  branch_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteConditionalEntry::_internal_mutable_branch_name() {
  
  return branch_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteConditionalEntry::release_branch_name() {
  // @@protoc_insertion_point(field_release:p4.v1.DeleteConditionalEntry.branch_name)
  return branch_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteConditionalEntry::set_allocated_branch_name(std::string* branch_name) {
  if (branch_name != nullptr) {
    
  } else {
    
  }
  branch_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), branch_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.DeleteConditionalEntry.branch_name)
}

// -------------------------------------------------------------------

// InsertFlexEntry

// string pipeline_name = 1;
inline void InsertFlexEntry::clear_pipeline_name() {
  pipeline_name_.ClearToEmpty();
}
inline const std::string& InsertFlexEntry::pipeline_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.InsertFlexEntry.pipeline_name)
  return _internal_pipeline_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertFlexEntry::set_pipeline_name(ArgT0&& arg0, ArgT... args) {
 
 pipeline_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.InsertFlexEntry.pipeline_name)
}
inline std::string* InsertFlexEntry::mutable_pipeline_name() {
  std::string* _s = _internal_mutable_pipeline_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.InsertFlexEntry.pipeline_name)
  return _s;
}
inline const std::string& InsertFlexEntry::_internal_pipeline_name() const {
  return pipeline_name_.Get();
}
inline void InsertFlexEntry::_internal_set_pipeline_name(const std::string& value) {
  
  pipeline_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InsertFlexEntry::_internal_mutable_pipeline_name() {
  
  return pipeline_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InsertFlexEntry::release_pipeline_name() {
  // @@protoc_insertion_point(field_release:p4.v1.InsertFlexEntry.pipeline_name)
  return pipeline_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InsertFlexEntry::set_allocated_pipeline_name(std::string* pipeline_name) {
  if (pipeline_name != nullptr) {
    
  } else {
    
  }
  pipeline_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pipeline_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.InsertFlexEntry.pipeline_name)
}

// string node_name = 2;
inline void InsertFlexEntry::clear_node_name() {
  node_name_.ClearToEmpty();
}
inline const std::string& InsertFlexEntry::node_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.InsertFlexEntry.node_name)
  return _internal_node_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertFlexEntry::set_node_name(ArgT0&& arg0, ArgT... args) {
 
 node_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.InsertFlexEntry.node_name)
}
inline std::string* InsertFlexEntry::mutable_node_name() {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.InsertFlexEntry.node_name)
  return _s;
}
inline const std::string& InsertFlexEntry::_internal_node_name() const {
  return node_name_.Get();
}
inline void InsertFlexEntry::_internal_set_node_name(const std::string& value) {
  
  node_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InsertFlexEntry::_internal_mutable_node_name() {
  
  return node_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InsertFlexEntry::release_node_name() {
  // @@protoc_insertion_point(field_release:p4.v1.InsertFlexEntry.node_name)
  return node_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InsertFlexEntry::set_allocated_node_name(std::string* node_name) {
  if (node_name != nullptr) {
    
  } else {
    
  }
  node_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.InsertFlexEntry.node_name)
}

// string true_next_node = 3;
inline void InsertFlexEntry::clear_true_next_node() {
  true_next_node_.ClearToEmpty();
}
inline const std::string& InsertFlexEntry::true_next_node() const {
  // @@protoc_insertion_point(field_get:p4.v1.InsertFlexEntry.true_next_node)
  return _internal_true_next_node();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertFlexEntry::set_true_next_node(ArgT0&& arg0, ArgT... args) {
 
 true_next_node_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.InsertFlexEntry.true_next_node)
}
inline std::string* InsertFlexEntry::mutable_true_next_node() {
  std::string* _s = _internal_mutable_true_next_node();
  // @@protoc_insertion_point(field_mutable:p4.v1.InsertFlexEntry.true_next_node)
  return _s;
}
inline const std::string& InsertFlexEntry::_internal_true_next_node() const {
  return true_next_node_.Get();
}
inline void InsertFlexEntry::_internal_set_true_next_node(const std::string& value) {
  
  true_next_node_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InsertFlexEntry::_internal_mutable_true_next_node() {
  
  return true_next_node_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InsertFlexEntry::release_true_next_node() {
  // @@protoc_insertion_point(field_release:p4.v1.InsertFlexEntry.true_next_node)
  return true_next_node_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InsertFlexEntry::set_allocated_true_next_node(std::string* true_next_node) {
  if (true_next_node != nullptr) {
    
  } else {
    
  }
  true_next_node_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), true_next_node,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.InsertFlexEntry.true_next_node)
}

// string false_next_node = 4;
inline void InsertFlexEntry::clear_false_next_node() {
  false_next_node_.ClearToEmpty();
}
inline const std::string& InsertFlexEntry::false_next_node() const {
  // @@protoc_insertion_point(field_get:p4.v1.InsertFlexEntry.false_next_node)
  return _internal_false_next_node();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertFlexEntry::set_false_next_node(ArgT0&& arg0, ArgT... args) {
 
 false_next_node_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.InsertFlexEntry.false_next_node)
}
inline std::string* InsertFlexEntry::mutable_false_next_node() {
  std::string* _s = _internal_mutable_false_next_node();
  // @@protoc_insertion_point(field_mutable:p4.v1.InsertFlexEntry.false_next_node)
  return _s;
}
inline const std::string& InsertFlexEntry::_internal_false_next_node() const {
  return false_next_node_.Get();
}
inline void InsertFlexEntry::_internal_set_false_next_node(const std::string& value) {
  
  false_next_node_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InsertFlexEntry::_internal_mutable_false_next_node() {
  
  return false_next_node_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InsertFlexEntry::release_false_next_node() {
  // @@protoc_insertion_point(field_release:p4.v1.InsertFlexEntry.false_next_node)
  return false_next_node_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InsertFlexEntry::set_allocated_false_next_node(std::string* false_next_node) {
  if (false_next_node != nullptr) {
    
  } else {
    
  }
  false_next_node_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), false_next_node,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.InsertFlexEntry.false_next_node)
}

// -------------------------------------------------------------------

// ChangeFlexEntry

// string pipeline_name = 1;
inline void ChangeFlexEntry::clear_pipeline_name() {
  pipeline_name_.ClearToEmpty();
}
inline const std::string& ChangeFlexEntry::pipeline_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.ChangeFlexEntry.pipeline_name)
  return _internal_pipeline_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeFlexEntry::set_pipeline_name(ArgT0&& arg0, ArgT... args) {
 
 pipeline_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.ChangeFlexEntry.pipeline_name)
}
inline std::string* ChangeFlexEntry::mutable_pipeline_name() {
  std::string* _s = _internal_mutable_pipeline_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.ChangeFlexEntry.pipeline_name)
  return _s;
}
inline const std::string& ChangeFlexEntry::_internal_pipeline_name() const {
  return pipeline_name_.Get();
}
inline void ChangeFlexEntry::_internal_set_pipeline_name(const std::string& value) {
  
  pipeline_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeFlexEntry::_internal_mutable_pipeline_name() {
  
  return pipeline_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeFlexEntry::release_pipeline_name() {
  // @@protoc_insertion_point(field_release:p4.v1.ChangeFlexEntry.pipeline_name)
  return pipeline_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeFlexEntry::set_allocated_pipeline_name(std::string* pipeline_name) {
  if (pipeline_name != nullptr) {
    
  } else {
    
  }
  pipeline_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pipeline_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.ChangeFlexEntry.pipeline_name)
}

// string flx_name = 2;
inline void ChangeFlexEntry::clear_flx_name() {
  flx_name_.ClearToEmpty();
}
inline const std::string& ChangeFlexEntry::flx_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.ChangeFlexEntry.flx_name)
  return _internal_flx_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeFlexEntry::set_flx_name(ArgT0&& arg0, ArgT... args) {
 
 flx_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.ChangeFlexEntry.flx_name)
}
inline std::string* ChangeFlexEntry::mutable_flx_name() {
  std::string* _s = _internal_mutable_flx_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.ChangeFlexEntry.flx_name)
  return _s;
}
inline const std::string& ChangeFlexEntry::_internal_flx_name() const {
  return flx_name_.Get();
}
inline void ChangeFlexEntry::_internal_set_flx_name(const std::string& value) {
  
  flx_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeFlexEntry::_internal_mutable_flx_name() {
  
  return flx_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeFlexEntry::release_flx_name() {
  // @@protoc_insertion_point(field_release:p4.v1.ChangeFlexEntry.flx_name)
  return flx_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeFlexEntry::set_allocated_flx_name(std::string* flx_name) {
  if (flx_name != nullptr) {
    
  } else {
    
  }
  flx_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), flx_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.ChangeFlexEntry.flx_name)
}

// bool true_or_false_next = 3;
inline void ChangeFlexEntry::clear_true_or_false_next() {
  true_or_false_next_ = false;
}
inline bool ChangeFlexEntry::_internal_true_or_false_next() const {
  return true_or_false_next_;
}
inline bool ChangeFlexEntry::true_or_false_next() const {
  // @@protoc_insertion_point(field_get:p4.v1.ChangeFlexEntry.true_or_false_next)
  return _internal_true_or_false_next();
}
inline void ChangeFlexEntry::_internal_set_true_or_false_next(bool value) {
  
  true_or_false_next_ = value;
}
inline void ChangeFlexEntry::set_true_or_false_next(bool value) {
  _internal_set_true_or_false_next(value);
  // @@protoc_insertion_point(field_set:p4.v1.ChangeFlexEntry.true_or_false_next)
}

// string node_next = 4;
inline void ChangeFlexEntry::clear_node_next() {
  node_next_.ClearToEmpty();
}
inline const std::string& ChangeFlexEntry::node_next() const {
  // @@protoc_insertion_point(field_get:p4.v1.ChangeFlexEntry.node_next)
  return _internal_node_next();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeFlexEntry::set_node_next(ArgT0&& arg0, ArgT... args) {
 
 node_next_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.ChangeFlexEntry.node_next)
}
inline std::string* ChangeFlexEntry::mutable_node_next() {
  std::string* _s = _internal_mutable_node_next();
  // @@protoc_insertion_point(field_mutable:p4.v1.ChangeFlexEntry.node_next)
  return _s;
}
inline const std::string& ChangeFlexEntry::_internal_node_next() const {
  return node_next_.Get();
}
inline void ChangeFlexEntry::_internal_set_node_next(const std::string& value) {
  
  node_next_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeFlexEntry::_internal_mutable_node_next() {
  
  return node_next_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeFlexEntry::release_node_next() {
  // @@protoc_insertion_point(field_release:p4.v1.ChangeFlexEntry.node_next)
  return node_next_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeFlexEntry::set_allocated_node_next(std::string* node_next) {
  if (node_next != nullptr) {
    
  } else {
    
  }
  node_next_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_next,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.ChangeFlexEntry.node_next)
}

// -------------------------------------------------------------------

// DeleteFlexEntry

// string pipeline_name = 1;
inline void DeleteFlexEntry::clear_pipeline_name() {
  pipeline_name_.ClearToEmpty();
}
inline const std::string& DeleteFlexEntry::pipeline_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.DeleteFlexEntry.pipeline_name)
  return _internal_pipeline_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteFlexEntry::set_pipeline_name(ArgT0&& arg0, ArgT... args) {
 
 pipeline_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.DeleteFlexEntry.pipeline_name)
}
inline std::string* DeleteFlexEntry::mutable_pipeline_name() {
  std::string* _s = _internal_mutable_pipeline_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.DeleteFlexEntry.pipeline_name)
  return _s;
}
inline const std::string& DeleteFlexEntry::_internal_pipeline_name() const {
  return pipeline_name_.Get();
}
inline void DeleteFlexEntry::_internal_set_pipeline_name(const std::string& value) {
  
  pipeline_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteFlexEntry::_internal_mutable_pipeline_name() {
  
  return pipeline_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteFlexEntry::release_pipeline_name() {
  // @@protoc_insertion_point(field_release:p4.v1.DeleteFlexEntry.pipeline_name)
  return pipeline_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteFlexEntry::set_allocated_pipeline_name(std::string* pipeline_name) {
  if (pipeline_name != nullptr) {
    
  } else {
    
  }
  pipeline_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pipeline_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.DeleteFlexEntry.pipeline_name)
}

// string flx_name = 2;
inline void DeleteFlexEntry::clear_flx_name() {
  flx_name_.ClearToEmpty();
}
inline const std::string& DeleteFlexEntry::flx_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.DeleteFlexEntry.flx_name)
  return _internal_flx_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteFlexEntry::set_flx_name(ArgT0&& arg0, ArgT... args) {
 
 flx_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.DeleteFlexEntry.flx_name)
}
inline std::string* DeleteFlexEntry::mutable_flx_name() {
  std::string* _s = _internal_mutable_flx_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.DeleteFlexEntry.flx_name)
  return _s;
}
inline const std::string& DeleteFlexEntry::_internal_flx_name() const {
  return flx_name_.Get();
}
inline void DeleteFlexEntry::_internal_set_flx_name(const std::string& value) {
  
  flx_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteFlexEntry::_internal_mutable_flx_name() {
  
  return flx_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteFlexEntry::release_flx_name() {
  // @@protoc_insertion_point(field_release:p4.v1.DeleteFlexEntry.flx_name)
  return flx_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteFlexEntry::set_allocated_flx_name(std::string* flx_name) {
  if (flx_name != nullptr) {
    
  } else {
    
  }
  flx_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), flx_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.DeleteFlexEntry.flx_name)
}

// -------------------------------------------------------------------

// InsertRegisterArrayEntry

// string register_array_name = 1;
inline void InsertRegisterArrayEntry::clear_register_array_name() {
  register_array_name_.ClearToEmpty();
}
inline const std::string& InsertRegisterArrayEntry::register_array_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.InsertRegisterArrayEntry.register_array_name)
  return _internal_register_array_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertRegisterArrayEntry::set_register_array_name(ArgT0&& arg0, ArgT... args) {
 
 register_array_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.InsertRegisterArrayEntry.register_array_name)
}
inline std::string* InsertRegisterArrayEntry::mutable_register_array_name() {
  std::string* _s = _internal_mutable_register_array_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.InsertRegisterArrayEntry.register_array_name)
  return _s;
}
inline const std::string& InsertRegisterArrayEntry::_internal_register_array_name() const {
  return register_array_name_.Get();
}
inline void InsertRegisterArrayEntry::_internal_set_register_array_name(const std::string& value) {
  
  register_array_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InsertRegisterArrayEntry::_internal_mutable_register_array_name() {
  
  return register_array_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InsertRegisterArrayEntry::release_register_array_name() {
  // @@protoc_insertion_point(field_release:p4.v1.InsertRegisterArrayEntry.register_array_name)
  return register_array_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InsertRegisterArrayEntry::set_allocated_register_array_name(std::string* register_array_name) {
  if (register_array_name != nullptr) {
    
  } else {
    
  }
  register_array_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), register_array_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.InsertRegisterArrayEntry.register_array_name)
}

// uint32 register_array_size = 2;
inline void InsertRegisterArrayEntry::clear_register_array_size() {
  register_array_size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 InsertRegisterArrayEntry::_internal_register_array_size() const {
  return register_array_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 InsertRegisterArrayEntry::register_array_size() const {
  // @@protoc_insertion_point(field_get:p4.v1.InsertRegisterArrayEntry.register_array_size)
  return _internal_register_array_size();
}
inline void InsertRegisterArrayEntry::_internal_set_register_array_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  register_array_size_ = value;
}
inline void InsertRegisterArrayEntry::set_register_array_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_register_array_size(value);
  // @@protoc_insertion_point(field_set:p4.v1.InsertRegisterArrayEntry.register_array_size)
}

// uint32 register_array_bitwidth = 3;
inline void InsertRegisterArrayEntry::clear_register_array_bitwidth() {
  register_array_bitwidth_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 InsertRegisterArrayEntry::_internal_register_array_bitwidth() const {
  return register_array_bitwidth_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 InsertRegisterArrayEntry::register_array_bitwidth() const {
  // @@protoc_insertion_point(field_get:p4.v1.InsertRegisterArrayEntry.register_array_bitwidth)
  return _internal_register_array_bitwidth();
}
inline void InsertRegisterArrayEntry::_internal_set_register_array_bitwidth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  register_array_bitwidth_ = value;
}
inline void InsertRegisterArrayEntry::set_register_array_bitwidth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_register_array_bitwidth(value);
  // @@protoc_insertion_point(field_set:p4.v1.InsertRegisterArrayEntry.register_array_bitwidth)
}

// -------------------------------------------------------------------

// ChangeRegisterArrayEntry

// string register_array_name = 1;
inline void ChangeRegisterArrayEntry::clear_register_array_name() {
  register_array_name_.ClearToEmpty();
}
inline const std::string& ChangeRegisterArrayEntry::register_array_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.ChangeRegisterArrayEntry.register_array_name)
  return _internal_register_array_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeRegisterArrayEntry::set_register_array_name(ArgT0&& arg0, ArgT... args) {
 
 register_array_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.ChangeRegisterArrayEntry.register_array_name)
}
inline std::string* ChangeRegisterArrayEntry::mutable_register_array_name() {
  std::string* _s = _internal_mutable_register_array_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.ChangeRegisterArrayEntry.register_array_name)
  return _s;
}
inline const std::string& ChangeRegisterArrayEntry::_internal_register_array_name() const {
  return register_array_name_.Get();
}
inline void ChangeRegisterArrayEntry::_internal_set_register_array_name(const std::string& value) {
  
  register_array_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeRegisterArrayEntry::_internal_mutable_register_array_name() {
  
  return register_array_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeRegisterArrayEntry::release_register_array_name() {
  // @@protoc_insertion_point(field_release:p4.v1.ChangeRegisterArrayEntry.register_array_name)
  return register_array_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeRegisterArrayEntry::set_allocated_register_array_name(std::string* register_array_name) {
  if (register_array_name != nullptr) {
    
  } else {
    
  }
  register_array_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), register_array_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.ChangeRegisterArrayEntry.register_array_name)
}

// .p4.v1.ChangeRegisterArrayEntry.RegisterArrayChangeType register_array_change_type = 2;
inline void ChangeRegisterArrayEntry::clear_register_array_change_type() {
  register_array_change_type_ = 0;
}
inline ::p4::v1::ChangeRegisterArrayEntry_RegisterArrayChangeType ChangeRegisterArrayEntry::_internal_register_array_change_type() const {
  return static_cast< ::p4::v1::ChangeRegisterArrayEntry_RegisterArrayChangeType >(register_array_change_type_);
}
inline ::p4::v1::ChangeRegisterArrayEntry_RegisterArrayChangeType ChangeRegisterArrayEntry::register_array_change_type() const {
  // @@protoc_insertion_point(field_get:p4.v1.ChangeRegisterArrayEntry.register_array_change_type)
  return _internal_register_array_change_type();
}
inline void ChangeRegisterArrayEntry::_internal_set_register_array_change_type(::p4::v1::ChangeRegisterArrayEntry_RegisterArrayChangeType value) {
  
  register_array_change_type_ = value;
}
inline void ChangeRegisterArrayEntry::set_register_array_change_type(::p4::v1::ChangeRegisterArrayEntry_RegisterArrayChangeType value) {
  _internal_set_register_array_change_type(value);
  // @@protoc_insertion_point(field_set:p4.v1.ChangeRegisterArrayEntry.register_array_change_type)
}

// uint32 new_value = 3;
inline void ChangeRegisterArrayEntry::clear_new_value() {
  new_value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChangeRegisterArrayEntry::_internal_new_value() const {
  return new_value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChangeRegisterArrayEntry::new_value() const {
  // @@protoc_insertion_point(field_get:p4.v1.ChangeRegisterArrayEntry.new_value)
  return _internal_new_value();
}
inline void ChangeRegisterArrayEntry::_internal_set_new_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  new_value_ = value;
}
inline void ChangeRegisterArrayEntry::set_new_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_new_value(value);
  // @@protoc_insertion_point(field_set:p4.v1.ChangeRegisterArrayEntry.new_value)
}

// -------------------------------------------------------------------

// DeleteRegisterArrayEntry

// string register_array_name = 1;
inline void DeleteRegisterArrayEntry::clear_register_array_name() {
  register_array_name_.ClearToEmpty();
}
inline const std::string& DeleteRegisterArrayEntry::register_array_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.DeleteRegisterArrayEntry.register_array_name)
  return _internal_register_array_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRegisterArrayEntry::set_register_array_name(ArgT0&& arg0, ArgT... args) {
 
 register_array_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.DeleteRegisterArrayEntry.register_array_name)
}
inline std::string* DeleteRegisterArrayEntry::mutable_register_array_name() {
  std::string* _s = _internal_mutable_register_array_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.DeleteRegisterArrayEntry.register_array_name)
  return _s;
}
inline const std::string& DeleteRegisterArrayEntry::_internal_register_array_name() const {
  return register_array_name_.Get();
}
inline void DeleteRegisterArrayEntry::_internal_set_register_array_name(const std::string& value) {
  
  register_array_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteRegisterArrayEntry::_internal_mutable_register_array_name() {
  
  return register_array_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteRegisterArrayEntry::release_register_array_name() {
  // @@protoc_insertion_point(field_release:p4.v1.DeleteRegisterArrayEntry.register_array_name)
  return register_array_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteRegisterArrayEntry::set_allocated_register_array_name(std::string* register_array_name) {
  if (register_array_name != nullptr) {
    
  } else {
    
  }
  register_array_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), register_array_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.DeleteRegisterArrayEntry.register_array_name)
}

// -------------------------------------------------------------------

// TriggerEntry

// bool on_or_off = 1;
inline void TriggerEntry::clear_on_or_off() {
  on_or_off_ = false;
}
inline bool TriggerEntry::_internal_on_or_off() const {
  return on_or_off_;
}
inline bool TriggerEntry::on_or_off() const {
  // @@protoc_insertion_point(field_get:p4.v1.TriggerEntry.on_or_off)
  return _internal_on_or_off();
}
inline void TriggerEntry::_internal_set_on_or_off(bool value) {
  
  on_or_off_ = value;
}
inline void TriggerEntry::set_on_or_off(bool value) {
  _internal_set_on_or_off(value);
  // @@protoc_insertion_point(field_set:p4.v1.TriggerEntry.on_or_off)
}

// -------------------------------------------------------------------

// ChangeInitEntry

// string pipeline_name = 1;
inline void ChangeInitEntry::clear_pipeline_name() {
  pipeline_name_.ClearToEmpty();
}
inline const std::string& ChangeInitEntry::pipeline_name() const {
  // @@protoc_insertion_point(field_get:p4.v1.ChangeInitEntry.pipeline_name)
  return _internal_pipeline_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeInitEntry::set_pipeline_name(ArgT0&& arg0, ArgT... args) {
 
 pipeline_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.ChangeInitEntry.pipeline_name)
}
inline std::string* ChangeInitEntry::mutable_pipeline_name() {
  std::string* _s = _internal_mutable_pipeline_name();
  // @@protoc_insertion_point(field_mutable:p4.v1.ChangeInitEntry.pipeline_name)
  return _s;
}
inline const std::string& ChangeInitEntry::_internal_pipeline_name() const {
  return pipeline_name_.Get();
}
inline void ChangeInitEntry::_internal_set_pipeline_name(const std::string& value) {
  
  pipeline_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeInitEntry::_internal_mutable_pipeline_name() {
  
  return pipeline_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeInitEntry::release_pipeline_name() {
  // @@protoc_insertion_point(field_release:p4.v1.ChangeInitEntry.pipeline_name)
  return pipeline_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeInitEntry::set_allocated_pipeline_name(std::string* pipeline_name) {
  if (pipeline_name != nullptr) {
    
  } else {
    
  }
  pipeline_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pipeline_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.ChangeInitEntry.pipeline_name)
}

// string table_name_next = 2;
inline void ChangeInitEntry::clear_table_name_next() {
  table_name_next_.ClearToEmpty();
}
inline const std::string& ChangeInitEntry::table_name_next() const {
  // @@protoc_insertion_point(field_get:p4.v1.ChangeInitEntry.table_name_next)
  return _internal_table_name_next();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeInitEntry::set_table_name_next(ArgT0&& arg0, ArgT... args) {
 
 table_name_next_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.ChangeInitEntry.table_name_next)
}
inline std::string* ChangeInitEntry::mutable_table_name_next() {
  std::string* _s = _internal_mutable_table_name_next();
  // @@protoc_insertion_point(field_mutable:p4.v1.ChangeInitEntry.table_name_next)
  return _s;
}
inline const std::string& ChangeInitEntry::_internal_table_name_next() const {
  return table_name_next_.Get();
}
inline void ChangeInitEntry::_internal_set_table_name_next(const std::string& value) {
  
  table_name_next_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeInitEntry::_internal_mutable_table_name_next() {
  
  return table_name_next_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeInitEntry::release_table_name_next() {
  // @@protoc_insertion_point(field_release:p4.v1.ChangeInitEntry.table_name_next)
  return table_name_next_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeInitEntry::set_allocated_table_name_next(std::string* table_name_next) {
  if (table_name_next != nullptr) {
    
  } else {
    
  }
  table_name_next_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name_next,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.ChangeInitEntry.table_name_next)
}

// -------------------------------------------------------------------

// ExternEntry

// uint32 extern_type_id = 1;
inline void ExternEntry::clear_extern_type_id() {
  extern_type_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ExternEntry::_internal_extern_type_id() const {
  return extern_type_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ExternEntry::extern_type_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.ExternEntry.extern_type_id)
  return _internal_extern_type_id();
}
inline void ExternEntry::_internal_set_extern_type_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  extern_type_id_ = value;
}
inline void ExternEntry::set_extern_type_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_extern_type_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.ExternEntry.extern_type_id)
}

// uint32 extern_id = 2;
inline void ExternEntry::clear_extern_id() {
  extern_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ExternEntry::_internal_extern_id() const {
  return extern_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ExternEntry::extern_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.ExternEntry.extern_id)
  return _internal_extern_id();
}
inline void ExternEntry::_internal_set_extern_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  extern_id_ = value;
}
inline void ExternEntry::set_extern_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_extern_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.ExternEntry.extern_id)
}

// .google.protobuf.Any entry = 3;
inline bool ExternEntry::_internal_has_entry() const {
  return this != internal_default_instance() && entry_ != nullptr;
}
inline bool ExternEntry::has_entry() const {
  return _internal_has_entry();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& ExternEntry::_internal_entry() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = entry_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& ExternEntry::entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.ExternEntry.entry)
  return _internal_entry();
}
inline void ExternEntry::unsafe_arena_set_allocated_entry(
    ::PROTOBUF_NAMESPACE_ID::Any* entry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(entry_);
  }
  entry_ = entry;
  if (entry) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.ExternEntry.entry)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ExternEntry::release_entry() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = entry_;
  entry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ExternEntry::unsafe_arena_release_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.ExternEntry.entry)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = entry_;
  entry_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ExternEntry::_internal_mutable_entry() {
  
  if (entry_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    entry_ = p;
  }
  return entry_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ExternEntry::mutable_entry() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.ExternEntry.entry)
  return _msg;
}
inline void ExternEntry::set_allocated_entry(::PROTOBUF_NAMESPACE_ID::Any* entry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(entry_);
  }
  if (entry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(entry));
    if (message_arena != submessage_arena) {
      entry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, entry, submessage_arena);
    }
    
  } else {
    
  }
  entry_ = entry;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.ExternEntry.entry)
}

// -------------------------------------------------------------------

// TableEntry_IdleTimeout

// int64 elapsed_ns = 1;
inline void TableEntry_IdleTimeout::clear_elapsed_ns() {
  elapsed_ns_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TableEntry_IdleTimeout::_internal_elapsed_ns() const {
  return elapsed_ns_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TableEntry_IdleTimeout::elapsed_ns() const {
  // @@protoc_insertion_point(field_get:p4.v1.TableEntry.IdleTimeout.elapsed_ns)
  return _internal_elapsed_ns();
}
inline void TableEntry_IdleTimeout::_internal_set_elapsed_ns(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  elapsed_ns_ = value;
}
inline void TableEntry_IdleTimeout::set_elapsed_ns(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_elapsed_ns(value);
  // @@protoc_insertion_point(field_set:p4.v1.TableEntry.IdleTimeout.elapsed_ns)
}

// -------------------------------------------------------------------

// TableEntry

// uint32 table_id = 1;
inline void TableEntry::clear_table_id() {
  table_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TableEntry::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TableEntry::table_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.TableEntry.table_id)
  return _internal_table_id();
}
inline void TableEntry::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  table_id_ = value;
}
inline void TableEntry::set_table_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.TableEntry.table_id)
}

// repeated .p4.v1.FieldMatch match = 2;
inline int TableEntry::_internal_match_size() const {
  return match_.size();
}
inline int TableEntry::match_size() const {
  return _internal_match_size();
}
inline void TableEntry::clear_match() {
  match_.Clear();
}
inline ::p4::v1::FieldMatch* TableEntry::mutable_match(int index) {
  // @@protoc_insertion_point(field_mutable:p4.v1.TableEntry.match)
  return match_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::FieldMatch >*
TableEntry::mutable_match() {
  // @@protoc_insertion_point(field_mutable_list:p4.v1.TableEntry.match)
  return &match_;
}
inline const ::p4::v1::FieldMatch& TableEntry::_internal_match(int index) const {
  return match_.Get(index);
}
inline const ::p4::v1::FieldMatch& TableEntry::match(int index) const {
  // @@protoc_insertion_point(field_get:p4.v1.TableEntry.match)
  return _internal_match(index);
}
inline ::p4::v1::FieldMatch* TableEntry::_internal_add_match() {
  return match_.Add();
}
inline ::p4::v1::FieldMatch* TableEntry::add_match() {
  ::p4::v1::FieldMatch* _add = _internal_add_match();
  // @@protoc_insertion_point(field_add:p4.v1.TableEntry.match)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::FieldMatch >&
TableEntry::match() const {
  // @@protoc_insertion_point(field_list:p4.v1.TableEntry.match)
  return match_;
}

// .p4.v1.TableAction action = 3;
inline bool TableEntry::_internal_has_action() const {
  return this != internal_default_instance() && action_ != nullptr;
}
inline bool TableEntry::has_action() const {
  return _internal_has_action();
}
inline void TableEntry::clear_action() {
  if (GetArenaForAllocation() == nullptr && action_ != nullptr) {
    delete action_;
  }
  action_ = nullptr;
}
inline const ::p4::v1::TableAction& TableEntry::_internal_action() const {
  const ::p4::v1::TableAction* p = action_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::TableAction&>(
      ::p4::v1::_TableAction_default_instance_);
}
inline const ::p4::v1::TableAction& TableEntry::action() const {
  // @@protoc_insertion_point(field_get:p4.v1.TableEntry.action)
  return _internal_action();
}
inline void TableEntry::unsafe_arena_set_allocated_action(
    ::p4::v1::TableAction* action) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(action_);
  }
  action_ = action;
  if (action) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.TableEntry.action)
}
inline ::p4::v1::TableAction* TableEntry::release_action() {
  
  ::p4::v1::TableAction* temp = action_;
  action_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::TableAction* TableEntry::unsafe_arena_release_action() {
  // @@protoc_insertion_point(field_release:p4.v1.TableEntry.action)
  
  ::p4::v1::TableAction* temp = action_;
  action_ = nullptr;
  return temp;
}
inline ::p4::v1::TableAction* TableEntry::_internal_mutable_action() {
  
  if (action_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::TableAction>(GetArenaForAllocation());
    action_ = p;
  }
  return action_;
}
inline ::p4::v1::TableAction* TableEntry::mutable_action() {
  ::p4::v1::TableAction* _msg = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:p4.v1.TableEntry.action)
  return _msg;
}
inline void TableEntry::set_allocated_action(::p4::v1::TableAction* action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete action_;
  }
  if (action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::TableAction>::GetOwningArena(action);
    if (message_arena != submessage_arena) {
      action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action, submessage_arena);
    }
    
  } else {
    
  }
  action_ = action;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.TableEntry.action)
}

// int32 priority = 4;
inline void TableEntry::clear_priority() {
  priority_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TableEntry::_internal_priority() const {
  return priority_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TableEntry::priority() const {
  // @@protoc_insertion_point(field_get:p4.v1.TableEntry.priority)
  return _internal_priority();
}
inline void TableEntry::_internal_set_priority(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  priority_ = value;
}
inline void TableEntry::set_priority(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:p4.v1.TableEntry.priority)
}

// uint64 controller_metadata = 5 [deprecated = true];
inline void TableEntry::clear_controller_metadata() {
  controller_metadata_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TableEntry::_internal_controller_metadata() const {
  return controller_metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TableEntry::controller_metadata() const {
  // @@protoc_insertion_point(field_get:p4.v1.TableEntry.controller_metadata)
  return _internal_controller_metadata();
}
inline void TableEntry::_internal_set_controller_metadata(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  controller_metadata_ = value;
}
inline void TableEntry::set_controller_metadata(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_controller_metadata(value);
  // @@protoc_insertion_point(field_set:p4.v1.TableEntry.controller_metadata)
}

// .p4.v1.MeterConfig meter_config = 6;
inline bool TableEntry::_internal_has_meter_config() const {
  return this != internal_default_instance() && meter_config_ != nullptr;
}
inline bool TableEntry::has_meter_config() const {
  return _internal_has_meter_config();
}
inline void TableEntry::clear_meter_config() {
  if (GetArenaForAllocation() == nullptr && meter_config_ != nullptr) {
    delete meter_config_;
  }
  meter_config_ = nullptr;
}
inline const ::p4::v1::MeterConfig& TableEntry::_internal_meter_config() const {
  const ::p4::v1::MeterConfig* p = meter_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::MeterConfig&>(
      ::p4::v1::_MeterConfig_default_instance_);
}
inline const ::p4::v1::MeterConfig& TableEntry::meter_config() const {
  // @@protoc_insertion_point(field_get:p4.v1.TableEntry.meter_config)
  return _internal_meter_config();
}
inline void TableEntry::unsafe_arena_set_allocated_meter_config(
    ::p4::v1::MeterConfig* meter_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(meter_config_);
  }
  meter_config_ = meter_config;
  if (meter_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.TableEntry.meter_config)
}
inline ::p4::v1::MeterConfig* TableEntry::release_meter_config() {
  
  ::p4::v1::MeterConfig* temp = meter_config_;
  meter_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::MeterConfig* TableEntry::unsafe_arena_release_meter_config() {
  // @@protoc_insertion_point(field_release:p4.v1.TableEntry.meter_config)
  
  ::p4::v1::MeterConfig* temp = meter_config_;
  meter_config_ = nullptr;
  return temp;
}
inline ::p4::v1::MeterConfig* TableEntry::_internal_mutable_meter_config() {
  
  if (meter_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::MeterConfig>(GetArenaForAllocation());
    meter_config_ = p;
  }
  return meter_config_;
}
inline ::p4::v1::MeterConfig* TableEntry::mutable_meter_config() {
  ::p4::v1::MeterConfig* _msg = _internal_mutable_meter_config();
  // @@protoc_insertion_point(field_mutable:p4.v1.TableEntry.meter_config)
  return _msg;
}
inline void TableEntry::set_allocated_meter_config(::p4::v1::MeterConfig* meter_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete meter_config_;
  }
  if (meter_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::MeterConfig>::GetOwningArena(meter_config);
    if (message_arena != submessage_arena) {
      meter_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meter_config, submessage_arena);
    }
    
  } else {
    
  }
  meter_config_ = meter_config;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.TableEntry.meter_config)
}

// .p4.v1.CounterData counter_data = 7;
inline bool TableEntry::_internal_has_counter_data() const {
  return this != internal_default_instance() && counter_data_ != nullptr;
}
inline bool TableEntry::has_counter_data() const {
  return _internal_has_counter_data();
}
inline void TableEntry::clear_counter_data() {
  if (GetArenaForAllocation() == nullptr && counter_data_ != nullptr) {
    delete counter_data_;
  }
  counter_data_ = nullptr;
}
inline const ::p4::v1::CounterData& TableEntry::_internal_counter_data() const {
  const ::p4::v1::CounterData* p = counter_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::CounterData&>(
      ::p4::v1::_CounterData_default_instance_);
}
inline const ::p4::v1::CounterData& TableEntry::counter_data() const {
  // @@protoc_insertion_point(field_get:p4.v1.TableEntry.counter_data)
  return _internal_counter_data();
}
inline void TableEntry::unsafe_arena_set_allocated_counter_data(
    ::p4::v1::CounterData* counter_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(counter_data_);
  }
  counter_data_ = counter_data;
  if (counter_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.TableEntry.counter_data)
}
inline ::p4::v1::CounterData* TableEntry::release_counter_data() {
  
  ::p4::v1::CounterData* temp = counter_data_;
  counter_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::CounterData* TableEntry::unsafe_arena_release_counter_data() {
  // @@protoc_insertion_point(field_release:p4.v1.TableEntry.counter_data)
  
  ::p4::v1::CounterData* temp = counter_data_;
  counter_data_ = nullptr;
  return temp;
}
inline ::p4::v1::CounterData* TableEntry::_internal_mutable_counter_data() {
  
  if (counter_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::CounterData>(GetArenaForAllocation());
    counter_data_ = p;
  }
  return counter_data_;
}
inline ::p4::v1::CounterData* TableEntry::mutable_counter_data() {
  ::p4::v1::CounterData* _msg = _internal_mutable_counter_data();
  // @@protoc_insertion_point(field_mutable:p4.v1.TableEntry.counter_data)
  return _msg;
}
inline void TableEntry::set_allocated_counter_data(::p4::v1::CounterData* counter_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete counter_data_;
  }
  if (counter_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::CounterData>::GetOwningArena(counter_data);
    if (message_arena != submessage_arena) {
      counter_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, counter_data, submessage_arena);
    }
    
  } else {
    
  }
  counter_data_ = counter_data;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.TableEntry.counter_data)
}

// bool is_default_action = 8;
inline void TableEntry::clear_is_default_action() {
  is_default_action_ = false;
}
inline bool TableEntry::_internal_is_default_action() const {
  return is_default_action_;
}
inline bool TableEntry::is_default_action() const {
  // @@protoc_insertion_point(field_get:p4.v1.TableEntry.is_default_action)
  return _internal_is_default_action();
}
inline void TableEntry::_internal_set_is_default_action(bool value) {
  
  is_default_action_ = value;
}
inline void TableEntry::set_is_default_action(bool value) {
  _internal_set_is_default_action(value);
  // @@protoc_insertion_point(field_set:p4.v1.TableEntry.is_default_action)
}

// int64 idle_timeout_ns = 9;
inline void TableEntry::clear_idle_timeout_ns() {
  idle_timeout_ns_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TableEntry::_internal_idle_timeout_ns() const {
  return idle_timeout_ns_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TableEntry::idle_timeout_ns() const {
  // @@protoc_insertion_point(field_get:p4.v1.TableEntry.idle_timeout_ns)
  return _internal_idle_timeout_ns();
}
inline void TableEntry::_internal_set_idle_timeout_ns(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  idle_timeout_ns_ = value;
}
inline void TableEntry::set_idle_timeout_ns(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_idle_timeout_ns(value);
  // @@protoc_insertion_point(field_set:p4.v1.TableEntry.idle_timeout_ns)
}

// .p4.v1.TableEntry.IdleTimeout time_since_last_hit = 10;
inline bool TableEntry::_internal_has_time_since_last_hit() const {
  return this != internal_default_instance() && time_since_last_hit_ != nullptr;
}
inline bool TableEntry::has_time_since_last_hit() const {
  return _internal_has_time_since_last_hit();
}
inline void TableEntry::clear_time_since_last_hit() {
  if (GetArenaForAllocation() == nullptr && time_since_last_hit_ != nullptr) {
    delete time_since_last_hit_;
  }
  time_since_last_hit_ = nullptr;
}
inline const ::p4::v1::TableEntry_IdleTimeout& TableEntry::_internal_time_since_last_hit() const {
  const ::p4::v1::TableEntry_IdleTimeout* p = time_since_last_hit_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::TableEntry_IdleTimeout&>(
      ::p4::v1::_TableEntry_IdleTimeout_default_instance_);
}
inline const ::p4::v1::TableEntry_IdleTimeout& TableEntry::time_since_last_hit() const {
  // @@protoc_insertion_point(field_get:p4.v1.TableEntry.time_since_last_hit)
  return _internal_time_since_last_hit();
}
inline void TableEntry::unsafe_arena_set_allocated_time_since_last_hit(
    ::p4::v1::TableEntry_IdleTimeout* time_since_last_hit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_since_last_hit_);
  }
  time_since_last_hit_ = time_since_last_hit;
  if (time_since_last_hit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.TableEntry.time_since_last_hit)
}
inline ::p4::v1::TableEntry_IdleTimeout* TableEntry::release_time_since_last_hit() {
  
  ::p4::v1::TableEntry_IdleTimeout* temp = time_since_last_hit_;
  time_since_last_hit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::TableEntry_IdleTimeout* TableEntry::unsafe_arena_release_time_since_last_hit() {
  // @@protoc_insertion_point(field_release:p4.v1.TableEntry.time_since_last_hit)
  
  ::p4::v1::TableEntry_IdleTimeout* temp = time_since_last_hit_;
  time_since_last_hit_ = nullptr;
  return temp;
}
inline ::p4::v1::TableEntry_IdleTimeout* TableEntry::_internal_mutable_time_since_last_hit() {
  
  if (time_since_last_hit_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::TableEntry_IdleTimeout>(GetArenaForAllocation());
    time_since_last_hit_ = p;
  }
  return time_since_last_hit_;
}
inline ::p4::v1::TableEntry_IdleTimeout* TableEntry::mutable_time_since_last_hit() {
  ::p4::v1::TableEntry_IdleTimeout* _msg = _internal_mutable_time_since_last_hit();
  // @@protoc_insertion_point(field_mutable:p4.v1.TableEntry.time_since_last_hit)
  return _msg;
}
inline void TableEntry::set_allocated_time_since_last_hit(::p4::v1::TableEntry_IdleTimeout* time_since_last_hit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete time_since_last_hit_;
  }
  if (time_since_last_hit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::TableEntry_IdleTimeout>::GetOwningArena(time_since_last_hit);
    if (message_arena != submessage_arena) {
      time_since_last_hit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_since_last_hit, submessage_arena);
    }
    
  } else {
    
  }
  time_since_last_hit_ = time_since_last_hit;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.TableEntry.time_since_last_hit)
}

// bytes metadata = 11;
inline void TableEntry::clear_metadata() {
  metadata_.ClearToEmpty();
}
inline const std::string& TableEntry::metadata() const {
  // @@protoc_insertion_point(field_get:p4.v1.TableEntry.metadata)
  return _internal_metadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TableEntry::set_metadata(ArgT0&& arg0, ArgT... args) {
 
 metadata_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.TableEntry.metadata)
}
inline std::string* TableEntry::mutable_metadata() {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:p4.v1.TableEntry.metadata)
  return _s;
}
inline const std::string& TableEntry::_internal_metadata() const {
  return metadata_.Get();
}
inline void TableEntry::_internal_set_metadata(const std::string& value) {
  
  metadata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TableEntry::_internal_mutable_metadata() {
  
  return metadata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TableEntry::release_metadata() {
  // @@protoc_insertion_point(field_release:p4.v1.TableEntry.metadata)
  return metadata_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TableEntry::set_allocated_metadata(std::string* metadata) {
  if (metadata != nullptr) {
    
  } else {
    
  }
  metadata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), metadata,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.TableEntry.metadata)
}

// -------------------------------------------------------------------

// FieldMatch_Exact

// bytes value = 1;
inline void FieldMatch_Exact::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& FieldMatch_Exact::value() const {
  // @@protoc_insertion_point(field_get:p4.v1.FieldMatch.Exact.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldMatch_Exact::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.FieldMatch.Exact.value)
}
inline std::string* FieldMatch_Exact::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:p4.v1.FieldMatch.Exact.value)
  return _s;
}
inline const std::string& FieldMatch_Exact::_internal_value() const {
  return value_.Get();
}
inline void FieldMatch_Exact::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FieldMatch_Exact::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FieldMatch_Exact::release_value() {
  // @@protoc_insertion_point(field_release:p4.v1.FieldMatch.Exact.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FieldMatch_Exact::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.FieldMatch.Exact.value)
}

// -------------------------------------------------------------------

// FieldMatch_Ternary

// bytes value = 1;
inline void FieldMatch_Ternary::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& FieldMatch_Ternary::value() const {
  // @@protoc_insertion_point(field_get:p4.v1.FieldMatch.Ternary.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldMatch_Ternary::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.FieldMatch.Ternary.value)
}
inline std::string* FieldMatch_Ternary::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:p4.v1.FieldMatch.Ternary.value)
  return _s;
}
inline const std::string& FieldMatch_Ternary::_internal_value() const {
  return value_.Get();
}
inline void FieldMatch_Ternary::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FieldMatch_Ternary::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FieldMatch_Ternary::release_value() {
  // @@protoc_insertion_point(field_release:p4.v1.FieldMatch.Ternary.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FieldMatch_Ternary::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.FieldMatch.Ternary.value)
}

// bytes mask = 2;
inline void FieldMatch_Ternary::clear_mask() {
  mask_.ClearToEmpty();
}
inline const std::string& FieldMatch_Ternary::mask() const {
  // @@protoc_insertion_point(field_get:p4.v1.FieldMatch.Ternary.mask)
  return _internal_mask();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldMatch_Ternary::set_mask(ArgT0&& arg0, ArgT... args) {
 
 mask_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.FieldMatch.Ternary.mask)
}
inline std::string* FieldMatch_Ternary::mutable_mask() {
  std::string* _s = _internal_mutable_mask();
  // @@protoc_insertion_point(field_mutable:p4.v1.FieldMatch.Ternary.mask)
  return _s;
}
inline const std::string& FieldMatch_Ternary::_internal_mask() const {
  return mask_.Get();
}
inline void FieldMatch_Ternary::_internal_set_mask(const std::string& value) {
  
  mask_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FieldMatch_Ternary::_internal_mutable_mask() {
  
  return mask_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FieldMatch_Ternary::release_mask() {
  // @@protoc_insertion_point(field_release:p4.v1.FieldMatch.Ternary.mask)
  return mask_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FieldMatch_Ternary::set_allocated_mask(std::string* mask) {
  if (mask != nullptr) {
    
  } else {
    
  }
  mask_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mask,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.FieldMatch.Ternary.mask)
}

// -------------------------------------------------------------------

// FieldMatch_LPM

// bytes value = 1;
inline void FieldMatch_LPM::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& FieldMatch_LPM::value() const {
  // @@protoc_insertion_point(field_get:p4.v1.FieldMatch.LPM.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldMatch_LPM::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.FieldMatch.LPM.value)
}
inline std::string* FieldMatch_LPM::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:p4.v1.FieldMatch.LPM.value)
  return _s;
}
inline const std::string& FieldMatch_LPM::_internal_value() const {
  return value_.Get();
}
inline void FieldMatch_LPM::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FieldMatch_LPM::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FieldMatch_LPM::release_value() {
  // @@protoc_insertion_point(field_release:p4.v1.FieldMatch.LPM.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FieldMatch_LPM::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.FieldMatch.LPM.value)
}

// int32 prefix_len = 2;
inline void FieldMatch_LPM::clear_prefix_len() {
  prefix_len_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FieldMatch_LPM::_internal_prefix_len() const {
  return prefix_len_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FieldMatch_LPM::prefix_len() const {
  // @@protoc_insertion_point(field_get:p4.v1.FieldMatch.LPM.prefix_len)
  return _internal_prefix_len();
}
inline void FieldMatch_LPM::_internal_set_prefix_len(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  prefix_len_ = value;
}
inline void FieldMatch_LPM::set_prefix_len(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_prefix_len(value);
  // @@protoc_insertion_point(field_set:p4.v1.FieldMatch.LPM.prefix_len)
}

// -------------------------------------------------------------------

// FieldMatch_Range

// bytes low = 1;
inline void FieldMatch_Range::clear_low() {
  low_.ClearToEmpty();
}
inline const std::string& FieldMatch_Range::low() const {
  // @@protoc_insertion_point(field_get:p4.v1.FieldMatch.Range.low)
  return _internal_low();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldMatch_Range::set_low(ArgT0&& arg0, ArgT... args) {
 
 low_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.FieldMatch.Range.low)
}
inline std::string* FieldMatch_Range::mutable_low() {
  std::string* _s = _internal_mutable_low();
  // @@protoc_insertion_point(field_mutable:p4.v1.FieldMatch.Range.low)
  return _s;
}
inline const std::string& FieldMatch_Range::_internal_low() const {
  return low_.Get();
}
inline void FieldMatch_Range::_internal_set_low(const std::string& value) {
  
  low_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FieldMatch_Range::_internal_mutable_low() {
  
  return low_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FieldMatch_Range::release_low() {
  // @@protoc_insertion_point(field_release:p4.v1.FieldMatch.Range.low)
  return low_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FieldMatch_Range::set_allocated_low(std::string* low) {
  if (low != nullptr) {
    
  } else {
    
  }
  low_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), low,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.FieldMatch.Range.low)
}

// bytes high = 2;
inline void FieldMatch_Range::clear_high() {
  high_.ClearToEmpty();
}
inline const std::string& FieldMatch_Range::high() const {
  // @@protoc_insertion_point(field_get:p4.v1.FieldMatch.Range.high)
  return _internal_high();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldMatch_Range::set_high(ArgT0&& arg0, ArgT... args) {
 
 high_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.FieldMatch.Range.high)
}
inline std::string* FieldMatch_Range::mutable_high() {
  std::string* _s = _internal_mutable_high();
  // @@protoc_insertion_point(field_mutable:p4.v1.FieldMatch.Range.high)
  return _s;
}
inline const std::string& FieldMatch_Range::_internal_high() const {
  return high_.Get();
}
inline void FieldMatch_Range::_internal_set_high(const std::string& value) {
  
  high_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FieldMatch_Range::_internal_mutable_high() {
  
  return high_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FieldMatch_Range::release_high() {
  // @@protoc_insertion_point(field_release:p4.v1.FieldMatch.Range.high)
  return high_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FieldMatch_Range::set_allocated_high(std::string* high) {
  if (high != nullptr) {
    
  } else {
    
  }
  high_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), high,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.FieldMatch.Range.high)
}

// -------------------------------------------------------------------

// FieldMatch_Optional

// bytes value = 1;
inline void FieldMatch_Optional::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& FieldMatch_Optional::value() const {
  // @@protoc_insertion_point(field_get:p4.v1.FieldMatch.Optional.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldMatch_Optional::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.FieldMatch.Optional.value)
}
inline std::string* FieldMatch_Optional::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:p4.v1.FieldMatch.Optional.value)
  return _s;
}
inline const std::string& FieldMatch_Optional::_internal_value() const {
  return value_.Get();
}
inline void FieldMatch_Optional::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FieldMatch_Optional::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FieldMatch_Optional::release_value() {
  // @@protoc_insertion_point(field_release:p4.v1.FieldMatch.Optional.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FieldMatch_Optional::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.FieldMatch.Optional.value)
}

// -------------------------------------------------------------------

// FieldMatch

// uint32 field_id = 1;
inline void FieldMatch::clear_field_id() {
  field_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FieldMatch::_internal_field_id() const {
  return field_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FieldMatch::field_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.FieldMatch.field_id)
  return _internal_field_id();
}
inline void FieldMatch::_internal_set_field_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  field_id_ = value;
}
inline void FieldMatch::set_field_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_field_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.FieldMatch.field_id)
}

// .p4.v1.FieldMatch.Exact exact = 2;
inline bool FieldMatch::_internal_has_exact() const {
  return field_match_type_case() == kExact;
}
inline bool FieldMatch::has_exact() const {
  return _internal_has_exact();
}
inline void FieldMatch::set_has_exact() {
  _oneof_case_[0] = kExact;
}
inline void FieldMatch::clear_exact() {
  if (_internal_has_exact()) {
    if (GetArenaForAllocation() == nullptr) {
      delete field_match_type_.exact_;
    }
    clear_has_field_match_type();
  }
}
inline ::p4::v1::FieldMatch_Exact* FieldMatch::release_exact() {
  // @@protoc_insertion_point(field_release:p4.v1.FieldMatch.exact)
  if (_internal_has_exact()) {
    clear_has_field_match_type();
      ::p4::v1::FieldMatch_Exact* temp = field_match_type_.exact_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    field_match_type_.exact_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::FieldMatch_Exact& FieldMatch::_internal_exact() const {
  return _internal_has_exact()
      ? *field_match_type_.exact_
      : reinterpret_cast< ::p4::v1::FieldMatch_Exact&>(::p4::v1::_FieldMatch_Exact_default_instance_);
}
inline const ::p4::v1::FieldMatch_Exact& FieldMatch::exact() const {
  // @@protoc_insertion_point(field_get:p4.v1.FieldMatch.exact)
  return _internal_exact();
}
inline ::p4::v1::FieldMatch_Exact* FieldMatch::unsafe_arena_release_exact() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.FieldMatch.exact)
  if (_internal_has_exact()) {
    clear_has_field_match_type();
    ::p4::v1::FieldMatch_Exact* temp = field_match_type_.exact_;
    field_match_type_.exact_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldMatch::unsafe_arena_set_allocated_exact(::p4::v1::FieldMatch_Exact* exact) {
  clear_field_match_type();
  if (exact) {
    set_has_exact();
    field_match_type_.exact_ = exact;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.FieldMatch.exact)
}
inline ::p4::v1::FieldMatch_Exact* FieldMatch::_internal_mutable_exact() {
  if (!_internal_has_exact()) {
    clear_field_match_type();
    set_has_exact();
    field_match_type_.exact_ = CreateMaybeMessage< ::p4::v1::FieldMatch_Exact >(GetArenaForAllocation());
  }
  return field_match_type_.exact_;
}
inline ::p4::v1::FieldMatch_Exact* FieldMatch::mutable_exact() {
  ::p4::v1::FieldMatch_Exact* _msg = _internal_mutable_exact();
  // @@protoc_insertion_point(field_mutable:p4.v1.FieldMatch.exact)
  return _msg;
}

// .p4.v1.FieldMatch.Ternary ternary = 3;
inline bool FieldMatch::_internal_has_ternary() const {
  return field_match_type_case() == kTernary;
}
inline bool FieldMatch::has_ternary() const {
  return _internal_has_ternary();
}
inline void FieldMatch::set_has_ternary() {
  _oneof_case_[0] = kTernary;
}
inline void FieldMatch::clear_ternary() {
  if (_internal_has_ternary()) {
    if (GetArenaForAllocation() == nullptr) {
      delete field_match_type_.ternary_;
    }
    clear_has_field_match_type();
  }
}
inline ::p4::v1::FieldMatch_Ternary* FieldMatch::release_ternary() {
  // @@protoc_insertion_point(field_release:p4.v1.FieldMatch.ternary)
  if (_internal_has_ternary()) {
    clear_has_field_match_type();
      ::p4::v1::FieldMatch_Ternary* temp = field_match_type_.ternary_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    field_match_type_.ternary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::FieldMatch_Ternary& FieldMatch::_internal_ternary() const {
  return _internal_has_ternary()
      ? *field_match_type_.ternary_
      : reinterpret_cast< ::p4::v1::FieldMatch_Ternary&>(::p4::v1::_FieldMatch_Ternary_default_instance_);
}
inline const ::p4::v1::FieldMatch_Ternary& FieldMatch::ternary() const {
  // @@protoc_insertion_point(field_get:p4.v1.FieldMatch.ternary)
  return _internal_ternary();
}
inline ::p4::v1::FieldMatch_Ternary* FieldMatch::unsafe_arena_release_ternary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.FieldMatch.ternary)
  if (_internal_has_ternary()) {
    clear_has_field_match_type();
    ::p4::v1::FieldMatch_Ternary* temp = field_match_type_.ternary_;
    field_match_type_.ternary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldMatch::unsafe_arena_set_allocated_ternary(::p4::v1::FieldMatch_Ternary* ternary) {
  clear_field_match_type();
  if (ternary) {
    set_has_ternary();
    field_match_type_.ternary_ = ternary;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.FieldMatch.ternary)
}
inline ::p4::v1::FieldMatch_Ternary* FieldMatch::_internal_mutable_ternary() {
  if (!_internal_has_ternary()) {
    clear_field_match_type();
    set_has_ternary();
    field_match_type_.ternary_ = CreateMaybeMessage< ::p4::v1::FieldMatch_Ternary >(GetArenaForAllocation());
  }
  return field_match_type_.ternary_;
}
inline ::p4::v1::FieldMatch_Ternary* FieldMatch::mutable_ternary() {
  ::p4::v1::FieldMatch_Ternary* _msg = _internal_mutable_ternary();
  // @@protoc_insertion_point(field_mutable:p4.v1.FieldMatch.ternary)
  return _msg;
}

// .p4.v1.FieldMatch.LPM lpm = 4;
inline bool FieldMatch::_internal_has_lpm() const {
  return field_match_type_case() == kLpm;
}
inline bool FieldMatch::has_lpm() const {
  return _internal_has_lpm();
}
inline void FieldMatch::set_has_lpm() {
  _oneof_case_[0] = kLpm;
}
inline void FieldMatch::clear_lpm() {
  if (_internal_has_lpm()) {
    if (GetArenaForAllocation() == nullptr) {
      delete field_match_type_.lpm_;
    }
    clear_has_field_match_type();
  }
}
inline ::p4::v1::FieldMatch_LPM* FieldMatch::release_lpm() {
  // @@protoc_insertion_point(field_release:p4.v1.FieldMatch.lpm)
  if (_internal_has_lpm()) {
    clear_has_field_match_type();
      ::p4::v1::FieldMatch_LPM* temp = field_match_type_.lpm_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    field_match_type_.lpm_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::FieldMatch_LPM& FieldMatch::_internal_lpm() const {
  return _internal_has_lpm()
      ? *field_match_type_.lpm_
      : reinterpret_cast< ::p4::v1::FieldMatch_LPM&>(::p4::v1::_FieldMatch_LPM_default_instance_);
}
inline const ::p4::v1::FieldMatch_LPM& FieldMatch::lpm() const {
  // @@protoc_insertion_point(field_get:p4.v1.FieldMatch.lpm)
  return _internal_lpm();
}
inline ::p4::v1::FieldMatch_LPM* FieldMatch::unsafe_arena_release_lpm() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.FieldMatch.lpm)
  if (_internal_has_lpm()) {
    clear_has_field_match_type();
    ::p4::v1::FieldMatch_LPM* temp = field_match_type_.lpm_;
    field_match_type_.lpm_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldMatch::unsafe_arena_set_allocated_lpm(::p4::v1::FieldMatch_LPM* lpm) {
  clear_field_match_type();
  if (lpm) {
    set_has_lpm();
    field_match_type_.lpm_ = lpm;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.FieldMatch.lpm)
}
inline ::p4::v1::FieldMatch_LPM* FieldMatch::_internal_mutable_lpm() {
  if (!_internal_has_lpm()) {
    clear_field_match_type();
    set_has_lpm();
    field_match_type_.lpm_ = CreateMaybeMessage< ::p4::v1::FieldMatch_LPM >(GetArenaForAllocation());
  }
  return field_match_type_.lpm_;
}
inline ::p4::v1::FieldMatch_LPM* FieldMatch::mutable_lpm() {
  ::p4::v1::FieldMatch_LPM* _msg = _internal_mutable_lpm();
  // @@protoc_insertion_point(field_mutable:p4.v1.FieldMatch.lpm)
  return _msg;
}

// .p4.v1.FieldMatch.Range range = 6;
inline bool FieldMatch::_internal_has_range() const {
  return field_match_type_case() == kRange;
}
inline bool FieldMatch::has_range() const {
  return _internal_has_range();
}
inline void FieldMatch::set_has_range() {
  _oneof_case_[0] = kRange;
}
inline void FieldMatch::clear_range() {
  if (_internal_has_range()) {
    if (GetArenaForAllocation() == nullptr) {
      delete field_match_type_.range_;
    }
    clear_has_field_match_type();
  }
}
inline ::p4::v1::FieldMatch_Range* FieldMatch::release_range() {
  // @@protoc_insertion_point(field_release:p4.v1.FieldMatch.range)
  if (_internal_has_range()) {
    clear_has_field_match_type();
      ::p4::v1::FieldMatch_Range* temp = field_match_type_.range_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    field_match_type_.range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::FieldMatch_Range& FieldMatch::_internal_range() const {
  return _internal_has_range()
      ? *field_match_type_.range_
      : reinterpret_cast< ::p4::v1::FieldMatch_Range&>(::p4::v1::_FieldMatch_Range_default_instance_);
}
inline const ::p4::v1::FieldMatch_Range& FieldMatch::range() const {
  // @@protoc_insertion_point(field_get:p4.v1.FieldMatch.range)
  return _internal_range();
}
inline ::p4::v1::FieldMatch_Range* FieldMatch::unsafe_arena_release_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.FieldMatch.range)
  if (_internal_has_range()) {
    clear_has_field_match_type();
    ::p4::v1::FieldMatch_Range* temp = field_match_type_.range_;
    field_match_type_.range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldMatch::unsafe_arena_set_allocated_range(::p4::v1::FieldMatch_Range* range) {
  clear_field_match_type();
  if (range) {
    set_has_range();
    field_match_type_.range_ = range;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.FieldMatch.range)
}
inline ::p4::v1::FieldMatch_Range* FieldMatch::_internal_mutable_range() {
  if (!_internal_has_range()) {
    clear_field_match_type();
    set_has_range();
    field_match_type_.range_ = CreateMaybeMessage< ::p4::v1::FieldMatch_Range >(GetArenaForAllocation());
  }
  return field_match_type_.range_;
}
inline ::p4::v1::FieldMatch_Range* FieldMatch::mutable_range() {
  ::p4::v1::FieldMatch_Range* _msg = _internal_mutable_range();
  // @@protoc_insertion_point(field_mutable:p4.v1.FieldMatch.range)
  return _msg;
}

// .p4.v1.FieldMatch.Optional optional = 7;
inline bool FieldMatch::_internal_has_optional() const {
  return field_match_type_case() == kOptional;
}
inline bool FieldMatch::has_optional() const {
  return _internal_has_optional();
}
inline void FieldMatch::set_has_optional() {
  _oneof_case_[0] = kOptional;
}
inline void FieldMatch::clear_optional() {
  if (_internal_has_optional()) {
    if (GetArenaForAllocation() == nullptr) {
      delete field_match_type_.optional_;
    }
    clear_has_field_match_type();
  }
}
inline ::p4::v1::FieldMatch_Optional* FieldMatch::release_optional() {
  // @@protoc_insertion_point(field_release:p4.v1.FieldMatch.optional)
  if (_internal_has_optional()) {
    clear_has_field_match_type();
      ::p4::v1::FieldMatch_Optional* temp = field_match_type_.optional_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    field_match_type_.optional_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::FieldMatch_Optional& FieldMatch::_internal_optional() const {
  return _internal_has_optional()
      ? *field_match_type_.optional_
      : reinterpret_cast< ::p4::v1::FieldMatch_Optional&>(::p4::v1::_FieldMatch_Optional_default_instance_);
}
inline const ::p4::v1::FieldMatch_Optional& FieldMatch::optional() const {
  // @@protoc_insertion_point(field_get:p4.v1.FieldMatch.optional)
  return _internal_optional();
}
inline ::p4::v1::FieldMatch_Optional* FieldMatch::unsafe_arena_release_optional() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.FieldMatch.optional)
  if (_internal_has_optional()) {
    clear_has_field_match_type();
    ::p4::v1::FieldMatch_Optional* temp = field_match_type_.optional_;
    field_match_type_.optional_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldMatch::unsafe_arena_set_allocated_optional(::p4::v1::FieldMatch_Optional* optional) {
  clear_field_match_type();
  if (optional) {
    set_has_optional();
    field_match_type_.optional_ = optional;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.FieldMatch.optional)
}
inline ::p4::v1::FieldMatch_Optional* FieldMatch::_internal_mutable_optional() {
  if (!_internal_has_optional()) {
    clear_field_match_type();
    set_has_optional();
    field_match_type_.optional_ = CreateMaybeMessage< ::p4::v1::FieldMatch_Optional >(GetArenaForAllocation());
  }
  return field_match_type_.optional_;
}
inline ::p4::v1::FieldMatch_Optional* FieldMatch::mutable_optional() {
  ::p4::v1::FieldMatch_Optional* _msg = _internal_mutable_optional();
  // @@protoc_insertion_point(field_mutable:p4.v1.FieldMatch.optional)
  return _msg;
}

// .google.protobuf.Any other = 100;
inline bool FieldMatch::_internal_has_other() const {
  return field_match_type_case() == kOther;
}
inline bool FieldMatch::has_other() const {
  return _internal_has_other();
}
inline void FieldMatch::set_has_other() {
  _oneof_case_[0] = kOther;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* FieldMatch::release_other() {
  // @@protoc_insertion_point(field_release:p4.v1.FieldMatch.other)
  if (_internal_has_other()) {
    clear_has_field_match_type();
      ::PROTOBUF_NAMESPACE_ID::Any* temp = field_match_type_.other_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    field_match_type_.other_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& FieldMatch::_internal_other() const {
  return _internal_has_other()
      ? *field_match_type_.other_
      : reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::Any&>(::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& FieldMatch::other() const {
  // @@protoc_insertion_point(field_get:p4.v1.FieldMatch.other)
  return _internal_other();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* FieldMatch::unsafe_arena_release_other() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.FieldMatch.other)
  if (_internal_has_other()) {
    clear_has_field_match_type();
    ::PROTOBUF_NAMESPACE_ID::Any* temp = field_match_type_.other_;
    field_match_type_.other_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldMatch::unsafe_arena_set_allocated_other(::PROTOBUF_NAMESPACE_ID::Any* other) {
  clear_field_match_type();
  if (other) {
    set_has_other();
    field_match_type_.other_ = other;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.FieldMatch.other)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* FieldMatch::_internal_mutable_other() {
  if (!_internal_has_other()) {
    clear_field_match_type();
    set_has_other();
    field_match_type_.other_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Any >(GetArenaForAllocation());
  }
  return field_match_type_.other_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* FieldMatch::mutable_other() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_other();
  // @@protoc_insertion_point(field_mutable:p4.v1.FieldMatch.other)
  return _msg;
}

inline bool FieldMatch::has_field_match_type() const {
  return field_match_type_case() != FIELD_MATCH_TYPE_NOT_SET;
}
inline void FieldMatch::clear_has_field_match_type() {
  _oneof_case_[0] = FIELD_MATCH_TYPE_NOT_SET;
}
inline FieldMatch::FieldMatchTypeCase FieldMatch::field_match_type_case() const {
  return FieldMatch::FieldMatchTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TableAction

// .p4.v1.Action action = 1;
inline bool TableAction::_internal_has_action() const {
  return type_case() == kAction;
}
inline bool TableAction::has_action() const {
  return _internal_has_action();
}
inline void TableAction::set_has_action() {
  _oneof_case_[0] = kAction;
}
inline void TableAction::clear_action() {
  if (_internal_has_action()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.action_;
    }
    clear_has_type();
  }
}
inline ::p4::v1::Action* TableAction::release_action() {
  // @@protoc_insertion_point(field_release:p4.v1.TableAction.action)
  if (_internal_has_action()) {
    clear_has_type();
      ::p4::v1::Action* temp = type_.action_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::Action& TableAction::_internal_action() const {
  return _internal_has_action()
      ? *type_.action_
      : reinterpret_cast< ::p4::v1::Action&>(::p4::v1::_Action_default_instance_);
}
inline const ::p4::v1::Action& TableAction::action() const {
  // @@protoc_insertion_point(field_get:p4.v1.TableAction.action)
  return _internal_action();
}
inline ::p4::v1::Action* TableAction::unsafe_arena_release_action() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.TableAction.action)
  if (_internal_has_action()) {
    clear_has_type();
    ::p4::v1::Action* temp = type_.action_;
    type_.action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TableAction::unsafe_arena_set_allocated_action(::p4::v1::Action* action) {
  clear_type();
  if (action) {
    set_has_action();
    type_.action_ = action;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.TableAction.action)
}
inline ::p4::v1::Action* TableAction::_internal_mutable_action() {
  if (!_internal_has_action()) {
    clear_type();
    set_has_action();
    type_.action_ = CreateMaybeMessage< ::p4::v1::Action >(GetArenaForAllocation());
  }
  return type_.action_;
}
inline ::p4::v1::Action* TableAction::mutable_action() {
  ::p4::v1::Action* _msg = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:p4.v1.TableAction.action)
  return _msg;
}

// uint32 action_profile_member_id = 2;
inline bool TableAction::_internal_has_action_profile_member_id() const {
  return type_case() == kActionProfileMemberId;
}
inline bool TableAction::has_action_profile_member_id() const {
  return _internal_has_action_profile_member_id();
}
inline void TableAction::set_has_action_profile_member_id() {
  _oneof_case_[0] = kActionProfileMemberId;
}
inline void TableAction::clear_action_profile_member_id() {
  if (_internal_has_action_profile_member_id()) {
    type_.action_profile_member_id_ = 0u;
    clear_has_type();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TableAction::_internal_action_profile_member_id() const {
  if (_internal_has_action_profile_member_id()) {
    return type_.action_profile_member_id_;
  }
  return 0u;
}
inline void TableAction::_internal_set_action_profile_member_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  if (!_internal_has_action_profile_member_id()) {
    clear_type();
    set_has_action_profile_member_id();
  }
  type_.action_profile_member_id_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TableAction::action_profile_member_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.TableAction.action_profile_member_id)
  return _internal_action_profile_member_id();
}
inline void TableAction::set_action_profile_member_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_action_profile_member_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.TableAction.action_profile_member_id)
}

// uint32 action_profile_group_id = 3;
inline bool TableAction::_internal_has_action_profile_group_id() const {
  return type_case() == kActionProfileGroupId;
}
inline bool TableAction::has_action_profile_group_id() const {
  return _internal_has_action_profile_group_id();
}
inline void TableAction::set_has_action_profile_group_id() {
  _oneof_case_[0] = kActionProfileGroupId;
}
inline void TableAction::clear_action_profile_group_id() {
  if (_internal_has_action_profile_group_id()) {
    type_.action_profile_group_id_ = 0u;
    clear_has_type();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TableAction::_internal_action_profile_group_id() const {
  if (_internal_has_action_profile_group_id()) {
    return type_.action_profile_group_id_;
  }
  return 0u;
}
inline void TableAction::_internal_set_action_profile_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  if (!_internal_has_action_profile_group_id()) {
    clear_type();
    set_has_action_profile_group_id();
  }
  type_.action_profile_group_id_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TableAction::action_profile_group_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.TableAction.action_profile_group_id)
  return _internal_action_profile_group_id();
}
inline void TableAction::set_action_profile_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_action_profile_group_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.TableAction.action_profile_group_id)
}

// .p4.v1.ActionProfileActionSet action_profile_action_set = 4;
inline bool TableAction::_internal_has_action_profile_action_set() const {
  return type_case() == kActionProfileActionSet;
}
inline bool TableAction::has_action_profile_action_set() const {
  return _internal_has_action_profile_action_set();
}
inline void TableAction::set_has_action_profile_action_set() {
  _oneof_case_[0] = kActionProfileActionSet;
}
inline void TableAction::clear_action_profile_action_set() {
  if (_internal_has_action_profile_action_set()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.action_profile_action_set_;
    }
    clear_has_type();
  }
}
inline ::p4::v1::ActionProfileActionSet* TableAction::release_action_profile_action_set() {
  // @@protoc_insertion_point(field_release:p4.v1.TableAction.action_profile_action_set)
  if (_internal_has_action_profile_action_set()) {
    clear_has_type();
      ::p4::v1::ActionProfileActionSet* temp = type_.action_profile_action_set_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.action_profile_action_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::ActionProfileActionSet& TableAction::_internal_action_profile_action_set() const {
  return _internal_has_action_profile_action_set()
      ? *type_.action_profile_action_set_
      : reinterpret_cast< ::p4::v1::ActionProfileActionSet&>(::p4::v1::_ActionProfileActionSet_default_instance_);
}
inline const ::p4::v1::ActionProfileActionSet& TableAction::action_profile_action_set() const {
  // @@protoc_insertion_point(field_get:p4.v1.TableAction.action_profile_action_set)
  return _internal_action_profile_action_set();
}
inline ::p4::v1::ActionProfileActionSet* TableAction::unsafe_arena_release_action_profile_action_set() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.TableAction.action_profile_action_set)
  if (_internal_has_action_profile_action_set()) {
    clear_has_type();
    ::p4::v1::ActionProfileActionSet* temp = type_.action_profile_action_set_;
    type_.action_profile_action_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TableAction::unsafe_arena_set_allocated_action_profile_action_set(::p4::v1::ActionProfileActionSet* action_profile_action_set) {
  clear_type();
  if (action_profile_action_set) {
    set_has_action_profile_action_set();
    type_.action_profile_action_set_ = action_profile_action_set;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.TableAction.action_profile_action_set)
}
inline ::p4::v1::ActionProfileActionSet* TableAction::_internal_mutable_action_profile_action_set() {
  if (!_internal_has_action_profile_action_set()) {
    clear_type();
    set_has_action_profile_action_set();
    type_.action_profile_action_set_ = CreateMaybeMessage< ::p4::v1::ActionProfileActionSet >(GetArenaForAllocation());
  }
  return type_.action_profile_action_set_;
}
inline ::p4::v1::ActionProfileActionSet* TableAction::mutable_action_profile_action_set() {
  ::p4::v1::ActionProfileActionSet* _msg = _internal_mutable_action_profile_action_set();
  // @@protoc_insertion_point(field_mutable:p4.v1.TableAction.action_profile_action_set)
  return _msg;
}

inline bool TableAction::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void TableAction::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline TableAction::TypeCase TableAction::type_case() const {
  return TableAction::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Action_Param

// uint32 param_id = 2;
inline void Action_Param::clear_param_id() {
  param_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Action_Param::_internal_param_id() const {
  return param_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Action_Param::param_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.Action.Param.param_id)
  return _internal_param_id();
}
inline void Action_Param::_internal_set_param_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  param_id_ = value;
}
inline void Action_Param::set_param_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_param_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.Action.Param.param_id)
}

// bytes value = 3;
inline void Action_Param::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& Action_Param::value() const {
  // @@protoc_insertion_point(field_get:p4.v1.Action.Param.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Action_Param::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.Action.Param.value)
}
inline std::string* Action_Param::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:p4.v1.Action.Param.value)
  return _s;
}
inline const std::string& Action_Param::_internal_value() const {
  return value_.Get();
}
inline void Action_Param::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Action_Param::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Action_Param::release_value() {
  // @@protoc_insertion_point(field_release:p4.v1.Action.Param.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Action_Param::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.Action.Param.value)
}

// -------------------------------------------------------------------

// Action

// uint32 action_id = 1;
inline void Action::clear_action_id() {
  action_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Action::_internal_action_id() const {
  return action_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Action::action_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.Action.action_id)
  return _internal_action_id();
}
inline void Action::_internal_set_action_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  action_id_ = value;
}
inline void Action::set_action_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_action_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.Action.action_id)
}

// repeated .p4.v1.Action.Param params = 4;
inline int Action::_internal_params_size() const {
  return params_.size();
}
inline int Action::params_size() const {
  return _internal_params_size();
}
inline void Action::clear_params() {
  params_.Clear();
}
inline ::p4::v1::Action_Param* Action::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:p4.v1.Action.params)
  return params_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Action_Param >*
Action::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:p4.v1.Action.params)
  return &params_;
}
inline const ::p4::v1::Action_Param& Action::_internal_params(int index) const {
  return params_.Get(index);
}
inline const ::p4::v1::Action_Param& Action::params(int index) const {
  // @@protoc_insertion_point(field_get:p4.v1.Action.params)
  return _internal_params(index);
}
inline ::p4::v1::Action_Param* Action::_internal_add_params() {
  return params_.Add();
}
inline ::p4::v1::Action_Param* Action::add_params() {
  ::p4::v1::Action_Param* _add = _internal_add_params();
  // @@protoc_insertion_point(field_add:p4.v1.Action.params)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Action_Param >&
Action::params() const {
  // @@protoc_insertion_point(field_list:p4.v1.Action.params)
  return params_;
}

// -------------------------------------------------------------------

// ActionProfileActionSet

// repeated .p4.v1.ActionProfileAction action_profile_actions = 1;
inline int ActionProfileActionSet::_internal_action_profile_actions_size() const {
  return action_profile_actions_.size();
}
inline int ActionProfileActionSet::action_profile_actions_size() const {
  return _internal_action_profile_actions_size();
}
inline void ActionProfileActionSet::clear_action_profile_actions() {
  action_profile_actions_.Clear();
}
inline ::p4::v1::ActionProfileAction* ActionProfileActionSet::mutable_action_profile_actions(int index) {
  // @@protoc_insertion_point(field_mutable:p4.v1.ActionProfileActionSet.action_profile_actions)
  return action_profile_actions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::ActionProfileAction >*
ActionProfileActionSet::mutable_action_profile_actions() {
  // @@protoc_insertion_point(field_mutable_list:p4.v1.ActionProfileActionSet.action_profile_actions)
  return &action_profile_actions_;
}
inline const ::p4::v1::ActionProfileAction& ActionProfileActionSet::_internal_action_profile_actions(int index) const {
  return action_profile_actions_.Get(index);
}
inline const ::p4::v1::ActionProfileAction& ActionProfileActionSet::action_profile_actions(int index) const {
  // @@protoc_insertion_point(field_get:p4.v1.ActionProfileActionSet.action_profile_actions)
  return _internal_action_profile_actions(index);
}
inline ::p4::v1::ActionProfileAction* ActionProfileActionSet::_internal_add_action_profile_actions() {
  return action_profile_actions_.Add();
}
inline ::p4::v1::ActionProfileAction* ActionProfileActionSet::add_action_profile_actions() {
  ::p4::v1::ActionProfileAction* _add = _internal_add_action_profile_actions();
  // @@protoc_insertion_point(field_add:p4.v1.ActionProfileActionSet.action_profile_actions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::ActionProfileAction >&
ActionProfileActionSet::action_profile_actions() const {
  // @@protoc_insertion_point(field_list:p4.v1.ActionProfileActionSet.action_profile_actions)
  return action_profile_actions_;
}

// -------------------------------------------------------------------

// ActionProfileAction

// .p4.v1.Action action = 1;
inline bool ActionProfileAction::_internal_has_action() const {
  return this != internal_default_instance() && action_ != nullptr;
}
inline bool ActionProfileAction::has_action() const {
  return _internal_has_action();
}
inline void ActionProfileAction::clear_action() {
  if (GetArenaForAllocation() == nullptr && action_ != nullptr) {
    delete action_;
  }
  action_ = nullptr;
}
inline const ::p4::v1::Action& ActionProfileAction::_internal_action() const {
  const ::p4::v1::Action* p = action_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::Action&>(
      ::p4::v1::_Action_default_instance_);
}
inline const ::p4::v1::Action& ActionProfileAction::action() const {
  // @@protoc_insertion_point(field_get:p4.v1.ActionProfileAction.action)
  return _internal_action();
}
inline void ActionProfileAction::unsafe_arena_set_allocated_action(
    ::p4::v1::Action* action) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(action_);
  }
  action_ = action;
  if (action) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.ActionProfileAction.action)
}
inline ::p4::v1::Action* ActionProfileAction::release_action() {
  
  ::p4::v1::Action* temp = action_;
  action_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::Action* ActionProfileAction::unsafe_arena_release_action() {
  // @@protoc_insertion_point(field_release:p4.v1.ActionProfileAction.action)
  
  ::p4::v1::Action* temp = action_;
  action_ = nullptr;
  return temp;
}
inline ::p4::v1::Action* ActionProfileAction::_internal_mutable_action() {
  
  if (action_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::Action>(GetArenaForAllocation());
    action_ = p;
  }
  return action_;
}
inline ::p4::v1::Action* ActionProfileAction::mutable_action() {
  ::p4::v1::Action* _msg = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:p4.v1.ActionProfileAction.action)
  return _msg;
}
inline void ActionProfileAction::set_allocated_action(::p4::v1::Action* action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete action_;
  }
  if (action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::Action>::GetOwningArena(action);
    if (message_arena != submessage_arena) {
      action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action, submessage_arena);
    }
    
  } else {
    
  }
  action_ = action;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.ActionProfileAction.action)
}

// int32 weight = 2;
inline void ActionProfileAction::clear_weight() {
  weight_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ActionProfileAction::_internal_weight() const {
  return weight_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ActionProfileAction::weight() const {
  // @@protoc_insertion_point(field_get:p4.v1.ActionProfileAction.weight)
  return _internal_weight();
}
inline void ActionProfileAction::_internal_set_weight(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  weight_ = value;
}
inline void ActionProfileAction::set_weight(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:p4.v1.ActionProfileAction.weight)
}

// int32 watch = 3 [deprecated = true];
inline bool ActionProfileAction::_internal_has_watch() const {
  return watch_kind_case() == kWatch;
}
inline bool ActionProfileAction::has_watch() const {
  return _internal_has_watch();
}
inline void ActionProfileAction::set_has_watch() {
  _oneof_case_[0] = kWatch;
}
inline void ActionProfileAction::clear_watch() {
  if (_internal_has_watch()) {
    watch_kind_.watch_ = 0;
    clear_has_watch_kind();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ActionProfileAction::_internal_watch() const {
  if (_internal_has_watch()) {
    return watch_kind_.watch_;
  }
  return 0;
}
inline void ActionProfileAction::_internal_set_watch(::PROTOBUF_NAMESPACE_ID::int32 value) {
  if (!_internal_has_watch()) {
    clear_watch_kind();
    set_has_watch();
  }
  watch_kind_.watch_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ActionProfileAction::watch() const {
  // @@protoc_insertion_point(field_get:p4.v1.ActionProfileAction.watch)
  return _internal_watch();
}
inline void ActionProfileAction::set_watch(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_watch(value);
  // @@protoc_insertion_point(field_set:p4.v1.ActionProfileAction.watch)
}

// bytes watch_port = 4;
inline bool ActionProfileAction::_internal_has_watch_port() const {
  return watch_kind_case() == kWatchPort;
}
inline bool ActionProfileAction::has_watch_port() const {
  return _internal_has_watch_port();
}
inline void ActionProfileAction::set_has_watch_port() {
  _oneof_case_[0] = kWatchPort;
}
inline void ActionProfileAction::clear_watch_port() {
  if (_internal_has_watch_port()) {
    watch_kind_.watch_port_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_watch_kind();
  }
}
inline const std::string& ActionProfileAction::watch_port() const {
  // @@protoc_insertion_point(field_get:p4.v1.ActionProfileAction.watch_port)
  return _internal_watch_port();
}
template <typename ArgT0, typename... ArgT>
inline void ActionProfileAction::set_watch_port(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_watch_port()) {
    clear_watch_kind();
    set_has_watch_port();
    watch_kind_.watch_port_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  watch_kind_.watch_port_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.ActionProfileAction.watch_port)
}
inline std::string* ActionProfileAction::mutable_watch_port() {
  std::string* _s = _internal_mutable_watch_port();
  // @@protoc_insertion_point(field_mutable:p4.v1.ActionProfileAction.watch_port)
  return _s;
}
inline const std::string& ActionProfileAction::_internal_watch_port() const {
  if (_internal_has_watch_port()) {
    return watch_kind_.watch_port_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ActionProfileAction::_internal_set_watch_port(const std::string& value) {
  if (!_internal_has_watch_port()) {
    clear_watch_kind();
    set_has_watch_port();
    watch_kind_.watch_port_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  watch_kind_.watch_port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActionProfileAction::_internal_mutable_watch_port() {
  if (!_internal_has_watch_port()) {
    clear_watch_kind();
    set_has_watch_port();
    watch_kind_.watch_port_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return watch_kind_.watch_port_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActionProfileAction::release_watch_port() {
  // @@protoc_insertion_point(field_release:p4.v1.ActionProfileAction.watch_port)
  if (_internal_has_watch_port()) {
    clear_has_watch_kind();
    return watch_kind_.watch_port_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void ActionProfileAction::set_allocated_watch_port(std::string* watch_port) {
  if (has_watch_kind()) {
    clear_watch_kind();
  }
  if (watch_port != nullptr) {
    set_has_watch_port();
    watch_kind_.watch_port_.UnsafeSetDefault(watch_port);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(watch_port);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:p4.v1.ActionProfileAction.watch_port)
}

inline bool ActionProfileAction::has_watch_kind() const {
  return watch_kind_case() != WATCH_KIND_NOT_SET;
}
inline void ActionProfileAction::clear_has_watch_kind() {
  _oneof_case_[0] = WATCH_KIND_NOT_SET;
}
inline ActionProfileAction::WatchKindCase ActionProfileAction::watch_kind_case() const {
  return ActionProfileAction::WatchKindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionProfileMember

// uint32 action_profile_id = 1;
inline void ActionProfileMember::clear_action_profile_id() {
  action_profile_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ActionProfileMember::_internal_action_profile_id() const {
  return action_profile_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ActionProfileMember::action_profile_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.ActionProfileMember.action_profile_id)
  return _internal_action_profile_id();
}
inline void ActionProfileMember::_internal_set_action_profile_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  action_profile_id_ = value;
}
inline void ActionProfileMember::set_action_profile_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_action_profile_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.ActionProfileMember.action_profile_id)
}

// uint32 member_id = 2;
inline void ActionProfileMember::clear_member_id() {
  member_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ActionProfileMember::_internal_member_id() const {
  return member_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ActionProfileMember::member_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.ActionProfileMember.member_id)
  return _internal_member_id();
}
inline void ActionProfileMember::_internal_set_member_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  member_id_ = value;
}
inline void ActionProfileMember::set_member_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_member_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.ActionProfileMember.member_id)
}

// .p4.v1.Action action = 3;
inline bool ActionProfileMember::_internal_has_action() const {
  return this != internal_default_instance() && action_ != nullptr;
}
inline bool ActionProfileMember::has_action() const {
  return _internal_has_action();
}
inline void ActionProfileMember::clear_action() {
  if (GetArenaForAllocation() == nullptr && action_ != nullptr) {
    delete action_;
  }
  action_ = nullptr;
}
inline const ::p4::v1::Action& ActionProfileMember::_internal_action() const {
  const ::p4::v1::Action* p = action_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::Action&>(
      ::p4::v1::_Action_default_instance_);
}
inline const ::p4::v1::Action& ActionProfileMember::action() const {
  // @@protoc_insertion_point(field_get:p4.v1.ActionProfileMember.action)
  return _internal_action();
}
inline void ActionProfileMember::unsafe_arena_set_allocated_action(
    ::p4::v1::Action* action) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(action_);
  }
  action_ = action;
  if (action) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.ActionProfileMember.action)
}
inline ::p4::v1::Action* ActionProfileMember::release_action() {
  
  ::p4::v1::Action* temp = action_;
  action_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::Action* ActionProfileMember::unsafe_arena_release_action() {
  // @@protoc_insertion_point(field_release:p4.v1.ActionProfileMember.action)
  
  ::p4::v1::Action* temp = action_;
  action_ = nullptr;
  return temp;
}
inline ::p4::v1::Action* ActionProfileMember::_internal_mutable_action() {
  
  if (action_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::Action>(GetArenaForAllocation());
    action_ = p;
  }
  return action_;
}
inline ::p4::v1::Action* ActionProfileMember::mutable_action() {
  ::p4::v1::Action* _msg = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:p4.v1.ActionProfileMember.action)
  return _msg;
}
inline void ActionProfileMember::set_allocated_action(::p4::v1::Action* action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete action_;
  }
  if (action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::Action>::GetOwningArena(action);
    if (message_arena != submessage_arena) {
      action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action, submessage_arena);
    }
    
  } else {
    
  }
  action_ = action;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.ActionProfileMember.action)
}

// -------------------------------------------------------------------

// ActionProfileGroup_Member

// uint32 member_id = 1;
inline void ActionProfileGroup_Member::clear_member_id() {
  member_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ActionProfileGroup_Member::_internal_member_id() const {
  return member_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ActionProfileGroup_Member::member_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.ActionProfileGroup.Member.member_id)
  return _internal_member_id();
}
inline void ActionProfileGroup_Member::_internal_set_member_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  member_id_ = value;
}
inline void ActionProfileGroup_Member::set_member_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_member_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.ActionProfileGroup.Member.member_id)
}

// int32 weight = 2;
inline void ActionProfileGroup_Member::clear_weight() {
  weight_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ActionProfileGroup_Member::_internal_weight() const {
  return weight_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ActionProfileGroup_Member::weight() const {
  // @@protoc_insertion_point(field_get:p4.v1.ActionProfileGroup.Member.weight)
  return _internal_weight();
}
inline void ActionProfileGroup_Member::_internal_set_weight(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  weight_ = value;
}
inline void ActionProfileGroup_Member::set_weight(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:p4.v1.ActionProfileGroup.Member.weight)
}

// int32 watch = 3 [deprecated = true];
inline bool ActionProfileGroup_Member::_internal_has_watch() const {
  return watch_kind_case() == kWatch;
}
inline bool ActionProfileGroup_Member::has_watch() const {
  return _internal_has_watch();
}
inline void ActionProfileGroup_Member::set_has_watch() {
  _oneof_case_[0] = kWatch;
}
inline void ActionProfileGroup_Member::clear_watch() {
  if (_internal_has_watch()) {
    watch_kind_.watch_ = 0;
    clear_has_watch_kind();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ActionProfileGroup_Member::_internal_watch() const {
  if (_internal_has_watch()) {
    return watch_kind_.watch_;
  }
  return 0;
}
inline void ActionProfileGroup_Member::_internal_set_watch(::PROTOBUF_NAMESPACE_ID::int32 value) {
  if (!_internal_has_watch()) {
    clear_watch_kind();
    set_has_watch();
  }
  watch_kind_.watch_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ActionProfileGroup_Member::watch() const {
  // @@protoc_insertion_point(field_get:p4.v1.ActionProfileGroup.Member.watch)
  return _internal_watch();
}
inline void ActionProfileGroup_Member::set_watch(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_watch(value);
  // @@protoc_insertion_point(field_set:p4.v1.ActionProfileGroup.Member.watch)
}

// bytes watch_port = 4;
inline bool ActionProfileGroup_Member::_internal_has_watch_port() const {
  return watch_kind_case() == kWatchPort;
}
inline bool ActionProfileGroup_Member::has_watch_port() const {
  return _internal_has_watch_port();
}
inline void ActionProfileGroup_Member::set_has_watch_port() {
  _oneof_case_[0] = kWatchPort;
}
inline void ActionProfileGroup_Member::clear_watch_port() {
  if (_internal_has_watch_port()) {
    watch_kind_.watch_port_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_watch_kind();
  }
}
inline const std::string& ActionProfileGroup_Member::watch_port() const {
  // @@protoc_insertion_point(field_get:p4.v1.ActionProfileGroup.Member.watch_port)
  return _internal_watch_port();
}
template <typename ArgT0, typename... ArgT>
inline void ActionProfileGroup_Member::set_watch_port(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_watch_port()) {
    clear_watch_kind();
    set_has_watch_port();
    watch_kind_.watch_port_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  watch_kind_.watch_port_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.ActionProfileGroup.Member.watch_port)
}
inline std::string* ActionProfileGroup_Member::mutable_watch_port() {
  std::string* _s = _internal_mutable_watch_port();
  // @@protoc_insertion_point(field_mutable:p4.v1.ActionProfileGroup.Member.watch_port)
  return _s;
}
inline const std::string& ActionProfileGroup_Member::_internal_watch_port() const {
  if (_internal_has_watch_port()) {
    return watch_kind_.watch_port_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ActionProfileGroup_Member::_internal_set_watch_port(const std::string& value) {
  if (!_internal_has_watch_port()) {
    clear_watch_kind();
    set_has_watch_port();
    watch_kind_.watch_port_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  watch_kind_.watch_port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActionProfileGroup_Member::_internal_mutable_watch_port() {
  if (!_internal_has_watch_port()) {
    clear_watch_kind();
    set_has_watch_port();
    watch_kind_.watch_port_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return watch_kind_.watch_port_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActionProfileGroup_Member::release_watch_port() {
  // @@protoc_insertion_point(field_release:p4.v1.ActionProfileGroup.Member.watch_port)
  if (_internal_has_watch_port()) {
    clear_has_watch_kind();
    return watch_kind_.watch_port_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void ActionProfileGroup_Member::set_allocated_watch_port(std::string* watch_port) {
  if (has_watch_kind()) {
    clear_watch_kind();
  }
  if (watch_port != nullptr) {
    set_has_watch_port();
    watch_kind_.watch_port_.UnsafeSetDefault(watch_port);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(watch_port);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:p4.v1.ActionProfileGroup.Member.watch_port)
}

inline bool ActionProfileGroup_Member::has_watch_kind() const {
  return watch_kind_case() != WATCH_KIND_NOT_SET;
}
inline void ActionProfileGroup_Member::clear_has_watch_kind() {
  _oneof_case_[0] = WATCH_KIND_NOT_SET;
}
inline ActionProfileGroup_Member::WatchKindCase ActionProfileGroup_Member::watch_kind_case() const {
  return ActionProfileGroup_Member::WatchKindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionProfileGroup

// uint32 action_profile_id = 1;
inline void ActionProfileGroup::clear_action_profile_id() {
  action_profile_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ActionProfileGroup::_internal_action_profile_id() const {
  return action_profile_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ActionProfileGroup::action_profile_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.ActionProfileGroup.action_profile_id)
  return _internal_action_profile_id();
}
inline void ActionProfileGroup::_internal_set_action_profile_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  action_profile_id_ = value;
}
inline void ActionProfileGroup::set_action_profile_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_action_profile_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.ActionProfileGroup.action_profile_id)
}

// uint32 group_id = 2;
inline void ActionProfileGroup::clear_group_id() {
  group_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ActionProfileGroup::_internal_group_id() const {
  return group_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ActionProfileGroup::group_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.ActionProfileGroup.group_id)
  return _internal_group_id();
}
inline void ActionProfileGroup::_internal_set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  group_id_ = value;
}
inline void ActionProfileGroup::set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.ActionProfileGroup.group_id)
}

// repeated .p4.v1.ActionProfileGroup.Member members = 3;
inline int ActionProfileGroup::_internal_members_size() const {
  return members_.size();
}
inline int ActionProfileGroup::members_size() const {
  return _internal_members_size();
}
inline void ActionProfileGroup::clear_members() {
  members_.Clear();
}
inline ::p4::v1::ActionProfileGroup_Member* ActionProfileGroup::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:p4.v1.ActionProfileGroup.members)
  return members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::ActionProfileGroup_Member >*
ActionProfileGroup::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:p4.v1.ActionProfileGroup.members)
  return &members_;
}
inline const ::p4::v1::ActionProfileGroup_Member& ActionProfileGroup::_internal_members(int index) const {
  return members_.Get(index);
}
inline const ::p4::v1::ActionProfileGroup_Member& ActionProfileGroup::members(int index) const {
  // @@protoc_insertion_point(field_get:p4.v1.ActionProfileGroup.members)
  return _internal_members(index);
}
inline ::p4::v1::ActionProfileGroup_Member* ActionProfileGroup::_internal_add_members() {
  return members_.Add();
}
inline ::p4::v1::ActionProfileGroup_Member* ActionProfileGroup::add_members() {
  ::p4::v1::ActionProfileGroup_Member* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:p4.v1.ActionProfileGroup.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::ActionProfileGroup_Member >&
ActionProfileGroup::members() const {
  // @@protoc_insertion_point(field_list:p4.v1.ActionProfileGroup.members)
  return members_;
}

// int32 max_size = 4;
inline void ActionProfileGroup::clear_max_size() {
  max_size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ActionProfileGroup::_internal_max_size() const {
  return max_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ActionProfileGroup::max_size() const {
  // @@protoc_insertion_point(field_get:p4.v1.ActionProfileGroup.max_size)
  return _internal_max_size();
}
inline void ActionProfileGroup::_internal_set_max_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_size_ = value;
}
inline void ActionProfileGroup::set_max_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_size(value);
  // @@protoc_insertion_point(field_set:p4.v1.ActionProfileGroup.max_size)
}

// -------------------------------------------------------------------

// Index

// int64 index = 1;
inline void Index::clear_index() {
  index_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Index::_internal_index() const {
  return index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Index::index() const {
  // @@protoc_insertion_point(field_get:p4.v1.Index.index)
  return _internal_index();
}
inline void Index::_internal_set_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  index_ = value;
}
inline void Index::set_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:p4.v1.Index.index)
}

// -------------------------------------------------------------------

// MeterEntry

// uint32 meter_id = 1;
inline void MeterEntry::clear_meter_id() {
  meter_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MeterEntry::_internal_meter_id() const {
  return meter_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MeterEntry::meter_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.MeterEntry.meter_id)
  return _internal_meter_id();
}
inline void MeterEntry::_internal_set_meter_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  meter_id_ = value;
}
inline void MeterEntry::set_meter_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_meter_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.MeterEntry.meter_id)
}

// .p4.v1.Index index = 2;
inline bool MeterEntry::_internal_has_index() const {
  return this != internal_default_instance() && index_ != nullptr;
}
inline bool MeterEntry::has_index() const {
  return _internal_has_index();
}
inline void MeterEntry::clear_index() {
  if (GetArenaForAllocation() == nullptr && index_ != nullptr) {
    delete index_;
  }
  index_ = nullptr;
}
inline const ::p4::v1::Index& MeterEntry::_internal_index() const {
  const ::p4::v1::Index* p = index_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::Index&>(
      ::p4::v1::_Index_default_instance_);
}
inline const ::p4::v1::Index& MeterEntry::index() const {
  // @@protoc_insertion_point(field_get:p4.v1.MeterEntry.index)
  return _internal_index();
}
inline void MeterEntry::unsafe_arena_set_allocated_index(
    ::p4::v1::Index* index) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(index_);
  }
  index_ = index;
  if (index) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.MeterEntry.index)
}
inline ::p4::v1::Index* MeterEntry::release_index() {
  
  ::p4::v1::Index* temp = index_;
  index_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::Index* MeterEntry::unsafe_arena_release_index() {
  // @@protoc_insertion_point(field_release:p4.v1.MeterEntry.index)
  
  ::p4::v1::Index* temp = index_;
  index_ = nullptr;
  return temp;
}
inline ::p4::v1::Index* MeterEntry::_internal_mutable_index() {
  
  if (index_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::Index>(GetArenaForAllocation());
    index_ = p;
  }
  return index_;
}
inline ::p4::v1::Index* MeterEntry::mutable_index() {
  ::p4::v1::Index* _msg = _internal_mutable_index();
  // @@protoc_insertion_point(field_mutable:p4.v1.MeterEntry.index)
  return _msg;
}
inline void MeterEntry::set_allocated_index(::p4::v1::Index* index) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete index_;
  }
  if (index) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::Index>::GetOwningArena(index);
    if (message_arena != submessage_arena) {
      index = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, index, submessage_arena);
    }
    
  } else {
    
  }
  index_ = index;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.MeterEntry.index)
}

// .p4.v1.MeterConfig config = 3;
inline bool MeterEntry::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool MeterEntry::has_config() const {
  return _internal_has_config();
}
inline void MeterEntry::clear_config() {
  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::p4::v1::MeterConfig& MeterEntry::_internal_config() const {
  const ::p4::v1::MeterConfig* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::MeterConfig&>(
      ::p4::v1::_MeterConfig_default_instance_);
}
inline const ::p4::v1::MeterConfig& MeterEntry::config() const {
  // @@protoc_insertion_point(field_get:p4.v1.MeterEntry.config)
  return _internal_config();
}
inline void MeterEntry::unsafe_arena_set_allocated_config(
    ::p4::v1::MeterConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.MeterEntry.config)
}
inline ::p4::v1::MeterConfig* MeterEntry::release_config() {
  
  ::p4::v1::MeterConfig* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::MeterConfig* MeterEntry::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:p4.v1.MeterEntry.config)
  
  ::p4::v1::MeterConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::p4::v1::MeterConfig* MeterEntry::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::MeterConfig>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::p4::v1::MeterConfig* MeterEntry::mutable_config() {
  ::p4::v1::MeterConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:p4.v1.MeterEntry.config)
  return _msg;
}
inline void MeterEntry::set_allocated_config(::p4::v1::MeterConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::MeterConfig>::GetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.MeterEntry.config)
}

// -------------------------------------------------------------------

// DirectMeterEntry

// .p4.v1.TableEntry table_entry = 1;
inline bool DirectMeterEntry::_internal_has_table_entry() const {
  return this != internal_default_instance() && table_entry_ != nullptr;
}
inline bool DirectMeterEntry::has_table_entry() const {
  return _internal_has_table_entry();
}
inline void DirectMeterEntry::clear_table_entry() {
  if (GetArenaForAllocation() == nullptr && table_entry_ != nullptr) {
    delete table_entry_;
  }
  table_entry_ = nullptr;
}
inline const ::p4::v1::TableEntry& DirectMeterEntry::_internal_table_entry() const {
  const ::p4::v1::TableEntry* p = table_entry_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::TableEntry&>(
      ::p4::v1::_TableEntry_default_instance_);
}
inline const ::p4::v1::TableEntry& DirectMeterEntry::table_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.DirectMeterEntry.table_entry)
  return _internal_table_entry();
}
inline void DirectMeterEntry::unsafe_arena_set_allocated_table_entry(
    ::p4::v1::TableEntry* table_entry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_entry_);
  }
  table_entry_ = table_entry;
  if (table_entry) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.DirectMeterEntry.table_entry)
}
inline ::p4::v1::TableEntry* DirectMeterEntry::release_table_entry() {
  
  ::p4::v1::TableEntry* temp = table_entry_;
  table_entry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::TableEntry* DirectMeterEntry::unsafe_arena_release_table_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.DirectMeterEntry.table_entry)
  
  ::p4::v1::TableEntry* temp = table_entry_;
  table_entry_ = nullptr;
  return temp;
}
inline ::p4::v1::TableEntry* DirectMeterEntry::_internal_mutable_table_entry() {
  
  if (table_entry_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::TableEntry>(GetArenaForAllocation());
    table_entry_ = p;
  }
  return table_entry_;
}
inline ::p4::v1::TableEntry* DirectMeterEntry::mutable_table_entry() {
  ::p4::v1::TableEntry* _msg = _internal_mutable_table_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.DirectMeterEntry.table_entry)
  return _msg;
}
inline void DirectMeterEntry::set_allocated_table_entry(::p4::v1::TableEntry* table_entry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete table_entry_;
  }
  if (table_entry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::TableEntry>::GetOwningArena(table_entry);
    if (message_arena != submessage_arena) {
      table_entry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_entry, submessage_arena);
    }
    
  } else {
    
  }
  table_entry_ = table_entry;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.DirectMeterEntry.table_entry)
}

// .p4.v1.MeterConfig config = 2;
inline bool DirectMeterEntry::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool DirectMeterEntry::has_config() const {
  return _internal_has_config();
}
inline void DirectMeterEntry::clear_config() {
  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::p4::v1::MeterConfig& DirectMeterEntry::_internal_config() const {
  const ::p4::v1::MeterConfig* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::MeterConfig&>(
      ::p4::v1::_MeterConfig_default_instance_);
}
inline const ::p4::v1::MeterConfig& DirectMeterEntry::config() const {
  // @@protoc_insertion_point(field_get:p4.v1.DirectMeterEntry.config)
  return _internal_config();
}
inline void DirectMeterEntry::unsafe_arena_set_allocated_config(
    ::p4::v1::MeterConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.DirectMeterEntry.config)
}
inline ::p4::v1::MeterConfig* DirectMeterEntry::release_config() {
  
  ::p4::v1::MeterConfig* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::MeterConfig* DirectMeterEntry::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:p4.v1.DirectMeterEntry.config)
  
  ::p4::v1::MeterConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::p4::v1::MeterConfig* DirectMeterEntry::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::MeterConfig>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::p4::v1::MeterConfig* DirectMeterEntry::mutable_config() {
  ::p4::v1::MeterConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:p4.v1.DirectMeterEntry.config)
  return _msg;
}
inline void DirectMeterEntry::set_allocated_config(::p4::v1::MeterConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::MeterConfig>::GetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.DirectMeterEntry.config)
}

// -------------------------------------------------------------------

// MeterConfig

// int64 cir = 1;
inline void MeterConfig::clear_cir() {
  cir_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MeterConfig::_internal_cir() const {
  return cir_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MeterConfig::cir() const {
  // @@protoc_insertion_point(field_get:p4.v1.MeterConfig.cir)
  return _internal_cir();
}
inline void MeterConfig::_internal_set_cir(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  cir_ = value;
}
inline void MeterConfig::set_cir(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_cir(value);
  // @@protoc_insertion_point(field_set:p4.v1.MeterConfig.cir)
}

// int64 cburst = 2;
inline void MeterConfig::clear_cburst() {
  cburst_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MeterConfig::_internal_cburst() const {
  return cburst_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MeterConfig::cburst() const {
  // @@protoc_insertion_point(field_get:p4.v1.MeterConfig.cburst)
  return _internal_cburst();
}
inline void MeterConfig::_internal_set_cburst(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  cburst_ = value;
}
inline void MeterConfig::set_cburst(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_cburst(value);
  // @@protoc_insertion_point(field_set:p4.v1.MeterConfig.cburst)
}

// int64 pir = 3;
inline void MeterConfig::clear_pir() {
  pir_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MeterConfig::_internal_pir() const {
  return pir_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MeterConfig::pir() const {
  // @@protoc_insertion_point(field_get:p4.v1.MeterConfig.pir)
  return _internal_pir();
}
inline void MeterConfig::_internal_set_pir(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  pir_ = value;
}
inline void MeterConfig::set_pir(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_pir(value);
  // @@protoc_insertion_point(field_set:p4.v1.MeterConfig.pir)
}

// int64 pburst = 4;
inline void MeterConfig::clear_pburst() {
  pburst_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MeterConfig::_internal_pburst() const {
  return pburst_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MeterConfig::pburst() const {
  // @@protoc_insertion_point(field_get:p4.v1.MeterConfig.pburst)
  return _internal_pburst();
}
inline void MeterConfig::_internal_set_pburst(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  pburst_ = value;
}
inline void MeterConfig::set_pburst(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_pburst(value);
  // @@protoc_insertion_point(field_set:p4.v1.MeterConfig.pburst)
}

// -------------------------------------------------------------------

// CounterEntry

// uint32 counter_id = 1;
inline void CounterEntry::clear_counter_id() {
  counter_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CounterEntry::_internal_counter_id() const {
  return counter_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CounterEntry::counter_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.CounterEntry.counter_id)
  return _internal_counter_id();
}
inline void CounterEntry::_internal_set_counter_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  counter_id_ = value;
}
inline void CounterEntry::set_counter_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_counter_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.CounterEntry.counter_id)
}

// .p4.v1.Index index = 2;
inline bool CounterEntry::_internal_has_index() const {
  return this != internal_default_instance() && index_ != nullptr;
}
inline bool CounterEntry::has_index() const {
  return _internal_has_index();
}
inline void CounterEntry::clear_index() {
  if (GetArenaForAllocation() == nullptr && index_ != nullptr) {
    delete index_;
  }
  index_ = nullptr;
}
inline const ::p4::v1::Index& CounterEntry::_internal_index() const {
  const ::p4::v1::Index* p = index_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::Index&>(
      ::p4::v1::_Index_default_instance_);
}
inline const ::p4::v1::Index& CounterEntry::index() const {
  // @@protoc_insertion_point(field_get:p4.v1.CounterEntry.index)
  return _internal_index();
}
inline void CounterEntry::unsafe_arena_set_allocated_index(
    ::p4::v1::Index* index) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(index_);
  }
  index_ = index;
  if (index) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.CounterEntry.index)
}
inline ::p4::v1::Index* CounterEntry::release_index() {
  
  ::p4::v1::Index* temp = index_;
  index_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::Index* CounterEntry::unsafe_arena_release_index() {
  // @@protoc_insertion_point(field_release:p4.v1.CounterEntry.index)
  
  ::p4::v1::Index* temp = index_;
  index_ = nullptr;
  return temp;
}
inline ::p4::v1::Index* CounterEntry::_internal_mutable_index() {
  
  if (index_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::Index>(GetArenaForAllocation());
    index_ = p;
  }
  return index_;
}
inline ::p4::v1::Index* CounterEntry::mutable_index() {
  ::p4::v1::Index* _msg = _internal_mutable_index();
  // @@protoc_insertion_point(field_mutable:p4.v1.CounterEntry.index)
  return _msg;
}
inline void CounterEntry::set_allocated_index(::p4::v1::Index* index) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete index_;
  }
  if (index) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::Index>::GetOwningArena(index);
    if (message_arena != submessage_arena) {
      index = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, index, submessage_arena);
    }
    
  } else {
    
  }
  index_ = index;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.CounterEntry.index)
}

// .p4.v1.CounterData data = 3;
inline bool CounterEntry::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool CounterEntry::has_data() const {
  return _internal_has_data();
}
inline void CounterEntry::clear_data() {
  if (GetArenaForAllocation() == nullptr && data_ != nullptr) {
    delete data_;
  }
  data_ = nullptr;
}
inline const ::p4::v1::CounterData& CounterEntry::_internal_data() const {
  const ::p4::v1::CounterData* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::CounterData&>(
      ::p4::v1::_CounterData_default_instance_);
}
inline const ::p4::v1::CounterData& CounterEntry::data() const {
  // @@protoc_insertion_point(field_get:p4.v1.CounterEntry.data)
  return _internal_data();
}
inline void CounterEntry::unsafe_arena_set_allocated_data(
    ::p4::v1::CounterData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.CounterEntry.data)
}
inline ::p4::v1::CounterData* CounterEntry::release_data() {
  
  ::p4::v1::CounterData* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::CounterData* CounterEntry::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:p4.v1.CounterEntry.data)
  
  ::p4::v1::CounterData* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::p4::v1::CounterData* CounterEntry::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::CounterData>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::p4::v1::CounterData* CounterEntry::mutable_data() {
  ::p4::v1::CounterData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:p4.v1.CounterEntry.data)
  return _msg;
}
inline void CounterEntry::set_allocated_data(::p4::v1::CounterData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::CounterData>::GetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.CounterEntry.data)
}

// -------------------------------------------------------------------

// DirectCounterEntry

// .p4.v1.TableEntry table_entry = 1;
inline bool DirectCounterEntry::_internal_has_table_entry() const {
  return this != internal_default_instance() && table_entry_ != nullptr;
}
inline bool DirectCounterEntry::has_table_entry() const {
  return _internal_has_table_entry();
}
inline void DirectCounterEntry::clear_table_entry() {
  if (GetArenaForAllocation() == nullptr && table_entry_ != nullptr) {
    delete table_entry_;
  }
  table_entry_ = nullptr;
}
inline const ::p4::v1::TableEntry& DirectCounterEntry::_internal_table_entry() const {
  const ::p4::v1::TableEntry* p = table_entry_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::TableEntry&>(
      ::p4::v1::_TableEntry_default_instance_);
}
inline const ::p4::v1::TableEntry& DirectCounterEntry::table_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.DirectCounterEntry.table_entry)
  return _internal_table_entry();
}
inline void DirectCounterEntry::unsafe_arena_set_allocated_table_entry(
    ::p4::v1::TableEntry* table_entry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_entry_);
  }
  table_entry_ = table_entry;
  if (table_entry) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.DirectCounterEntry.table_entry)
}
inline ::p4::v1::TableEntry* DirectCounterEntry::release_table_entry() {
  
  ::p4::v1::TableEntry* temp = table_entry_;
  table_entry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::TableEntry* DirectCounterEntry::unsafe_arena_release_table_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.DirectCounterEntry.table_entry)
  
  ::p4::v1::TableEntry* temp = table_entry_;
  table_entry_ = nullptr;
  return temp;
}
inline ::p4::v1::TableEntry* DirectCounterEntry::_internal_mutable_table_entry() {
  
  if (table_entry_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::TableEntry>(GetArenaForAllocation());
    table_entry_ = p;
  }
  return table_entry_;
}
inline ::p4::v1::TableEntry* DirectCounterEntry::mutable_table_entry() {
  ::p4::v1::TableEntry* _msg = _internal_mutable_table_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.DirectCounterEntry.table_entry)
  return _msg;
}
inline void DirectCounterEntry::set_allocated_table_entry(::p4::v1::TableEntry* table_entry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete table_entry_;
  }
  if (table_entry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::TableEntry>::GetOwningArena(table_entry);
    if (message_arena != submessage_arena) {
      table_entry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_entry, submessage_arena);
    }
    
  } else {
    
  }
  table_entry_ = table_entry;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.DirectCounterEntry.table_entry)
}

// .p4.v1.CounterData data = 2;
inline bool DirectCounterEntry::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool DirectCounterEntry::has_data() const {
  return _internal_has_data();
}
inline void DirectCounterEntry::clear_data() {
  if (GetArenaForAllocation() == nullptr && data_ != nullptr) {
    delete data_;
  }
  data_ = nullptr;
}
inline const ::p4::v1::CounterData& DirectCounterEntry::_internal_data() const {
  const ::p4::v1::CounterData* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::CounterData&>(
      ::p4::v1::_CounterData_default_instance_);
}
inline const ::p4::v1::CounterData& DirectCounterEntry::data() const {
  // @@protoc_insertion_point(field_get:p4.v1.DirectCounterEntry.data)
  return _internal_data();
}
inline void DirectCounterEntry::unsafe_arena_set_allocated_data(
    ::p4::v1::CounterData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.DirectCounterEntry.data)
}
inline ::p4::v1::CounterData* DirectCounterEntry::release_data() {
  
  ::p4::v1::CounterData* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::CounterData* DirectCounterEntry::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:p4.v1.DirectCounterEntry.data)
  
  ::p4::v1::CounterData* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::p4::v1::CounterData* DirectCounterEntry::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::CounterData>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::p4::v1::CounterData* DirectCounterEntry::mutable_data() {
  ::p4::v1::CounterData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:p4.v1.DirectCounterEntry.data)
  return _msg;
}
inline void DirectCounterEntry::set_allocated_data(::p4::v1::CounterData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::CounterData>::GetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.DirectCounterEntry.data)
}

// -------------------------------------------------------------------

// CounterData

// int64 byte_count = 1;
inline void CounterData::clear_byte_count() {
  byte_count_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CounterData::_internal_byte_count() const {
  return byte_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CounterData::byte_count() const {
  // @@protoc_insertion_point(field_get:p4.v1.CounterData.byte_count)
  return _internal_byte_count();
}
inline void CounterData::_internal_set_byte_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  byte_count_ = value;
}
inline void CounterData::set_byte_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_byte_count(value);
  // @@protoc_insertion_point(field_set:p4.v1.CounterData.byte_count)
}

// int64 packet_count = 2;
inline void CounterData::clear_packet_count() {
  packet_count_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CounterData::_internal_packet_count() const {
  return packet_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CounterData::packet_count() const {
  // @@protoc_insertion_point(field_get:p4.v1.CounterData.packet_count)
  return _internal_packet_count();
}
inline void CounterData::_internal_set_packet_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  packet_count_ = value;
}
inline void CounterData::set_packet_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_packet_count(value);
  // @@protoc_insertion_point(field_set:p4.v1.CounterData.packet_count)
}

// -------------------------------------------------------------------

// PacketReplicationEngineEntry

// .p4.v1.MulticastGroupEntry multicast_group_entry = 1;
inline bool PacketReplicationEngineEntry::_internal_has_multicast_group_entry() const {
  return type_case() == kMulticastGroupEntry;
}
inline bool PacketReplicationEngineEntry::has_multicast_group_entry() const {
  return _internal_has_multicast_group_entry();
}
inline void PacketReplicationEngineEntry::set_has_multicast_group_entry() {
  _oneof_case_[0] = kMulticastGroupEntry;
}
inline void PacketReplicationEngineEntry::clear_multicast_group_entry() {
  if (_internal_has_multicast_group_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.multicast_group_entry_;
    }
    clear_has_type();
  }
}
inline ::p4::v1::MulticastGroupEntry* PacketReplicationEngineEntry::release_multicast_group_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.PacketReplicationEngineEntry.multicast_group_entry)
  if (_internal_has_multicast_group_entry()) {
    clear_has_type();
      ::p4::v1::MulticastGroupEntry* temp = type_.multicast_group_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.multicast_group_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::MulticastGroupEntry& PacketReplicationEngineEntry::_internal_multicast_group_entry() const {
  return _internal_has_multicast_group_entry()
      ? *type_.multicast_group_entry_
      : reinterpret_cast< ::p4::v1::MulticastGroupEntry&>(::p4::v1::_MulticastGroupEntry_default_instance_);
}
inline const ::p4::v1::MulticastGroupEntry& PacketReplicationEngineEntry::multicast_group_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.PacketReplicationEngineEntry.multicast_group_entry)
  return _internal_multicast_group_entry();
}
inline ::p4::v1::MulticastGroupEntry* PacketReplicationEngineEntry::unsafe_arena_release_multicast_group_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.PacketReplicationEngineEntry.multicast_group_entry)
  if (_internal_has_multicast_group_entry()) {
    clear_has_type();
    ::p4::v1::MulticastGroupEntry* temp = type_.multicast_group_entry_;
    type_.multicast_group_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PacketReplicationEngineEntry::unsafe_arena_set_allocated_multicast_group_entry(::p4::v1::MulticastGroupEntry* multicast_group_entry) {
  clear_type();
  if (multicast_group_entry) {
    set_has_multicast_group_entry();
    type_.multicast_group_entry_ = multicast_group_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.PacketReplicationEngineEntry.multicast_group_entry)
}
inline ::p4::v1::MulticastGroupEntry* PacketReplicationEngineEntry::_internal_mutable_multicast_group_entry() {
  if (!_internal_has_multicast_group_entry()) {
    clear_type();
    set_has_multicast_group_entry();
    type_.multicast_group_entry_ = CreateMaybeMessage< ::p4::v1::MulticastGroupEntry >(GetArenaForAllocation());
  }
  return type_.multicast_group_entry_;
}
inline ::p4::v1::MulticastGroupEntry* PacketReplicationEngineEntry::mutable_multicast_group_entry() {
  ::p4::v1::MulticastGroupEntry* _msg = _internal_mutable_multicast_group_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.PacketReplicationEngineEntry.multicast_group_entry)
  return _msg;
}

// .p4.v1.CloneSessionEntry clone_session_entry = 2;
inline bool PacketReplicationEngineEntry::_internal_has_clone_session_entry() const {
  return type_case() == kCloneSessionEntry;
}
inline bool PacketReplicationEngineEntry::has_clone_session_entry() const {
  return _internal_has_clone_session_entry();
}
inline void PacketReplicationEngineEntry::set_has_clone_session_entry() {
  _oneof_case_[0] = kCloneSessionEntry;
}
inline void PacketReplicationEngineEntry::clear_clone_session_entry() {
  if (_internal_has_clone_session_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.clone_session_entry_;
    }
    clear_has_type();
  }
}
inline ::p4::v1::CloneSessionEntry* PacketReplicationEngineEntry::release_clone_session_entry() {
  // @@protoc_insertion_point(field_release:p4.v1.PacketReplicationEngineEntry.clone_session_entry)
  if (_internal_has_clone_session_entry()) {
    clear_has_type();
      ::p4::v1::CloneSessionEntry* temp = type_.clone_session_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.clone_session_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::CloneSessionEntry& PacketReplicationEngineEntry::_internal_clone_session_entry() const {
  return _internal_has_clone_session_entry()
      ? *type_.clone_session_entry_
      : reinterpret_cast< ::p4::v1::CloneSessionEntry&>(::p4::v1::_CloneSessionEntry_default_instance_);
}
inline const ::p4::v1::CloneSessionEntry& PacketReplicationEngineEntry::clone_session_entry() const {
  // @@protoc_insertion_point(field_get:p4.v1.PacketReplicationEngineEntry.clone_session_entry)
  return _internal_clone_session_entry();
}
inline ::p4::v1::CloneSessionEntry* PacketReplicationEngineEntry::unsafe_arena_release_clone_session_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.PacketReplicationEngineEntry.clone_session_entry)
  if (_internal_has_clone_session_entry()) {
    clear_has_type();
    ::p4::v1::CloneSessionEntry* temp = type_.clone_session_entry_;
    type_.clone_session_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PacketReplicationEngineEntry::unsafe_arena_set_allocated_clone_session_entry(::p4::v1::CloneSessionEntry* clone_session_entry) {
  clear_type();
  if (clone_session_entry) {
    set_has_clone_session_entry();
    type_.clone_session_entry_ = clone_session_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.PacketReplicationEngineEntry.clone_session_entry)
}
inline ::p4::v1::CloneSessionEntry* PacketReplicationEngineEntry::_internal_mutable_clone_session_entry() {
  if (!_internal_has_clone_session_entry()) {
    clear_type();
    set_has_clone_session_entry();
    type_.clone_session_entry_ = CreateMaybeMessage< ::p4::v1::CloneSessionEntry >(GetArenaForAllocation());
  }
  return type_.clone_session_entry_;
}
inline ::p4::v1::CloneSessionEntry* PacketReplicationEngineEntry::mutable_clone_session_entry() {
  ::p4::v1::CloneSessionEntry* _msg = _internal_mutable_clone_session_entry();
  // @@protoc_insertion_point(field_mutable:p4.v1.PacketReplicationEngineEntry.clone_session_entry)
  return _msg;
}

inline bool PacketReplicationEngineEntry::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void PacketReplicationEngineEntry::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline PacketReplicationEngineEntry::TypeCase PacketReplicationEngineEntry::type_case() const {
  return PacketReplicationEngineEntry::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Replica

// uint32 egress_port = 1;
inline void Replica::clear_egress_port() {
  egress_port_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Replica::_internal_egress_port() const {
  return egress_port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Replica::egress_port() const {
  // @@protoc_insertion_point(field_get:p4.v1.Replica.egress_port)
  return _internal_egress_port();
}
inline void Replica::_internal_set_egress_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  egress_port_ = value;
}
inline void Replica::set_egress_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_egress_port(value);
  // @@protoc_insertion_point(field_set:p4.v1.Replica.egress_port)
}

// uint32 instance = 2;
inline void Replica::clear_instance() {
  instance_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Replica::_internal_instance() const {
  return instance_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Replica::instance() const {
  // @@protoc_insertion_point(field_get:p4.v1.Replica.instance)
  return _internal_instance();
}
inline void Replica::_internal_set_instance(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  instance_ = value;
}
inline void Replica::set_instance(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_instance(value);
  // @@protoc_insertion_point(field_set:p4.v1.Replica.instance)
}

// -------------------------------------------------------------------

// MulticastGroupEntry

// uint32 multicast_group_id = 1;
inline void MulticastGroupEntry::clear_multicast_group_id() {
  multicast_group_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MulticastGroupEntry::_internal_multicast_group_id() const {
  return multicast_group_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MulticastGroupEntry::multicast_group_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.MulticastGroupEntry.multicast_group_id)
  return _internal_multicast_group_id();
}
inline void MulticastGroupEntry::_internal_set_multicast_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  multicast_group_id_ = value;
}
inline void MulticastGroupEntry::set_multicast_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_multicast_group_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.MulticastGroupEntry.multicast_group_id)
}

// repeated .p4.v1.Replica replicas = 2;
inline int MulticastGroupEntry::_internal_replicas_size() const {
  return replicas_.size();
}
inline int MulticastGroupEntry::replicas_size() const {
  return _internal_replicas_size();
}
inline void MulticastGroupEntry::clear_replicas() {
  replicas_.Clear();
}
inline ::p4::v1::Replica* MulticastGroupEntry::mutable_replicas(int index) {
  // @@protoc_insertion_point(field_mutable:p4.v1.MulticastGroupEntry.replicas)
  return replicas_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Replica >*
MulticastGroupEntry::mutable_replicas() {
  // @@protoc_insertion_point(field_mutable_list:p4.v1.MulticastGroupEntry.replicas)
  return &replicas_;
}
inline const ::p4::v1::Replica& MulticastGroupEntry::_internal_replicas(int index) const {
  return replicas_.Get(index);
}
inline const ::p4::v1::Replica& MulticastGroupEntry::replicas(int index) const {
  // @@protoc_insertion_point(field_get:p4.v1.MulticastGroupEntry.replicas)
  return _internal_replicas(index);
}
inline ::p4::v1::Replica* MulticastGroupEntry::_internal_add_replicas() {
  return replicas_.Add();
}
inline ::p4::v1::Replica* MulticastGroupEntry::add_replicas() {
  ::p4::v1::Replica* _add = _internal_add_replicas();
  // @@protoc_insertion_point(field_add:p4.v1.MulticastGroupEntry.replicas)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Replica >&
MulticastGroupEntry::replicas() const {
  // @@protoc_insertion_point(field_list:p4.v1.MulticastGroupEntry.replicas)
  return replicas_;
}

// -------------------------------------------------------------------

// CloneSessionEntry

// uint32 session_id = 1;
inline void CloneSessionEntry::clear_session_id() {
  session_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CloneSessionEntry::_internal_session_id() const {
  return session_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CloneSessionEntry::session_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.CloneSessionEntry.session_id)
  return _internal_session_id();
}
inline void CloneSessionEntry::_internal_set_session_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  session_id_ = value;
}
inline void CloneSessionEntry::set_session_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.CloneSessionEntry.session_id)
}

// repeated .p4.v1.Replica replicas = 2;
inline int CloneSessionEntry::_internal_replicas_size() const {
  return replicas_.size();
}
inline int CloneSessionEntry::replicas_size() const {
  return _internal_replicas_size();
}
inline void CloneSessionEntry::clear_replicas() {
  replicas_.Clear();
}
inline ::p4::v1::Replica* CloneSessionEntry::mutable_replicas(int index) {
  // @@protoc_insertion_point(field_mutable:p4.v1.CloneSessionEntry.replicas)
  return replicas_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Replica >*
CloneSessionEntry::mutable_replicas() {
  // @@protoc_insertion_point(field_mutable_list:p4.v1.CloneSessionEntry.replicas)
  return &replicas_;
}
inline const ::p4::v1::Replica& CloneSessionEntry::_internal_replicas(int index) const {
  return replicas_.Get(index);
}
inline const ::p4::v1::Replica& CloneSessionEntry::replicas(int index) const {
  // @@protoc_insertion_point(field_get:p4.v1.CloneSessionEntry.replicas)
  return _internal_replicas(index);
}
inline ::p4::v1::Replica* CloneSessionEntry::_internal_add_replicas() {
  return replicas_.Add();
}
inline ::p4::v1::Replica* CloneSessionEntry::add_replicas() {
  ::p4::v1::Replica* _add = _internal_add_replicas();
  // @@protoc_insertion_point(field_add:p4.v1.CloneSessionEntry.replicas)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::Replica >&
CloneSessionEntry::replicas() const {
  // @@protoc_insertion_point(field_list:p4.v1.CloneSessionEntry.replicas)
  return replicas_;
}

// uint32 class_of_service = 3;
inline void CloneSessionEntry::clear_class_of_service() {
  class_of_service_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CloneSessionEntry::_internal_class_of_service() const {
  return class_of_service_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CloneSessionEntry::class_of_service() const {
  // @@protoc_insertion_point(field_get:p4.v1.CloneSessionEntry.class_of_service)
  return _internal_class_of_service();
}
inline void CloneSessionEntry::_internal_set_class_of_service(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  class_of_service_ = value;
}
inline void CloneSessionEntry::set_class_of_service(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_class_of_service(value);
  // @@protoc_insertion_point(field_set:p4.v1.CloneSessionEntry.class_of_service)
}

// int32 packet_length_bytes = 4;
inline void CloneSessionEntry::clear_packet_length_bytes() {
  packet_length_bytes_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CloneSessionEntry::_internal_packet_length_bytes() const {
  return packet_length_bytes_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CloneSessionEntry::packet_length_bytes() const {
  // @@protoc_insertion_point(field_get:p4.v1.CloneSessionEntry.packet_length_bytes)
  return _internal_packet_length_bytes();
}
inline void CloneSessionEntry::_internal_set_packet_length_bytes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  packet_length_bytes_ = value;
}
inline void CloneSessionEntry::set_packet_length_bytes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_packet_length_bytes(value);
  // @@protoc_insertion_point(field_set:p4.v1.CloneSessionEntry.packet_length_bytes)
}

// -------------------------------------------------------------------

// ValueSetMember

// repeated .p4.v1.FieldMatch match = 1;
inline int ValueSetMember::_internal_match_size() const {
  return match_.size();
}
inline int ValueSetMember::match_size() const {
  return _internal_match_size();
}
inline void ValueSetMember::clear_match() {
  match_.Clear();
}
inline ::p4::v1::FieldMatch* ValueSetMember::mutable_match(int index) {
  // @@protoc_insertion_point(field_mutable:p4.v1.ValueSetMember.match)
  return match_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::FieldMatch >*
ValueSetMember::mutable_match() {
  // @@protoc_insertion_point(field_mutable_list:p4.v1.ValueSetMember.match)
  return &match_;
}
inline const ::p4::v1::FieldMatch& ValueSetMember::_internal_match(int index) const {
  return match_.Get(index);
}
inline const ::p4::v1::FieldMatch& ValueSetMember::match(int index) const {
  // @@protoc_insertion_point(field_get:p4.v1.ValueSetMember.match)
  return _internal_match(index);
}
inline ::p4::v1::FieldMatch* ValueSetMember::_internal_add_match() {
  return match_.Add();
}
inline ::p4::v1::FieldMatch* ValueSetMember::add_match() {
  ::p4::v1::FieldMatch* _add = _internal_add_match();
  // @@protoc_insertion_point(field_add:p4.v1.ValueSetMember.match)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::FieldMatch >&
ValueSetMember::match() const {
  // @@protoc_insertion_point(field_list:p4.v1.ValueSetMember.match)
  return match_;
}

// -------------------------------------------------------------------

// ValueSetEntry

// uint32 value_set_id = 1;
inline void ValueSetEntry::clear_value_set_id() {
  value_set_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ValueSetEntry::_internal_value_set_id() const {
  return value_set_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ValueSetEntry::value_set_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.ValueSetEntry.value_set_id)
  return _internal_value_set_id();
}
inline void ValueSetEntry::_internal_set_value_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_set_id_ = value;
}
inline void ValueSetEntry::set_value_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_value_set_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.ValueSetEntry.value_set_id)
}

// repeated .p4.v1.ValueSetMember members = 2;
inline int ValueSetEntry::_internal_members_size() const {
  return members_.size();
}
inline int ValueSetEntry::members_size() const {
  return _internal_members_size();
}
inline void ValueSetEntry::clear_members() {
  members_.Clear();
}
inline ::p4::v1::ValueSetMember* ValueSetEntry::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:p4.v1.ValueSetEntry.members)
  return members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::ValueSetMember >*
ValueSetEntry::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:p4.v1.ValueSetEntry.members)
  return &members_;
}
inline const ::p4::v1::ValueSetMember& ValueSetEntry::_internal_members(int index) const {
  return members_.Get(index);
}
inline const ::p4::v1::ValueSetMember& ValueSetEntry::members(int index) const {
  // @@protoc_insertion_point(field_get:p4.v1.ValueSetEntry.members)
  return _internal_members(index);
}
inline ::p4::v1::ValueSetMember* ValueSetEntry::_internal_add_members() {
  return members_.Add();
}
inline ::p4::v1::ValueSetMember* ValueSetEntry::add_members() {
  ::p4::v1::ValueSetMember* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:p4.v1.ValueSetEntry.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::ValueSetMember >&
ValueSetEntry::members() const {
  // @@protoc_insertion_point(field_list:p4.v1.ValueSetEntry.members)
  return members_;
}

// -------------------------------------------------------------------

// RegisterEntry

// uint32 register_id = 1;
inline void RegisterEntry::clear_register_id() {
  register_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RegisterEntry::_internal_register_id() const {
  return register_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RegisterEntry::register_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.RegisterEntry.register_id)
  return _internal_register_id();
}
inline void RegisterEntry::_internal_set_register_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  register_id_ = value;
}
inline void RegisterEntry::set_register_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_register_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.RegisterEntry.register_id)
}

// .p4.v1.Index index = 2;
inline bool RegisterEntry::_internal_has_index() const {
  return this != internal_default_instance() && index_ != nullptr;
}
inline bool RegisterEntry::has_index() const {
  return _internal_has_index();
}
inline void RegisterEntry::clear_index() {
  if (GetArenaForAllocation() == nullptr && index_ != nullptr) {
    delete index_;
  }
  index_ = nullptr;
}
inline const ::p4::v1::Index& RegisterEntry::_internal_index() const {
  const ::p4::v1::Index* p = index_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::Index&>(
      ::p4::v1::_Index_default_instance_);
}
inline const ::p4::v1::Index& RegisterEntry::index() const {
  // @@protoc_insertion_point(field_get:p4.v1.RegisterEntry.index)
  return _internal_index();
}
inline void RegisterEntry::unsafe_arena_set_allocated_index(
    ::p4::v1::Index* index) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(index_);
  }
  index_ = index;
  if (index) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.RegisterEntry.index)
}
inline ::p4::v1::Index* RegisterEntry::release_index() {
  
  ::p4::v1::Index* temp = index_;
  index_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::Index* RegisterEntry::unsafe_arena_release_index() {
  // @@protoc_insertion_point(field_release:p4.v1.RegisterEntry.index)
  
  ::p4::v1::Index* temp = index_;
  index_ = nullptr;
  return temp;
}
inline ::p4::v1::Index* RegisterEntry::_internal_mutable_index() {
  
  if (index_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::Index>(GetArenaForAllocation());
    index_ = p;
  }
  return index_;
}
inline ::p4::v1::Index* RegisterEntry::mutable_index() {
  ::p4::v1::Index* _msg = _internal_mutable_index();
  // @@protoc_insertion_point(field_mutable:p4.v1.RegisterEntry.index)
  return _msg;
}
inline void RegisterEntry::set_allocated_index(::p4::v1::Index* index) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete index_;
  }
  if (index) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::Index>::GetOwningArena(index);
    if (message_arena != submessage_arena) {
      index = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, index, submessage_arena);
    }
    
  } else {
    
  }
  index_ = index;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.RegisterEntry.index)
}

// .p4.v1.P4Data data = 3;
inline bool RegisterEntry::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool RegisterEntry::has_data() const {
  return _internal_has_data();
}
inline const ::p4::v1::P4Data& RegisterEntry::_internal_data() const {
  const ::p4::v1::P4Data* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::P4Data&>(
      ::p4::v1::_P4Data_default_instance_);
}
inline const ::p4::v1::P4Data& RegisterEntry::data() const {
  // @@protoc_insertion_point(field_get:p4.v1.RegisterEntry.data)
  return _internal_data();
}
inline void RegisterEntry::unsafe_arena_set_allocated_data(
    ::p4::v1::P4Data* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.RegisterEntry.data)
}
inline ::p4::v1::P4Data* RegisterEntry::release_data() {
  
  ::p4::v1::P4Data* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::P4Data* RegisterEntry::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:p4.v1.RegisterEntry.data)
  
  ::p4::v1::P4Data* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::p4::v1::P4Data* RegisterEntry::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::P4Data>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::p4::v1::P4Data* RegisterEntry::mutable_data() {
  ::p4::v1::P4Data* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:p4.v1.RegisterEntry.data)
  return _msg;
}
inline void RegisterEntry::set_allocated_data(::p4::v1::P4Data* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.RegisterEntry.data)
}

// -------------------------------------------------------------------

// DigestEntry_Config

// int64 max_timeout_ns = 1;
inline void DigestEntry_Config::clear_max_timeout_ns() {
  max_timeout_ns_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DigestEntry_Config::_internal_max_timeout_ns() const {
  return max_timeout_ns_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DigestEntry_Config::max_timeout_ns() const {
  // @@protoc_insertion_point(field_get:p4.v1.DigestEntry.Config.max_timeout_ns)
  return _internal_max_timeout_ns();
}
inline void DigestEntry_Config::_internal_set_max_timeout_ns(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  max_timeout_ns_ = value;
}
inline void DigestEntry_Config::set_max_timeout_ns(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_max_timeout_ns(value);
  // @@protoc_insertion_point(field_set:p4.v1.DigestEntry.Config.max_timeout_ns)
}

// int32 max_list_size = 2;
inline void DigestEntry_Config::clear_max_list_size() {
  max_list_size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DigestEntry_Config::_internal_max_list_size() const {
  return max_list_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DigestEntry_Config::max_list_size() const {
  // @@protoc_insertion_point(field_get:p4.v1.DigestEntry.Config.max_list_size)
  return _internal_max_list_size();
}
inline void DigestEntry_Config::_internal_set_max_list_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_list_size_ = value;
}
inline void DigestEntry_Config::set_max_list_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_list_size(value);
  // @@protoc_insertion_point(field_set:p4.v1.DigestEntry.Config.max_list_size)
}

// int64 ack_timeout_ns = 3;
inline void DigestEntry_Config::clear_ack_timeout_ns() {
  ack_timeout_ns_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DigestEntry_Config::_internal_ack_timeout_ns() const {
  return ack_timeout_ns_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DigestEntry_Config::ack_timeout_ns() const {
  // @@protoc_insertion_point(field_get:p4.v1.DigestEntry.Config.ack_timeout_ns)
  return _internal_ack_timeout_ns();
}
inline void DigestEntry_Config::_internal_set_ack_timeout_ns(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  ack_timeout_ns_ = value;
}
inline void DigestEntry_Config::set_ack_timeout_ns(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_ack_timeout_ns(value);
  // @@protoc_insertion_point(field_set:p4.v1.DigestEntry.Config.ack_timeout_ns)
}

// -------------------------------------------------------------------

// DigestEntry

// uint32 digest_id = 1;
inline void DigestEntry::clear_digest_id() {
  digest_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DigestEntry::_internal_digest_id() const {
  return digest_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DigestEntry::digest_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.DigestEntry.digest_id)
  return _internal_digest_id();
}
inline void DigestEntry::_internal_set_digest_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  digest_id_ = value;
}
inline void DigestEntry::set_digest_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_digest_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.DigestEntry.digest_id)
}

// .p4.v1.DigestEntry.Config config = 2;
inline bool DigestEntry::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool DigestEntry::has_config() const {
  return _internal_has_config();
}
inline void DigestEntry::clear_config() {
  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::p4::v1::DigestEntry_Config& DigestEntry::_internal_config() const {
  const ::p4::v1::DigestEntry_Config* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::DigestEntry_Config&>(
      ::p4::v1::_DigestEntry_Config_default_instance_);
}
inline const ::p4::v1::DigestEntry_Config& DigestEntry::config() const {
  // @@protoc_insertion_point(field_get:p4.v1.DigestEntry.config)
  return _internal_config();
}
inline void DigestEntry::unsafe_arena_set_allocated_config(
    ::p4::v1::DigestEntry_Config* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.DigestEntry.config)
}
inline ::p4::v1::DigestEntry_Config* DigestEntry::release_config() {
  
  ::p4::v1::DigestEntry_Config* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::DigestEntry_Config* DigestEntry::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:p4.v1.DigestEntry.config)
  
  ::p4::v1::DigestEntry_Config* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::p4::v1::DigestEntry_Config* DigestEntry::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::DigestEntry_Config>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::p4::v1::DigestEntry_Config* DigestEntry::mutable_config() {
  ::p4::v1::DigestEntry_Config* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:p4.v1.DigestEntry.config)
  return _msg;
}
inline void DigestEntry::set_allocated_config(::p4::v1::DigestEntry_Config* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::DigestEntry_Config>::GetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.DigestEntry.config)
}

// -------------------------------------------------------------------

// StreamMessageRequest

// .p4.v1.MasterArbitrationUpdate arbitration = 1;
inline bool StreamMessageRequest::_internal_has_arbitration() const {
  return update_case() == kArbitration;
}
inline bool StreamMessageRequest::has_arbitration() const {
  return _internal_has_arbitration();
}
inline void StreamMessageRequest::set_has_arbitration() {
  _oneof_case_[0] = kArbitration;
}
inline void StreamMessageRequest::clear_arbitration() {
  if (_internal_has_arbitration()) {
    if (GetArenaForAllocation() == nullptr) {
      delete update_.arbitration_;
    }
    clear_has_update();
  }
}
inline ::p4::v1::MasterArbitrationUpdate* StreamMessageRequest::release_arbitration() {
  // @@protoc_insertion_point(field_release:p4.v1.StreamMessageRequest.arbitration)
  if (_internal_has_arbitration()) {
    clear_has_update();
      ::p4::v1::MasterArbitrationUpdate* temp = update_.arbitration_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    update_.arbitration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::MasterArbitrationUpdate& StreamMessageRequest::_internal_arbitration() const {
  return _internal_has_arbitration()
      ? *update_.arbitration_
      : reinterpret_cast< ::p4::v1::MasterArbitrationUpdate&>(::p4::v1::_MasterArbitrationUpdate_default_instance_);
}
inline const ::p4::v1::MasterArbitrationUpdate& StreamMessageRequest::arbitration() const {
  // @@protoc_insertion_point(field_get:p4.v1.StreamMessageRequest.arbitration)
  return _internal_arbitration();
}
inline ::p4::v1::MasterArbitrationUpdate* StreamMessageRequest::unsafe_arena_release_arbitration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.StreamMessageRequest.arbitration)
  if (_internal_has_arbitration()) {
    clear_has_update();
    ::p4::v1::MasterArbitrationUpdate* temp = update_.arbitration_;
    update_.arbitration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamMessageRequest::unsafe_arena_set_allocated_arbitration(::p4::v1::MasterArbitrationUpdate* arbitration) {
  clear_update();
  if (arbitration) {
    set_has_arbitration();
    update_.arbitration_ = arbitration;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.StreamMessageRequest.arbitration)
}
inline ::p4::v1::MasterArbitrationUpdate* StreamMessageRequest::_internal_mutable_arbitration() {
  if (!_internal_has_arbitration()) {
    clear_update();
    set_has_arbitration();
    update_.arbitration_ = CreateMaybeMessage< ::p4::v1::MasterArbitrationUpdate >(GetArenaForAllocation());
  }
  return update_.arbitration_;
}
inline ::p4::v1::MasterArbitrationUpdate* StreamMessageRequest::mutable_arbitration() {
  ::p4::v1::MasterArbitrationUpdate* _msg = _internal_mutable_arbitration();
  // @@protoc_insertion_point(field_mutable:p4.v1.StreamMessageRequest.arbitration)
  return _msg;
}

// .p4.v1.PacketOut packet = 2;
inline bool StreamMessageRequest::_internal_has_packet() const {
  return update_case() == kPacket;
}
inline bool StreamMessageRequest::has_packet() const {
  return _internal_has_packet();
}
inline void StreamMessageRequest::set_has_packet() {
  _oneof_case_[0] = kPacket;
}
inline void StreamMessageRequest::clear_packet() {
  if (_internal_has_packet()) {
    if (GetArenaForAllocation() == nullptr) {
      delete update_.packet_;
    }
    clear_has_update();
  }
}
inline ::p4::v1::PacketOut* StreamMessageRequest::release_packet() {
  // @@protoc_insertion_point(field_release:p4.v1.StreamMessageRequest.packet)
  if (_internal_has_packet()) {
    clear_has_update();
      ::p4::v1::PacketOut* temp = update_.packet_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    update_.packet_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::PacketOut& StreamMessageRequest::_internal_packet() const {
  return _internal_has_packet()
      ? *update_.packet_
      : reinterpret_cast< ::p4::v1::PacketOut&>(::p4::v1::_PacketOut_default_instance_);
}
inline const ::p4::v1::PacketOut& StreamMessageRequest::packet() const {
  // @@protoc_insertion_point(field_get:p4.v1.StreamMessageRequest.packet)
  return _internal_packet();
}
inline ::p4::v1::PacketOut* StreamMessageRequest::unsafe_arena_release_packet() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.StreamMessageRequest.packet)
  if (_internal_has_packet()) {
    clear_has_update();
    ::p4::v1::PacketOut* temp = update_.packet_;
    update_.packet_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamMessageRequest::unsafe_arena_set_allocated_packet(::p4::v1::PacketOut* packet) {
  clear_update();
  if (packet) {
    set_has_packet();
    update_.packet_ = packet;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.StreamMessageRequest.packet)
}
inline ::p4::v1::PacketOut* StreamMessageRequest::_internal_mutable_packet() {
  if (!_internal_has_packet()) {
    clear_update();
    set_has_packet();
    update_.packet_ = CreateMaybeMessage< ::p4::v1::PacketOut >(GetArenaForAllocation());
  }
  return update_.packet_;
}
inline ::p4::v1::PacketOut* StreamMessageRequest::mutable_packet() {
  ::p4::v1::PacketOut* _msg = _internal_mutable_packet();
  // @@protoc_insertion_point(field_mutable:p4.v1.StreamMessageRequest.packet)
  return _msg;
}

// .p4.v1.DigestListAck digest_ack = 3;
inline bool StreamMessageRequest::_internal_has_digest_ack() const {
  return update_case() == kDigestAck;
}
inline bool StreamMessageRequest::has_digest_ack() const {
  return _internal_has_digest_ack();
}
inline void StreamMessageRequest::set_has_digest_ack() {
  _oneof_case_[0] = kDigestAck;
}
inline void StreamMessageRequest::clear_digest_ack() {
  if (_internal_has_digest_ack()) {
    if (GetArenaForAllocation() == nullptr) {
      delete update_.digest_ack_;
    }
    clear_has_update();
  }
}
inline ::p4::v1::DigestListAck* StreamMessageRequest::release_digest_ack() {
  // @@protoc_insertion_point(field_release:p4.v1.StreamMessageRequest.digest_ack)
  if (_internal_has_digest_ack()) {
    clear_has_update();
      ::p4::v1::DigestListAck* temp = update_.digest_ack_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    update_.digest_ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::DigestListAck& StreamMessageRequest::_internal_digest_ack() const {
  return _internal_has_digest_ack()
      ? *update_.digest_ack_
      : reinterpret_cast< ::p4::v1::DigestListAck&>(::p4::v1::_DigestListAck_default_instance_);
}
inline const ::p4::v1::DigestListAck& StreamMessageRequest::digest_ack() const {
  // @@protoc_insertion_point(field_get:p4.v1.StreamMessageRequest.digest_ack)
  return _internal_digest_ack();
}
inline ::p4::v1::DigestListAck* StreamMessageRequest::unsafe_arena_release_digest_ack() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.StreamMessageRequest.digest_ack)
  if (_internal_has_digest_ack()) {
    clear_has_update();
    ::p4::v1::DigestListAck* temp = update_.digest_ack_;
    update_.digest_ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamMessageRequest::unsafe_arena_set_allocated_digest_ack(::p4::v1::DigestListAck* digest_ack) {
  clear_update();
  if (digest_ack) {
    set_has_digest_ack();
    update_.digest_ack_ = digest_ack;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.StreamMessageRequest.digest_ack)
}
inline ::p4::v1::DigestListAck* StreamMessageRequest::_internal_mutable_digest_ack() {
  if (!_internal_has_digest_ack()) {
    clear_update();
    set_has_digest_ack();
    update_.digest_ack_ = CreateMaybeMessage< ::p4::v1::DigestListAck >(GetArenaForAllocation());
  }
  return update_.digest_ack_;
}
inline ::p4::v1::DigestListAck* StreamMessageRequest::mutable_digest_ack() {
  ::p4::v1::DigestListAck* _msg = _internal_mutable_digest_ack();
  // @@protoc_insertion_point(field_mutable:p4.v1.StreamMessageRequest.digest_ack)
  return _msg;
}

// .google.protobuf.Any other = 4;
inline bool StreamMessageRequest::_internal_has_other() const {
  return update_case() == kOther;
}
inline bool StreamMessageRequest::has_other() const {
  return _internal_has_other();
}
inline void StreamMessageRequest::set_has_other() {
  _oneof_case_[0] = kOther;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* StreamMessageRequest::release_other() {
  // @@protoc_insertion_point(field_release:p4.v1.StreamMessageRequest.other)
  if (_internal_has_other()) {
    clear_has_update();
      ::PROTOBUF_NAMESPACE_ID::Any* temp = update_.other_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    update_.other_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& StreamMessageRequest::_internal_other() const {
  return _internal_has_other()
      ? *update_.other_
      : reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::Any&>(::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& StreamMessageRequest::other() const {
  // @@protoc_insertion_point(field_get:p4.v1.StreamMessageRequest.other)
  return _internal_other();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* StreamMessageRequest::unsafe_arena_release_other() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.StreamMessageRequest.other)
  if (_internal_has_other()) {
    clear_has_update();
    ::PROTOBUF_NAMESPACE_ID::Any* temp = update_.other_;
    update_.other_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamMessageRequest::unsafe_arena_set_allocated_other(::PROTOBUF_NAMESPACE_ID::Any* other) {
  clear_update();
  if (other) {
    set_has_other();
    update_.other_ = other;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.StreamMessageRequest.other)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* StreamMessageRequest::_internal_mutable_other() {
  if (!_internal_has_other()) {
    clear_update();
    set_has_other();
    update_.other_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Any >(GetArenaForAllocation());
  }
  return update_.other_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* StreamMessageRequest::mutable_other() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_other();
  // @@protoc_insertion_point(field_mutable:p4.v1.StreamMessageRequest.other)
  return _msg;
}

inline bool StreamMessageRequest::has_update() const {
  return update_case() != UPDATE_NOT_SET;
}
inline void StreamMessageRequest::clear_has_update() {
  _oneof_case_[0] = UPDATE_NOT_SET;
}
inline StreamMessageRequest::UpdateCase StreamMessageRequest::update_case() const {
  return StreamMessageRequest::UpdateCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PacketOut

// bytes payload = 1;
inline void PacketOut::clear_payload() {
  payload_.ClearToEmpty();
}
inline const std::string& PacketOut::payload() const {
  // @@protoc_insertion_point(field_get:p4.v1.PacketOut.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PacketOut::set_payload(ArgT0&& arg0, ArgT... args) {
 
 payload_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.PacketOut.payload)
}
inline std::string* PacketOut::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:p4.v1.PacketOut.payload)
  return _s;
}
inline const std::string& PacketOut::_internal_payload() const {
  return payload_.Get();
}
inline void PacketOut::_internal_set_payload(const std::string& value) {
  
  payload_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PacketOut::_internal_mutable_payload() {
  
  return payload_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PacketOut::release_payload() {
  // @@protoc_insertion_point(field_release:p4.v1.PacketOut.payload)
  return payload_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PacketOut::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.PacketOut.payload)
}

// repeated .p4.v1.PacketMetadata metadata = 2;
inline int PacketOut::_internal_metadata_size() const {
  return metadata_.size();
}
inline int PacketOut::metadata_size() const {
  return _internal_metadata_size();
}
inline void PacketOut::clear_metadata() {
  metadata_.Clear();
}
inline ::p4::v1::PacketMetadata* PacketOut::mutable_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:p4.v1.PacketOut.metadata)
  return metadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::PacketMetadata >*
PacketOut::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_list:p4.v1.PacketOut.metadata)
  return &metadata_;
}
inline const ::p4::v1::PacketMetadata& PacketOut::_internal_metadata(int index) const {
  return metadata_.Get(index);
}
inline const ::p4::v1::PacketMetadata& PacketOut::metadata(int index) const {
  // @@protoc_insertion_point(field_get:p4.v1.PacketOut.metadata)
  return _internal_metadata(index);
}
inline ::p4::v1::PacketMetadata* PacketOut::_internal_add_metadata() {
  return metadata_.Add();
}
inline ::p4::v1::PacketMetadata* PacketOut::add_metadata() {
  ::p4::v1::PacketMetadata* _add = _internal_add_metadata();
  // @@protoc_insertion_point(field_add:p4.v1.PacketOut.metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::PacketMetadata >&
PacketOut::metadata() const {
  // @@protoc_insertion_point(field_list:p4.v1.PacketOut.metadata)
  return metadata_;
}

// -------------------------------------------------------------------

// DigestListAck

// uint32 digest_id = 1;
inline void DigestListAck::clear_digest_id() {
  digest_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DigestListAck::_internal_digest_id() const {
  return digest_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DigestListAck::digest_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.DigestListAck.digest_id)
  return _internal_digest_id();
}
inline void DigestListAck::_internal_set_digest_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  digest_id_ = value;
}
inline void DigestListAck::set_digest_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_digest_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.DigestListAck.digest_id)
}

// uint64 list_id = 2;
inline void DigestListAck::clear_list_id() {
  list_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DigestListAck::_internal_list_id() const {
  return list_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DigestListAck::list_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.DigestListAck.list_id)
  return _internal_list_id();
}
inline void DigestListAck::_internal_set_list_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  list_id_ = value;
}
inline void DigestListAck::set_list_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_list_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.DigestListAck.list_id)
}

// -------------------------------------------------------------------

// StreamMessageResponse

// .p4.v1.MasterArbitrationUpdate arbitration = 1;
inline bool StreamMessageResponse::_internal_has_arbitration() const {
  return update_case() == kArbitration;
}
inline bool StreamMessageResponse::has_arbitration() const {
  return _internal_has_arbitration();
}
inline void StreamMessageResponse::set_has_arbitration() {
  _oneof_case_[0] = kArbitration;
}
inline void StreamMessageResponse::clear_arbitration() {
  if (_internal_has_arbitration()) {
    if (GetArenaForAllocation() == nullptr) {
      delete update_.arbitration_;
    }
    clear_has_update();
  }
}
inline ::p4::v1::MasterArbitrationUpdate* StreamMessageResponse::release_arbitration() {
  // @@protoc_insertion_point(field_release:p4.v1.StreamMessageResponse.arbitration)
  if (_internal_has_arbitration()) {
    clear_has_update();
      ::p4::v1::MasterArbitrationUpdate* temp = update_.arbitration_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    update_.arbitration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::MasterArbitrationUpdate& StreamMessageResponse::_internal_arbitration() const {
  return _internal_has_arbitration()
      ? *update_.arbitration_
      : reinterpret_cast< ::p4::v1::MasterArbitrationUpdate&>(::p4::v1::_MasterArbitrationUpdate_default_instance_);
}
inline const ::p4::v1::MasterArbitrationUpdate& StreamMessageResponse::arbitration() const {
  // @@protoc_insertion_point(field_get:p4.v1.StreamMessageResponse.arbitration)
  return _internal_arbitration();
}
inline ::p4::v1::MasterArbitrationUpdate* StreamMessageResponse::unsafe_arena_release_arbitration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.StreamMessageResponse.arbitration)
  if (_internal_has_arbitration()) {
    clear_has_update();
    ::p4::v1::MasterArbitrationUpdate* temp = update_.arbitration_;
    update_.arbitration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamMessageResponse::unsafe_arena_set_allocated_arbitration(::p4::v1::MasterArbitrationUpdate* arbitration) {
  clear_update();
  if (arbitration) {
    set_has_arbitration();
    update_.arbitration_ = arbitration;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.StreamMessageResponse.arbitration)
}
inline ::p4::v1::MasterArbitrationUpdate* StreamMessageResponse::_internal_mutable_arbitration() {
  if (!_internal_has_arbitration()) {
    clear_update();
    set_has_arbitration();
    update_.arbitration_ = CreateMaybeMessage< ::p4::v1::MasterArbitrationUpdate >(GetArenaForAllocation());
  }
  return update_.arbitration_;
}
inline ::p4::v1::MasterArbitrationUpdate* StreamMessageResponse::mutable_arbitration() {
  ::p4::v1::MasterArbitrationUpdate* _msg = _internal_mutable_arbitration();
  // @@protoc_insertion_point(field_mutable:p4.v1.StreamMessageResponse.arbitration)
  return _msg;
}

// .p4.v1.PacketIn packet = 2;
inline bool StreamMessageResponse::_internal_has_packet() const {
  return update_case() == kPacket;
}
inline bool StreamMessageResponse::has_packet() const {
  return _internal_has_packet();
}
inline void StreamMessageResponse::set_has_packet() {
  _oneof_case_[0] = kPacket;
}
inline void StreamMessageResponse::clear_packet() {
  if (_internal_has_packet()) {
    if (GetArenaForAllocation() == nullptr) {
      delete update_.packet_;
    }
    clear_has_update();
  }
}
inline ::p4::v1::PacketIn* StreamMessageResponse::release_packet() {
  // @@protoc_insertion_point(field_release:p4.v1.StreamMessageResponse.packet)
  if (_internal_has_packet()) {
    clear_has_update();
      ::p4::v1::PacketIn* temp = update_.packet_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    update_.packet_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::PacketIn& StreamMessageResponse::_internal_packet() const {
  return _internal_has_packet()
      ? *update_.packet_
      : reinterpret_cast< ::p4::v1::PacketIn&>(::p4::v1::_PacketIn_default_instance_);
}
inline const ::p4::v1::PacketIn& StreamMessageResponse::packet() const {
  // @@protoc_insertion_point(field_get:p4.v1.StreamMessageResponse.packet)
  return _internal_packet();
}
inline ::p4::v1::PacketIn* StreamMessageResponse::unsafe_arena_release_packet() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.StreamMessageResponse.packet)
  if (_internal_has_packet()) {
    clear_has_update();
    ::p4::v1::PacketIn* temp = update_.packet_;
    update_.packet_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamMessageResponse::unsafe_arena_set_allocated_packet(::p4::v1::PacketIn* packet) {
  clear_update();
  if (packet) {
    set_has_packet();
    update_.packet_ = packet;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.StreamMessageResponse.packet)
}
inline ::p4::v1::PacketIn* StreamMessageResponse::_internal_mutable_packet() {
  if (!_internal_has_packet()) {
    clear_update();
    set_has_packet();
    update_.packet_ = CreateMaybeMessage< ::p4::v1::PacketIn >(GetArenaForAllocation());
  }
  return update_.packet_;
}
inline ::p4::v1::PacketIn* StreamMessageResponse::mutable_packet() {
  ::p4::v1::PacketIn* _msg = _internal_mutable_packet();
  // @@protoc_insertion_point(field_mutable:p4.v1.StreamMessageResponse.packet)
  return _msg;
}

// .p4.v1.DigestList digest = 3;
inline bool StreamMessageResponse::_internal_has_digest() const {
  return update_case() == kDigest;
}
inline bool StreamMessageResponse::has_digest() const {
  return _internal_has_digest();
}
inline void StreamMessageResponse::set_has_digest() {
  _oneof_case_[0] = kDigest;
}
inline void StreamMessageResponse::clear_digest() {
  if (_internal_has_digest()) {
    if (GetArenaForAllocation() == nullptr) {
      delete update_.digest_;
    }
    clear_has_update();
  }
}
inline ::p4::v1::DigestList* StreamMessageResponse::release_digest() {
  // @@protoc_insertion_point(field_release:p4.v1.StreamMessageResponse.digest)
  if (_internal_has_digest()) {
    clear_has_update();
      ::p4::v1::DigestList* temp = update_.digest_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    update_.digest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::DigestList& StreamMessageResponse::_internal_digest() const {
  return _internal_has_digest()
      ? *update_.digest_
      : reinterpret_cast< ::p4::v1::DigestList&>(::p4::v1::_DigestList_default_instance_);
}
inline const ::p4::v1::DigestList& StreamMessageResponse::digest() const {
  // @@protoc_insertion_point(field_get:p4.v1.StreamMessageResponse.digest)
  return _internal_digest();
}
inline ::p4::v1::DigestList* StreamMessageResponse::unsafe_arena_release_digest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.StreamMessageResponse.digest)
  if (_internal_has_digest()) {
    clear_has_update();
    ::p4::v1::DigestList* temp = update_.digest_;
    update_.digest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamMessageResponse::unsafe_arena_set_allocated_digest(::p4::v1::DigestList* digest) {
  clear_update();
  if (digest) {
    set_has_digest();
    update_.digest_ = digest;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.StreamMessageResponse.digest)
}
inline ::p4::v1::DigestList* StreamMessageResponse::_internal_mutable_digest() {
  if (!_internal_has_digest()) {
    clear_update();
    set_has_digest();
    update_.digest_ = CreateMaybeMessage< ::p4::v1::DigestList >(GetArenaForAllocation());
  }
  return update_.digest_;
}
inline ::p4::v1::DigestList* StreamMessageResponse::mutable_digest() {
  ::p4::v1::DigestList* _msg = _internal_mutable_digest();
  // @@protoc_insertion_point(field_mutable:p4.v1.StreamMessageResponse.digest)
  return _msg;
}

// .p4.v1.IdleTimeoutNotification idle_timeout_notification = 4;
inline bool StreamMessageResponse::_internal_has_idle_timeout_notification() const {
  return update_case() == kIdleTimeoutNotification;
}
inline bool StreamMessageResponse::has_idle_timeout_notification() const {
  return _internal_has_idle_timeout_notification();
}
inline void StreamMessageResponse::set_has_idle_timeout_notification() {
  _oneof_case_[0] = kIdleTimeoutNotification;
}
inline void StreamMessageResponse::clear_idle_timeout_notification() {
  if (_internal_has_idle_timeout_notification()) {
    if (GetArenaForAllocation() == nullptr) {
      delete update_.idle_timeout_notification_;
    }
    clear_has_update();
  }
}
inline ::p4::v1::IdleTimeoutNotification* StreamMessageResponse::release_idle_timeout_notification() {
  // @@protoc_insertion_point(field_release:p4.v1.StreamMessageResponse.idle_timeout_notification)
  if (_internal_has_idle_timeout_notification()) {
    clear_has_update();
      ::p4::v1::IdleTimeoutNotification* temp = update_.idle_timeout_notification_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    update_.idle_timeout_notification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::IdleTimeoutNotification& StreamMessageResponse::_internal_idle_timeout_notification() const {
  return _internal_has_idle_timeout_notification()
      ? *update_.idle_timeout_notification_
      : reinterpret_cast< ::p4::v1::IdleTimeoutNotification&>(::p4::v1::_IdleTimeoutNotification_default_instance_);
}
inline const ::p4::v1::IdleTimeoutNotification& StreamMessageResponse::idle_timeout_notification() const {
  // @@protoc_insertion_point(field_get:p4.v1.StreamMessageResponse.idle_timeout_notification)
  return _internal_idle_timeout_notification();
}
inline ::p4::v1::IdleTimeoutNotification* StreamMessageResponse::unsafe_arena_release_idle_timeout_notification() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.StreamMessageResponse.idle_timeout_notification)
  if (_internal_has_idle_timeout_notification()) {
    clear_has_update();
    ::p4::v1::IdleTimeoutNotification* temp = update_.idle_timeout_notification_;
    update_.idle_timeout_notification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamMessageResponse::unsafe_arena_set_allocated_idle_timeout_notification(::p4::v1::IdleTimeoutNotification* idle_timeout_notification) {
  clear_update();
  if (idle_timeout_notification) {
    set_has_idle_timeout_notification();
    update_.idle_timeout_notification_ = idle_timeout_notification;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.StreamMessageResponse.idle_timeout_notification)
}
inline ::p4::v1::IdleTimeoutNotification* StreamMessageResponse::_internal_mutable_idle_timeout_notification() {
  if (!_internal_has_idle_timeout_notification()) {
    clear_update();
    set_has_idle_timeout_notification();
    update_.idle_timeout_notification_ = CreateMaybeMessage< ::p4::v1::IdleTimeoutNotification >(GetArenaForAllocation());
  }
  return update_.idle_timeout_notification_;
}
inline ::p4::v1::IdleTimeoutNotification* StreamMessageResponse::mutable_idle_timeout_notification() {
  ::p4::v1::IdleTimeoutNotification* _msg = _internal_mutable_idle_timeout_notification();
  // @@protoc_insertion_point(field_mutable:p4.v1.StreamMessageResponse.idle_timeout_notification)
  return _msg;
}

// .google.protobuf.Any other = 5;
inline bool StreamMessageResponse::_internal_has_other() const {
  return update_case() == kOther;
}
inline bool StreamMessageResponse::has_other() const {
  return _internal_has_other();
}
inline void StreamMessageResponse::set_has_other() {
  _oneof_case_[0] = kOther;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* StreamMessageResponse::release_other() {
  // @@protoc_insertion_point(field_release:p4.v1.StreamMessageResponse.other)
  if (_internal_has_other()) {
    clear_has_update();
      ::PROTOBUF_NAMESPACE_ID::Any* temp = update_.other_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    update_.other_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& StreamMessageResponse::_internal_other() const {
  return _internal_has_other()
      ? *update_.other_
      : reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::Any&>(::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& StreamMessageResponse::other() const {
  // @@protoc_insertion_point(field_get:p4.v1.StreamMessageResponse.other)
  return _internal_other();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* StreamMessageResponse::unsafe_arena_release_other() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.StreamMessageResponse.other)
  if (_internal_has_other()) {
    clear_has_update();
    ::PROTOBUF_NAMESPACE_ID::Any* temp = update_.other_;
    update_.other_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamMessageResponse::unsafe_arena_set_allocated_other(::PROTOBUF_NAMESPACE_ID::Any* other) {
  clear_update();
  if (other) {
    set_has_other();
    update_.other_ = other;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.StreamMessageResponse.other)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* StreamMessageResponse::_internal_mutable_other() {
  if (!_internal_has_other()) {
    clear_update();
    set_has_other();
    update_.other_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Any >(GetArenaForAllocation());
  }
  return update_.other_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* StreamMessageResponse::mutable_other() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_other();
  // @@protoc_insertion_point(field_mutable:p4.v1.StreamMessageResponse.other)
  return _msg;
}

// .p4.v1.StreamError error = 6;
inline bool StreamMessageResponse::_internal_has_error() const {
  return update_case() == kError;
}
inline bool StreamMessageResponse::has_error() const {
  return _internal_has_error();
}
inline void StreamMessageResponse::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void StreamMessageResponse::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete update_.error_;
    }
    clear_has_update();
  }
}
inline ::p4::v1::StreamError* StreamMessageResponse::release_error() {
  // @@protoc_insertion_point(field_release:p4.v1.StreamMessageResponse.error)
  if (_internal_has_error()) {
    clear_has_update();
      ::p4::v1::StreamError* temp = update_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    update_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::StreamError& StreamMessageResponse::_internal_error() const {
  return _internal_has_error()
      ? *update_.error_
      : reinterpret_cast< ::p4::v1::StreamError&>(::p4::v1::_StreamError_default_instance_);
}
inline const ::p4::v1::StreamError& StreamMessageResponse::error() const {
  // @@protoc_insertion_point(field_get:p4.v1.StreamMessageResponse.error)
  return _internal_error();
}
inline ::p4::v1::StreamError* StreamMessageResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.StreamMessageResponse.error)
  if (_internal_has_error()) {
    clear_has_update();
    ::p4::v1::StreamError* temp = update_.error_;
    update_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamMessageResponse::unsafe_arena_set_allocated_error(::p4::v1::StreamError* error) {
  clear_update();
  if (error) {
    set_has_error();
    update_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.StreamMessageResponse.error)
}
inline ::p4::v1::StreamError* StreamMessageResponse::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_update();
    set_has_error();
    update_.error_ = CreateMaybeMessage< ::p4::v1::StreamError >(GetArenaForAllocation());
  }
  return update_.error_;
}
inline ::p4::v1::StreamError* StreamMessageResponse::mutable_error() {
  ::p4::v1::StreamError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:p4.v1.StreamMessageResponse.error)
  return _msg;
}

inline bool StreamMessageResponse::has_update() const {
  return update_case() != UPDATE_NOT_SET;
}
inline void StreamMessageResponse::clear_has_update() {
  _oneof_case_[0] = UPDATE_NOT_SET;
}
inline StreamMessageResponse::UpdateCase StreamMessageResponse::update_case() const {
  return StreamMessageResponse::UpdateCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PacketIn

// bytes payload = 1;
inline void PacketIn::clear_payload() {
  payload_.ClearToEmpty();
}
inline const std::string& PacketIn::payload() const {
  // @@protoc_insertion_point(field_get:p4.v1.PacketIn.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PacketIn::set_payload(ArgT0&& arg0, ArgT... args) {
 
 payload_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.PacketIn.payload)
}
inline std::string* PacketIn::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:p4.v1.PacketIn.payload)
  return _s;
}
inline const std::string& PacketIn::_internal_payload() const {
  return payload_.Get();
}
inline void PacketIn::_internal_set_payload(const std::string& value) {
  
  payload_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PacketIn::_internal_mutable_payload() {
  
  return payload_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PacketIn::release_payload() {
  // @@protoc_insertion_point(field_release:p4.v1.PacketIn.payload)
  return payload_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PacketIn::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.PacketIn.payload)
}

// repeated .p4.v1.PacketMetadata metadata = 2;
inline int PacketIn::_internal_metadata_size() const {
  return metadata_.size();
}
inline int PacketIn::metadata_size() const {
  return _internal_metadata_size();
}
inline void PacketIn::clear_metadata() {
  metadata_.Clear();
}
inline ::p4::v1::PacketMetadata* PacketIn::mutable_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:p4.v1.PacketIn.metadata)
  return metadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::PacketMetadata >*
PacketIn::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_list:p4.v1.PacketIn.metadata)
  return &metadata_;
}
inline const ::p4::v1::PacketMetadata& PacketIn::_internal_metadata(int index) const {
  return metadata_.Get(index);
}
inline const ::p4::v1::PacketMetadata& PacketIn::metadata(int index) const {
  // @@protoc_insertion_point(field_get:p4.v1.PacketIn.metadata)
  return _internal_metadata(index);
}
inline ::p4::v1::PacketMetadata* PacketIn::_internal_add_metadata() {
  return metadata_.Add();
}
inline ::p4::v1::PacketMetadata* PacketIn::add_metadata() {
  ::p4::v1::PacketMetadata* _add = _internal_add_metadata();
  // @@protoc_insertion_point(field_add:p4.v1.PacketIn.metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::PacketMetadata >&
PacketIn::metadata() const {
  // @@protoc_insertion_point(field_list:p4.v1.PacketIn.metadata)
  return metadata_;
}

// -------------------------------------------------------------------

// DigestList

// uint32 digest_id = 1;
inline void DigestList::clear_digest_id() {
  digest_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DigestList::_internal_digest_id() const {
  return digest_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DigestList::digest_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.DigestList.digest_id)
  return _internal_digest_id();
}
inline void DigestList::_internal_set_digest_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  digest_id_ = value;
}
inline void DigestList::set_digest_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_digest_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.DigestList.digest_id)
}

// uint64 list_id = 2;
inline void DigestList::clear_list_id() {
  list_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DigestList::_internal_list_id() const {
  return list_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DigestList::list_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.DigestList.list_id)
  return _internal_list_id();
}
inline void DigestList::_internal_set_list_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  list_id_ = value;
}
inline void DigestList::set_list_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_list_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.DigestList.list_id)
}

// repeated .p4.v1.P4Data data = 3;
inline int DigestList::_internal_data_size() const {
  return data_.size();
}
inline int DigestList::data_size() const {
  return _internal_data_size();
}
inline ::p4::v1::P4Data* DigestList::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:p4.v1.DigestList.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::P4Data >*
DigestList::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:p4.v1.DigestList.data)
  return &data_;
}
inline const ::p4::v1::P4Data& DigestList::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::p4::v1::P4Data& DigestList::data(int index) const {
  // @@protoc_insertion_point(field_get:p4.v1.DigestList.data)
  return _internal_data(index);
}
inline ::p4::v1::P4Data* DigestList::_internal_add_data() {
  return data_.Add();
}
inline ::p4::v1::P4Data* DigestList::add_data() {
  ::p4::v1::P4Data* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:p4.v1.DigestList.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::P4Data >&
DigestList::data() const {
  // @@protoc_insertion_point(field_list:p4.v1.DigestList.data)
  return data_;
}

// int64 timestamp = 4;
inline void DigestList::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DigestList::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DigestList::timestamp() const {
  // @@protoc_insertion_point(field_get:p4.v1.DigestList.timestamp)
  return _internal_timestamp();
}
inline void DigestList::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  timestamp_ = value;
}
inline void DigestList::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:p4.v1.DigestList.timestamp)
}

// -------------------------------------------------------------------

// PacketMetadata

// uint32 metadata_id = 1;
inline void PacketMetadata::clear_metadata_id() {
  metadata_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PacketMetadata::_internal_metadata_id() const {
  return metadata_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PacketMetadata::metadata_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.PacketMetadata.metadata_id)
  return _internal_metadata_id();
}
inline void PacketMetadata::_internal_set_metadata_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  metadata_id_ = value;
}
inline void PacketMetadata::set_metadata_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_metadata_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.PacketMetadata.metadata_id)
}

// bytes value = 2;
inline void PacketMetadata::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& PacketMetadata::value() const {
  // @@protoc_insertion_point(field_get:p4.v1.PacketMetadata.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PacketMetadata::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.PacketMetadata.value)
}
inline std::string* PacketMetadata::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:p4.v1.PacketMetadata.value)
  return _s;
}
inline const std::string& PacketMetadata::_internal_value() const {
  return value_.Get();
}
inline void PacketMetadata::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PacketMetadata::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PacketMetadata::release_value() {
  // @@protoc_insertion_point(field_release:p4.v1.PacketMetadata.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PacketMetadata::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.PacketMetadata.value)
}

// -------------------------------------------------------------------

// MasterArbitrationUpdate

// uint64 device_id = 1;
inline void MasterArbitrationUpdate::clear_device_id() {
  device_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MasterArbitrationUpdate::_internal_device_id() const {
  return device_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MasterArbitrationUpdate::device_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.MasterArbitrationUpdate.device_id)
  return _internal_device_id();
}
inline void MasterArbitrationUpdate::_internal_set_device_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  device_id_ = value;
}
inline void MasterArbitrationUpdate::set_device_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.MasterArbitrationUpdate.device_id)
}

// .p4.v1.Role role = 2;
inline bool MasterArbitrationUpdate::_internal_has_role() const {
  return this != internal_default_instance() && role_ != nullptr;
}
inline bool MasterArbitrationUpdate::has_role() const {
  return _internal_has_role();
}
inline void MasterArbitrationUpdate::clear_role() {
  if (GetArenaForAllocation() == nullptr && role_ != nullptr) {
    delete role_;
  }
  role_ = nullptr;
}
inline const ::p4::v1::Role& MasterArbitrationUpdate::_internal_role() const {
  const ::p4::v1::Role* p = role_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::Role&>(
      ::p4::v1::_Role_default_instance_);
}
inline const ::p4::v1::Role& MasterArbitrationUpdate::role() const {
  // @@protoc_insertion_point(field_get:p4.v1.MasterArbitrationUpdate.role)
  return _internal_role();
}
inline void MasterArbitrationUpdate::unsafe_arena_set_allocated_role(
    ::p4::v1::Role* role) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(role_);
  }
  role_ = role;
  if (role) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.MasterArbitrationUpdate.role)
}
inline ::p4::v1::Role* MasterArbitrationUpdate::release_role() {
  
  ::p4::v1::Role* temp = role_;
  role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::Role* MasterArbitrationUpdate::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_release:p4.v1.MasterArbitrationUpdate.role)
  
  ::p4::v1::Role* temp = role_;
  role_ = nullptr;
  return temp;
}
inline ::p4::v1::Role* MasterArbitrationUpdate::_internal_mutable_role() {
  
  if (role_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::Role>(GetArenaForAllocation());
    role_ = p;
  }
  return role_;
}
inline ::p4::v1::Role* MasterArbitrationUpdate::mutable_role() {
  ::p4::v1::Role* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:p4.v1.MasterArbitrationUpdate.role)
  return _msg;
}
inline void MasterArbitrationUpdate::set_allocated_role(::p4::v1::Role* role) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete role_;
  }
  if (role) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::Role>::GetOwningArena(role);
    if (message_arena != submessage_arena) {
      role = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    
  } else {
    
  }
  role_ = role;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.MasterArbitrationUpdate.role)
}

// .p4.v1.Uint128 election_id = 3;
inline bool MasterArbitrationUpdate::_internal_has_election_id() const {
  return this != internal_default_instance() && election_id_ != nullptr;
}
inline bool MasterArbitrationUpdate::has_election_id() const {
  return _internal_has_election_id();
}
inline void MasterArbitrationUpdate::clear_election_id() {
  if (GetArenaForAllocation() == nullptr && election_id_ != nullptr) {
    delete election_id_;
  }
  election_id_ = nullptr;
}
inline const ::p4::v1::Uint128& MasterArbitrationUpdate::_internal_election_id() const {
  const ::p4::v1::Uint128* p = election_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::Uint128&>(
      ::p4::v1::_Uint128_default_instance_);
}
inline const ::p4::v1::Uint128& MasterArbitrationUpdate::election_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.MasterArbitrationUpdate.election_id)
  return _internal_election_id();
}
inline void MasterArbitrationUpdate::unsafe_arena_set_allocated_election_id(
    ::p4::v1::Uint128* election_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(election_id_);
  }
  election_id_ = election_id;
  if (election_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.MasterArbitrationUpdate.election_id)
}
inline ::p4::v1::Uint128* MasterArbitrationUpdate::release_election_id() {
  
  ::p4::v1::Uint128* temp = election_id_;
  election_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::Uint128* MasterArbitrationUpdate::unsafe_arena_release_election_id() {
  // @@protoc_insertion_point(field_release:p4.v1.MasterArbitrationUpdate.election_id)
  
  ::p4::v1::Uint128* temp = election_id_;
  election_id_ = nullptr;
  return temp;
}
inline ::p4::v1::Uint128* MasterArbitrationUpdate::_internal_mutable_election_id() {
  
  if (election_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::Uint128>(GetArenaForAllocation());
    election_id_ = p;
  }
  return election_id_;
}
inline ::p4::v1::Uint128* MasterArbitrationUpdate::mutable_election_id() {
  ::p4::v1::Uint128* _msg = _internal_mutable_election_id();
  // @@protoc_insertion_point(field_mutable:p4.v1.MasterArbitrationUpdate.election_id)
  return _msg;
}
inline void MasterArbitrationUpdate::set_allocated_election_id(::p4::v1::Uint128* election_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete election_id_;
  }
  if (election_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::Uint128>::GetOwningArena(election_id);
    if (message_arena != submessage_arena) {
      election_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, election_id, submessage_arena);
    }
    
  } else {
    
  }
  election_id_ = election_id;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.MasterArbitrationUpdate.election_id)
}

// .google.rpc.Status status = 4;
inline bool MasterArbitrationUpdate::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool MasterArbitrationUpdate::has_status() const {
  return _internal_has_status();
}
inline const ::google::rpc::Status& MasterArbitrationUpdate::_internal_status() const {
  const ::google::rpc::Status* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::rpc::Status&>(
      ::google::rpc::_Status_default_instance_);
}
inline const ::google::rpc::Status& MasterArbitrationUpdate::status() const {
  // @@protoc_insertion_point(field_get:p4.v1.MasterArbitrationUpdate.status)
  return _internal_status();
}
inline void MasterArbitrationUpdate::unsafe_arena_set_allocated_status(
    ::google::rpc::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.MasterArbitrationUpdate.status)
}
inline ::google::rpc::Status* MasterArbitrationUpdate::release_status() {
  
  ::google::rpc::Status* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::rpc::Status* MasterArbitrationUpdate::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:p4.v1.MasterArbitrationUpdate.status)
  
  ::google::rpc::Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::google::rpc::Status* MasterArbitrationUpdate::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::rpc::Status>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::google::rpc::Status* MasterArbitrationUpdate::mutable_status() {
  ::google::rpc::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:p4.v1.MasterArbitrationUpdate.status)
  return _msg;
}
inline void MasterArbitrationUpdate::set_allocated_status(::google::rpc::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.MasterArbitrationUpdate.status)
}

// -------------------------------------------------------------------

// Role

// uint64 id = 1;
inline void Role::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Role::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Role::id() const {
  // @@protoc_insertion_point(field_get:p4.v1.Role.id)
  return _internal_id();
}
inline void Role::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void Role::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.Role.id)
}

// .google.protobuf.Any config = 2;
inline bool Role::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool Role::has_config() const {
  return _internal_has_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Role::_internal_config() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Role::config() const {
  // @@protoc_insertion_point(field_get:p4.v1.Role.config)
  return _internal_config();
}
inline void Role::unsafe_arena_set_allocated_config(
    ::PROTOBUF_NAMESPACE_ID::Any* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.Role.config)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Role::release_config() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Role::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:p4.v1.Role.config)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Role::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Role::mutable_config() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:p4.v1.Role.config)
  return _msg;
}
inline void Role::set_allocated_config(::PROTOBUF_NAMESPACE_ID::Any* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config));
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.Role.config)
}

// -------------------------------------------------------------------

// IdleTimeoutNotification

// repeated .p4.v1.TableEntry table_entry = 1;
inline int IdleTimeoutNotification::_internal_table_entry_size() const {
  return table_entry_.size();
}
inline int IdleTimeoutNotification::table_entry_size() const {
  return _internal_table_entry_size();
}
inline void IdleTimeoutNotification::clear_table_entry() {
  table_entry_.Clear();
}
inline ::p4::v1::TableEntry* IdleTimeoutNotification::mutable_table_entry(int index) {
  // @@protoc_insertion_point(field_mutable:p4.v1.IdleTimeoutNotification.table_entry)
  return table_entry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::TableEntry >*
IdleTimeoutNotification::mutable_table_entry() {
  // @@protoc_insertion_point(field_mutable_list:p4.v1.IdleTimeoutNotification.table_entry)
  return &table_entry_;
}
inline const ::p4::v1::TableEntry& IdleTimeoutNotification::_internal_table_entry(int index) const {
  return table_entry_.Get(index);
}
inline const ::p4::v1::TableEntry& IdleTimeoutNotification::table_entry(int index) const {
  // @@protoc_insertion_point(field_get:p4.v1.IdleTimeoutNotification.table_entry)
  return _internal_table_entry(index);
}
inline ::p4::v1::TableEntry* IdleTimeoutNotification::_internal_add_table_entry() {
  return table_entry_.Add();
}
inline ::p4::v1::TableEntry* IdleTimeoutNotification::add_table_entry() {
  ::p4::v1::TableEntry* _add = _internal_add_table_entry();
  // @@protoc_insertion_point(field_add:p4.v1.IdleTimeoutNotification.table_entry)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p4::v1::TableEntry >&
IdleTimeoutNotification::table_entry() const {
  // @@protoc_insertion_point(field_list:p4.v1.IdleTimeoutNotification.table_entry)
  return table_entry_;
}

// int64 timestamp = 2;
inline void IdleTimeoutNotification::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IdleTimeoutNotification::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IdleTimeoutNotification::timestamp() const {
  // @@protoc_insertion_point(field_get:p4.v1.IdleTimeoutNotification.timestamp)
  return _internal_timestamp();
}
inline void IdleTimeoutNotification::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  timestamp_ = value;
}
inline void IdleTimeoutNotification::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:p4.v1.IdleTimeoutNotification.timestamp)
}

// -------------------------------------------------------------------

// StreamError

// int32 canonical_code = 1;
inline void StreamError::clear_canonical_code() {
  canonical_code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StreamError::_internal_canonical_code() const {
  return canonical_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StreamError::canonical_code() const {
  // @@protoc_insertion_point(field_get:p4.v1.StreamError.canonical_code)
  return _internal_canonical_code();
}
inline void StreamError::_internal_set_canonical_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  canonical_code_ = value;
}
inline void StreamError::set_canonical_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_canonical_code(value);
  // @@protoc_insertion_point(field_set:p4.v1.StreamError.canonical_code)
}

// string message = 2;
inline void StreamError::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& StreamError::message() const {
  // @@protoc_insertion_point(field_get:p4.v1.StreamError.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamError::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.StreamError.message)
}
inline std::string* StreamError::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:p4.v1.StreamError.message)
  return _s;
}
inline const std::string& StreamError::_internal_message() const {
  return message_.Get();
}
inline void StreamError::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StreamError::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StreamError::release_message() {
  // @@protoc_insertion_point(field_release:p4.v1.StreamError.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StreamError::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.StreamError.message)
}

// string space = 3;
inline void StreamError::clear_space() {
  space_.ClearToEmpty();
}
inline const std::string& StreamError::space() const {
  // @@protoc_insertion_point(field_get:p4.v1.StreamError.space)
  return _internal_space();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamError::set_space(ArgT0&& arg0, ArgT... args) {
 
 space_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.StreamError.space)
}
inline std::string* StreamError::mutable_space() {
  std::string* _s = _internal_mutable_space();
  // @@protoc_insertion_point(field_mutable:p4.v1.StreamError.space)
  return _s;
}
inline const std::string& StreamError::_internal_space() const {
  return space_.Get();
}
inline void StreamError::_internal_set_space(const std::string& value) {
  
  space_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StreamError::_internal_mutable_space() {
  
  return space_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StreamError::release_space() {
  // @@protoc_insertion_point(field_release:p4.v1.StreamError.space)
  return space_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StreamError::set_allocated_space(std::string* space) {
  if (space != nullptr) {
    
  } else {
    
  }
  space_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), space,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.StreamError.space)
}

// int32 code = 4;
inline void StreamError::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StreamError::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StreamError::code() const {
  // @@protoc_insertion_point(field_get:p4.v1.StreamError.code)
  return _internal_code();
}
inline void StreamError::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void StreamError::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:p4.v1.StreamError.code)
}

// .p4.v1.PacketOutError packet_out = 5;
inline bool StreamError::_internal_has_packet_out() const {
  return details_case() == kPacketOut;
}
inline bool StreamError::has_packet_out() const {
  return _internal_has_packet_out();
}
inline void StreamError::set_has_packet_out() {
  _oneof_case_[0] = kPacketOut;
}
inline void StreamError::clear_packet_out() {
  if (_internal_has_packet_out()) {
    if (GetArenaForAllocation() == nullptr) {
      delete details_.packet_out_;
    }
    clear_has_details();
  }
}
inline ::p4::v1::PacketOutError* StreamError::release_packet_out() {
  // @@protoc_insertion_point(field_release:p4.v1.StreamError.packet_out)
  if (_internal_has_packet_out()) {
    clear_has_details();
      ::p4::v1::PacketOutError* temp = details_.packet_out_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    details_.packet_out_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::PacketOutError& StreamError::_internal_packet_out() const {
  return _internal_has_packet_out()
      ? *details_.packet_out_
      : reinterpret_cast< ::p4::v1::PacketOutError&>(::p4::v1::_PacketOutError_default_instance_);
}
inline const ::p4::v1::PacketOutError& StreamError::packet_out() const {
  // @@protoc_insertion_point(field_get:p4.v1.StreamError.packet_out)
  return _internal_packet_out();
}
inline ::p4::v1::PacketOutError* StreamError::unsafe_arena_release_packet_out() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.StreamError.packet_out)
  if (_internal_has_packet_out()) {
    clear_has_details();
    ::p4::v1::PacketOutError* temp = details_.packet_out_;
    details_.packet_out_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamError::unsafe_arena_set_allocated_packet_out(::p4::v1::PacketOutError* packet_out) {
  clear_details();
  if (packet_out) {
    set_has_packet_out();
    details_.packet_out_ = packet_out;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.StreamError.packet_out)
}
inline ::p4::v1::PacketOutError* StreamError::_internal_mutable_packet_out() {
  if (!_internal_has_packet_out()) {
    clear_details();
    set_has_packet_out();
    details_.packet_out_ = CreateMaybeMessage< ::p4::v1::PacketOutError >(GetArenaForAllocation());
  }
  return details_.packet_out_;
}
inline ::p4::v1::PacketOutError* StreamError::mutable_packet_out() {
  ::p4::v1::PacketOutError* _msg = _internal_mutable_packet_out();
  // @@protoc_insertion_point(field_mutable:p4.v1.StreamError.packet_out)
  return _msg;
}

// .p4.v1.DigestListAckError digest_list_ack = 6;
inline bool StreamError::_internal_has_digest_list_ack() const {
  return details_case() == kDigestListAck;
}
inline bool StreamError::has_digest_list_ack() const {
  return _internal_has_digest_list_ack();
}
inline void StreamError::set_has_digest_list_ack() {
  _oneof_case_[0] = kDigestListAck;
}
inline void StreamError::clear_digest_list_ack() {
  if (_internal_has_digest_list_ack()) {
    if (GetArenaForAllocation() == nullptr) {
      delete details_.digest_list_ack_;
    }
    clear_has_details();
  }
}
inline ::p4::v1::DigestListAckError* StreamError::release_digest_list_ack() {
  // @@protoc_insertion_point(field_release:p4.v1.StreamError.digest_list_ack)
  if (_internal_has_digest_list_ack()) {
    clear_has_details();
      ::p4::v1::DigestListAckError* temp = details_.digest_list_ack_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    details_.digest_list_ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::DigestListAckError& StreamError::_internal_digest_list_ack() const {
  return _internal_has_digest_list_ack()
      ? *details_.digest_list_ack_
      : reinterpret_cast< ::p4::v1::DigestListAckError&>(::p4::v1::_DigestListAckError_default_instance_);
}
inline const ::p4::v1::DigestListAckError& StreamError::digest_list_ack() const {
  // @@protoc_insertion_point(field_get:p4.v1.StreamError.digest_list_ack)
  return _internal_digest_list_ack();
}
inline ::p4::v1::DigestListAckError* StreamError::unsafe_arena_release_digest_list_ack() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.StreamError.digest_list_ack)
  if (_internal_has_digest_list_ack()) {
    clear_has_details();
    ::p4::v1::DigestListAckError* temp = details_.digest_list_ack_;
    details_.digest_list_ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamError::unsafe_arena_set_allocated_digest_list_ack(::p4::v1::DigestListAckError* digest_list_ack) {
  clear_details();
  if (digest_list_ack) {
    set_has_digest_list_ack();
    details_.digest_list_ack_ = digest_list_ack;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.StreamError.digest_list_ack)
}
inline ::p4::v1::DigestListAckError* StreamError::_internal_mutable_digest_list_ack() {
  if (!_internal_has_digest_list_ack()) {
    clear_details();
    set_has_digest_list_ack();
    details_.digest_list_ack_ = CreateMaybeMessage< ::p4::v1::DigestListAckError >(GetArenaForAllocation());
  }
  return details_.digest_list_ack_;
}
inline ::p4::v1::DigestListAckError* StreamError::mutable_digest_list_ack() {
  ::p4::v1::DigestListAckError* _msg = _internal_mutable_digest_list_ack();
  // @@protoc_insertion_point(field_mutable:p4.v1.StreamError.digest_list_ack)
  return _msg;
}

// .p4.v1.StreamOtherError other = 7;
inline bool StreamError::_internal_has_other() const {
  return details_case() == kOther;
}
inline bool StreamError::has_other() const {
  return _internal_has_other();
}
inline void StreamError::set_has_other() {
  _oneof_case_[0] = kOther;
}
inline void StreamError::clear_other() {
  if (_internal_has_other()) {
    if (GetArenaForAllocation() == nullptr) {
      delete details_.other_;
    }
    clear_has_details();
  }
}
inline ::p4::v1::StreamOtherError* StreamError::release_other() {
  // @@protoc_insertion_point(field_release:p4.v1.StreamError.other)
  if (_internal_has_other()) {
    clear_has_details();
      ::p4::v1::StreamOtherError* temp = details_.other_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    details_.other_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::p4::v1::StreamOtherError& StreamError::_internal_other() const {
  return _internal_has_other()
      ? *details_.other_
      : reinterpret_cast< ::p4::v1::StreamOtherError&>(::p4::v1::_StreamOtherError_default_instance_);
}
inline const ::p4::v1::StreamOtherError& StreamError::other() const {
  // @@protoc_insertion_point(field_get:p4.v1.StreamError.other)
  return _internal_other();
}
inline ::p4::v1::StreamOtherError* StreamError::unsafe_arena_release_other() {
  // @@protoc_insertion_point(field_unsafe_arena_release:p4.v1.StreamError.other)
  if (_internal_has_other()) {
    clear_has_details();
    ::p4::v1::StreamOtherError* temp = details_.other_;
    details_.other_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamError::unsafe_arena_set_allocated_other(::p4::v1::StreamOtherError* other) {
  clear_details();
  if (other) {
    set_has_other();
    details_.other_ = other;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.StreamError.other)
}
inline ::p4::v1::StreamOtherError* StreamError::_internal_mutable_other() {
  if (!_internal_has_other()) {
    clear_details();
    set_has_other();
    details_.other_ = CreateMaybeMessage< ::p4::v1::StreamOtherError >(GetArenaForAllocation());
  }
  return details_.other_;
}
inline ::p4::v1::StreamOtherError* StreamError::mutable_other() {
  ::p4::v1::StreamOtherError* _msg = _internal_mutable_other();
  // @@protoc_insertion_point(field_mutable:p4.v1.StreamError.other)
  return _msg;
}

inline bool StreamError::has_details() const {
  return details_case() != DETAILS_NOT_SET;
}
inline void StreamError::clear_has_details() {
  _oneof_case_[0] = DETAILS_NOT_SET;
}
inline StreamError::DetailsCase StreamError::details_case() const {
  return StreamError::DetailsCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PacketOutError

// .p4.v1.PacketOut packet_out = 1;
inline bool PacketOutError::_internal_has_packet_out() const {
  return this != internal_default_instance() && packet_out_ != nullptr;
}
inline bool PacketOutError::has_packet_out() const {
  return _internal_has_packet_out();
}
inline void PacketOutError::clear_packet_out() {
  if (GetArenaForAllocation() == nullptr && packet_out_ != nullptr) {
    delete packet_out_;
  }
  packet_out_ = nullptr;
}
inline const ::p4::v1::PacketOut& PacketOutError::_internal_packet_out() const {
  const ::p4::v1::PacketOut* p = packet_out_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::PacketOut&>(
      ::p4::v1::_PacketOut_default_instance_);
}
inline const ::p4::v1::PacketOut& PacketOutError::packet_out() const {
  // @@protoc_insertion_point(field_get:p4.v1.PacketOutError.packet_out)
  return _internal_packet_out();
}
inline void PacketOutError::unsafe_arena_set_allocated_packet_out(
    ::p4::v1::PacketOut* packet_out) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(packet_out_);
  }
  packet_out_ = packet_out;
  if (packet_out) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.PacketOutError.packet_out)
}
inline ::p4::v1::PacketOut* PacketOutError::release_packet_out() {
  
  ::p4::v1::PacketOut* temp = packet_out_;
  packet_out_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::PacketOut* PacketOutError::unsafe_arena_release_packet_out() {
  // @@protoc_insertion_point(field_release:p4.v1.PacketOutError.packet_out)
  
  ::p4::v1::PacketOut* temp = packet_out_;
  packet_out_ = nullptr;
  return temp;
}
inline ::p4::v1::PacketOut* PacketOutError::_internal_mutable_packet_out() {
  
  if (packet_out_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::PacketOut>(GetArenaForAllocation());
    packet_out_ = p;
  }
  return packet_out_;
}
inline ::p4::v1::PacketOut* PacketOutError::mutable_packet_out() {
  ::p4::v1::PacketOut* _msg = _internal_mutable_packet_out();
  // @@protoc_insertion_point(field_mutable:p4.v1.PacketOutError.packet_out)
  return _msg;
}
inline void PacketOutError::set_allocated_packet_out(::p4::v1::PacketOut* packet_out) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete packet_out_;
  }
  if (packet_out) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::PacketOut>::GetOwningArena(packet_out);
    if (message_arena != submessage_arena) {
      packet_out = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, packet_out, submessage_arena);
    }
    
  } else {
    
  }
  packet_out_ = packet_out;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.PacketOutError.packet_out)
}

// -------------------------------------------------------------------

// DigestListAckError

// .p4.v1.DigestListAck digest_list_ack = 1;
inline bool DigestListAckError::_internal_has_digest_list_ack() const {
  return this != internal_default_instance() && digest_list_ack_ != nullptr;
}
inline bool DigestListAckError::has_digest_list_ack() const {
  return _internal_has_digest_list_ack();
}
inline void DigestListAckError::clear_digest_list_ack() {
  if (GetArenaForAllocation() == nullptr && digest_list_ack_ != nullptr) {
    delete digest_list_ack_;
  }
  digest_list_ack_ = nullptr;
}
inline const ::p4::v1::DigestListAck& DigestListAckError::_internal_digest_list_ack() const {
  const ::p4::v1::DigestListAck* p = digest_list_ack_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::DigestListAck&>(
      ::p4::v1::_DigestListAck_default_instance_);
}
inline const ::p4::v1::DigestListAck& DigestListAckError::digest_list_ack() const {
  // @@protoc_insertion_point(field_get:p4.v1.DigestListAckError.digest_list_ack)
  return _internal_digest_list_ack();
}
inline void DigestListAckError::unsafe_arena_set_allocated_digest_list_ack(
    ::p4::v1::DigestListAck* digest_list_ack) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(digest_list_ack_);
  }
  digest_list_ack_ = digest_list_ack;
  if (digest_list_ack) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.DigestListAckError.digest_list_ack)
}
inline ::p4::v1::DigestListAck* DigestListAckError::release_digest_list_ack() {
  
  ::p4::v1::DigestListAck* temp = digest_list_ack_;
  digest_list_ack_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::DigestListAck* DigestListAckError::unsafe_arena_release_digest_list_ack() {
  // @@protoc_insertion_point(field_release:p4.v1.DigestListAckError.digest_list_ack)
  
  ::p4::v1::DigestListAck* temp = digest_list_ack_;
  digest_list_ack_ = nullptr;
  return temp;
}
inline ::p4::v1::DigestListAck* DigestListAckError::_internal_mutable_digest_list_ack() {
  
  if (digest_list_ack_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::DigestListAck>(GetArenaForAllocation());
    digest_list_ack_ = p;
  }
  return digest_list_ack_;
}
inline ::p4::v1::DigestListAck* DigestListAckError::mutable_digest_list_ack() {
  ::p4::v1::DigestListAck* _msg = _internal_mutable_digest_list_ack();
  // @@protoc_insertion_point(field_mutable:p4.v1.DigestListAckError.digest_list_ack)
  return _msg;
}
inline void DigestListAckError::set_allocated_digest_list_ack(::p4::v1::DigestListAck* digest_list_ack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete digest_list_ack_;
  }
  if (digest_list_ack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::DigestListAck>::GetOwningArena(digest_list_ack);
    if (message_arena != submessage_arena) {
      digest_list_ack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, digest_list_ack, submessage_arena);
    }
    
  } else {
    
  }
  digest_list_ack_ = digest_list_ack;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.DigestListAckError.digest_list_ack)
}

// -------------------------------------------------------------------

// StreamOtherError

// .google.protobuf.Any other = 1;
inline bool StreamOtherError::_internal_has_other() const {
  return this != internal_default_instance() && other_ != nullptr;
}
inline bool StreamOtherError::has_other() const {
  return _internal_has_other();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& StreamOtherError::_internal_other() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = other_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& StreamOtherError::other() const {
  // @@protoc_insertion_point(field_get:p4.v1.StreamOtherError.other)
  return _internal_other();
}
inline void StreamOtherError::unsafe_arena_set_allocated_other(
    ::PROTOBUF_NAMESPACE_ID::Any* other) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(other_);
  }
  other_ = other;
  if (other) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.StreamOtherError.other)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* StreamOtherError::release_other() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = other_;
  other_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* StreamOtherError::unsafe_arena_release_other() {
  // @@protoc_insertion_point(field_release:p4.v1.StreamOtherError.other)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = other_;
  other_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* StreamOtherError::_internal_mutable_other() {
  
  if (other_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    other_ = p;
  }
  return other_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* StreamOtherError::mutable_other() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_other();
  // @@protoc_insertion_point(field_mutable:p4.v1.StreamOtherError.other)
  return _msg;
}
inline void StreamOtherError::set_allocated_other(::PROTOBUF_NAMESPACE_ID::Any* other) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(other_);
  }
  if (other) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(other));
    if (message_arena != submessage_arena) {
      other = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, other, submessage_arena);
    }
    
  } else {
    
  }
  other_ = other;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.StreamOtherError.other)
}

// -------------------------------------------------------------------

// Uint128

// uint64 high = 1;
inline void Uint128::clear_high() {
  high_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Uint128::_internal_high() const {
  return high_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Uint128::high() const {
  // @@protoc_insertion_point(field_get:p4.v1.Uint128.high)
  return _internal_high();
}
inline void Uint128::_internal_set_high(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  high_ = value;
}
inline void Uint128::set_high(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_high(value);
  // @@protoc_insertion_point(field_set:p4.v1.Uint128.high)
}

// uint64 low = 2;
inline void Uint128::clear_low() {
  low_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Uint128::_internal_low() const {
  return low_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Uint128::low() const {
  // @@protoc_insertion_point(field_get:p4.v1.Uint128.low)
  return _internal_low();
}
inline void Uint128::_internal_set_low(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  low_ = value;
}
inline void Uint128::set_low(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_low(value);
  // @@protoc_insertion_point(field_set:p4.v1.Uint128.low)
}

// -------------------------------------------------------------------

// SetForwardingPipelineConfigRequest

// uint64 device_id = 1;
inline void SetForwardingPipelineConfigRequest::clear_device_id() {
  device_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SetForwardingPipelineConfigRequest::_internal_device_id() const {
  return device_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SetForwardingPipelineConfigRequest::device_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.SetForwardingPipelineConfigRequest.device_id)
  return _internal_device_id();
}
inline void SetForwardingPipelineConfigRequest::_internal_set_device_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  device_id_ = value;
}
inline void SetForwardingPipelineConfigRequest::set_device_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.SetForwardingPipelineConfigRequest.device_id)
}

// uint64 role_id = 2;
inline void SetForwardingPipelineConfigRequest::clear_role_id() {
  role_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SetForwardingPipelineConfigRequest::_internal_role_id() const {
  return role_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SetForwardingPipelineConfigRequest::role_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.SetForwardingPipelineConfigRequest.role_id)
  return _internal_role_id();
}
inline void SetForwardingPipelineConfigRequest::_internal_set_role_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  role_id_ = value;
}
inline void SetForwardingPipelineConfigRequest::set_role_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_role_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.SetForwardingPipelineConfigRequest.role_id)
}

// .p4.v1.Uint128 election_id = 3;
inline bool SetForwardingPipelineConfigRequest::_internal_has_election_id() const {
  return this != internal_default_instance() && election_id_ != nullptr;
}
inline bool SetForwardingPipelineConfigRequest::has_election_id() const {
  return _internal_has_election_id();
}
inline void SetForwardingPipelineConfigRequest::clear_election_id() {
  if (GetArenaForAllocation() == nullptr && election_id_ != nullptr) {
    delete election_id_;
  }
  election_id_ = nullptr;
}
inline const ::p4::v1::Uint128& SetForwardingPipelineConfigRequest::_internal_election_id() const {
  const ::p4::v1::Uint128* p = election_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::Uint128&>(
      ::p4::v1::_Uint128_default_instance_);
}
inline const ::p4::v1::Uint128& SetForwardingPipelineConfigRequest::election_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.SetForwardingPipelineConfigRequest.election_id)
  return _internal_election_id();
}
inline void SetForwardingPipelineConfigRequest::unsafe_arena_set_allocated_election_id(
    ::p4::v1::Uint128* election_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(election_id_);
  }
  election_id_ = election_id;
  if (election_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.SetForwardingPipelineConfigRequest.election_id)
}
inline ::p4::v1::Uint128* SetForwardingPipelineConfigRequest::release_election_id() {
  
  ::p4::v1::Uint128* temp = election_id_;
  election_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::Uint128* SetForwardingPipelineConfigRequest::unsafe_arena_release_election_id() {
  // @@protoc_insertion_point(field_release:p4.v1.SetForwardingPipelineConfigRequest.election_id)
  
  ::p4::v1::Uint128* temp = election_id_;
  election_id_ = nullptr;
  return temp;
}
inline ::p4::v1::Uint128* SetForwardingPipelineConfigRequest::_internal_mutable_election_id() {
  
  if (election_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::Uint128>(GetArenaForAllocation());
    election_id_ = p;
  }
  return election_id_;
}
inline ::p4::v1::Uint128* SetForwardingPipelineConfigRequest::mutable_election_id() {
  ::p4::v1::Uint128* _msg = _internal_mutable_election_id();
  // @@protoc_insertion_point(field_mutable:p4.v1.SetForwardingPipelineConfigRequest.election_id)
  return _msg;
}
inline void SetForwardingPipelineConfigRequest::set_allocated_election_id(::p4::v1::Uint128* election_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete election_id_;
  }
  if (election_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::Uint128>::GetOwningArena(election_id);
    if (message_arena != submessage_arena) {
      election_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, election_id, submessage_arena);
    }
    
  } else {
    
  }
  election_id_ = election_id;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.SetForwardingPipelineConfigRequest.election_id)
}

// .p4.v1.SetForwardingPipelineConfigRequest.Action action = 4;
inline void SetForwardingPipelineConfigRequest::clear_action() {
  action_ = 0;
}
inline ::p4::v1::SetForwardingPipelineConfigRequest_Action SetForwardingPipelineConfigRequest::_internal_action() const {
  return static_cast< ::p4::v1::SetForwardingPipelineConfigRequest_Action >(action_);
}
inline ::p4::v1::SetForwardingPipelineConfigRequest_Action SetForwardingPipelineConfigRequest::action() const {
  // @@protoc_insertion_point(field_get:p4.v1.SetForwardingPipelineConfigRequest.action)
  return _internal_action();
}
inline void SetForwardingPipelineConfigRequest::_internal_set_action(::p4::v1::SetForwardingPipelineConfigRequest_Action value) {
  
  action_ = value;
}
inline void SetForwardingPipelineConfigRequest::set_action(::p4::v1::SetForwardingPipelineConfigRequest_Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:p4.v1.SetForwardingPipelineConfigRequest.action)
}

// .p4.v1.ForwardingPipelineConfig config = 5;
inline bool SetForwardingPipelineConfigRequest::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool SetForwardingPipelineConfigRequest::has_config() const {
  return _internal_has_config();
}
inline void SetForwardingPipelineConfigRequest::clear_config() {
  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::p4::v1::ForwardingPipelineConfig& SetForwardingPipelineConfigRequest::_internal_config() const {
  const ::p4::v1::ForwardingPipelineConfig* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::ForwardingPipelineConfig&>(
      ::p4::v1::_ForwardingPipelineConfig_default_instance_);
}
inline const ::p4::v1::ForwardingPipelineConfig& SetForwardingPipelineConfigRequest::config() const {
  // @@protoc_insertion_point(field_get:p4.v1.SetForwardingPipelineConfigRequest.config)
  return _internal_config();
}
inline void SetForwardingPipelineConfigRequest::unsafe_arena_set_allocated_config(
    ::p4::v1::ForwardingPipelineConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.SetForwardingPipelineConfigRequest.config)
}
inline ::p4::v1::ForwardingPipelineConfig* SetForwardingPipelineConfigRequest::release_config() {
  
  ::p4::v1::ForwardingPipelineConfig* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::ForwardingPipelineConfig* SetForwardingPipelineConfigRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:p4.v1.SetForwardingPipelineConfigRequest.config)
  
  ::p4::v1::ForwardingPipelineConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::p4::v1::ForwardingPipelineConfig* SetForwardingPipelineConfigRequest::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::ForwardingPipelineConfig>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::p4::v1::ForwardingPipelineConfig* SetForwardingPipelineConfigRequest::mutable_config() {
  ::p4::v1::ForwardingPipelineConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:p4.v1.SetForwardingPipelineConfigRequest.config)
  return _msg;
}
inline void SetForwardingPipelineConfigRequest::set_allocated_config(::p4::v1::ForwardingPipelineConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::ForwardingPipelineConfig>::GetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.SetForwardingPipelineConfigRequest.config)
}

// -------------------------------------------------------------------

// SetForwardingPipelineConfigResponse

// -------------------------------------------------------------------

// ForwardingPipelineConfig_Cookie

// uint64 cookie = 1;
inline void ForwardingPipelineConfig_Cookie::clear_cookie() {
  cookie_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ForwardingPipelineConfig_Cookie::_internal_cookie() const {
  return cookie_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ForwardingPipelineConfig_Cookie::cookie() const {
  // @@protoc_insertion_point(field_get:p4.v1.ForwardingPipelineConfig.Cookie.cookie)
  return _internal_cookie();
}
inline void ForwardingPipelineConfig_Cookie::_internal_set_cookie(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  cookie_ = value;
}
inline void ForwardingPipelineConfig_Cookie::set_cookie(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_cookie(value);
  // @@protoc_insertion_point(field_set:p4.v1.ForwardingPipelineConfig.Cookie.cookie)
}

// -------------------------------------------------------------------

// ForwardingPipelineConfig

// .p4.config.v1.P4Info p4info = 1;
inline bool ForwardingPipelineConfig::_internal_has_p4info() const {
  return this != internal_default_instance() && p4info_ != nullptr;
}
inline bool ForwardingPipelineConfig::has_p4info() const {
  return _internal_has_p4info();
}
inline const ::p4::config::v1::P4Info& ForwardingPipelineConfig::_internal_p4info() const {
  const ::p4::config::v1::P4Info* p = p4info_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::config::v1::P4Info&>(
      ::p4::config::v1::_P4Info_default_instance_);
}
inline const ::p4::config::v1::P4Info& ForwardingPipelineConfig::p4info() const {
  // @@protoc_insertion_point(field_get:p4.v1.ForwardingPipelineConfig.p4info)
  return _internal_p4info();
}
inline void ForwardingPipelineConfig::unsafe_arena_set_allocated_p4info(
    ::p4::config::v1::P4Info* p4info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(p4info_);
  }
  p4info_ = p4info;
  if (p4info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.ForwardingPipelineConfig.p4info)
}
inline ::p4::config::v1::P4Info* ForwardingPipelineConfig::release_p4info() {
  
  ::p4::config::v1::P4Info* temp = p4info_;
  p4info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::config::v1::P4Info* ForwardingPipelineConfig::unsafe_arena_release_p4info() {
  // @@protoc_insertion_point(field_release:p4.v1.ForwardingPipelineConfig.p4info)
  
  ::p4::config::v1::P4Info* temp = p4info_;
  p4info_ = nullptr;
  return temp;
}
inline ::p4::config::v1::P4Info* ForwardingPipelineConfig::_internal_mutable_p4info() {
  
  if (p4info_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::config::v1::P4Info>(GetArenaForAllocation());
    p4info_ = p;
  }
  return p4info_;
}
inline ::p4::config::v1::P4Info* ForwardingPipelineConfig::mutable_p4info() {
  ::p4::config::v1::P4Info* _msg = _internal_mutable_p4info();
  // @@protoc_insertion_point(field_mutable:p4.v1.ForwardingPipelineConfig.p4info)
  return _msg;
}
inline void ForwardingPipelineConfig::set_allocated_p4info(::p4::config::v1::P4Info* p4info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(p4info_);
  }
  if (p4info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(p4info));
    if (message_arena != submessage_arena) {
      p4info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, p4info, submessage_arena);
    }
    
  } else {
    
  }
  p4info_ = p4info;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.ForwardingPipelineConfig.p4info)
}

// bytes p4_device_config = 2;
inline void ForwardingPipelineConfig::clear_p4_device_config() {
  p4_device_config_.ClearToEmpty();
}
inline const std::string& ForwardingPipelineConfig::p4_device_config() const {
  // @@protoc_insertion_point(field_get:p4.v1.ForwardingPipelineConfig.p4_device_config)
  return _internal_p4_device_config();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ForwardingPipelineConfig::set_p4_device_config(ArgT0&& arg0, ArgT... args) {
 
 p4_device_config_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.ForwardingPipelineConfig.p4_device_config)
}
inline std::string* ForwardingPipelineConfig::mutable_p4_device_config() {
  std::string* _s = _internal_mutable_p4_device_config();
  // @@protoc_insertion_point(field_mutable:p4.v1.ForwardingPipelineConfig.p4_device_config)
  return _s;
}
inline const std::string& ForwardingPipelineConfig::_internal_p4_device_config() const {
  return p4_device_config_.Get();
}
inline void ForwardingPipelineConfig::_internal_set_p4_device_config(const std::string& value) {
  
  p4_device_config_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ForwardingPipelineConfig::_internal_mutable_p4_device_config() {
  
  return p4_device_config_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ForwardingPipelineConfig::release_p4_device_config() {
  // @@protoc_insertion_point(field_release:p4.v1.ForwardingPipelineConfig.p4_device_config)
  return p4_device_config_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ForwardingPipelineConfig::set_allocated_p4_device_config(std::string* p4_device_config) {
  if (p4_device_config != nullptr) {
    
  } else {
    
  }
  p4_device_config_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), p4_device_config,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.ForwardingPipelineConfig.p4_device_config)
}

// .p4.v1.ForwardingPipelineConfig.Cookie cookie = 3;
inline bool ForwardingPipelineConfig::_internal_has_cookie() const {
  return this != internal_default_instance() && cookie_ != nullptr;
}
inline bool ForwardingPipelineConfig::has_cookie() const {
  return _internal_has_cookie();
}
inline void ForwardingPipelineConfig::clear_cookie() {
  if (GetArenaForAllocation() == nullptr && cookie_ != nullptr) {
    delete cookie_;
  }
  cookie_ = nullptr;
}
inline const ::p4::v1::ForwardingPipelineConfig_Cookie& ForwardingPipelineConfig::_internal_cookie() const {
  const ::p4::v1::ForwardingPipelineConfig_Cookie* p = cookie_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::ForwardingPipelineConfig_Cookie&>(
      ::p4::v1::_ForwardingPipelineConfig_Cookie_default_instance_);
}
inline const ::p4::v1::ForwardingPipelineConfig_Cookie& ForwardingPipelineConfig::cookie() const {
  // @@protoc_insertion_point(field_get:p4.v1.ForwardingPipelineConfig.cookie)
  return _internal_cookie();
}
inline void ForwardingPipelineConfig::unsafe_arena_set_allocated_cookie(
    ::p4::v1::ForwardingPipelineConfig_Cookie* cookie) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cookie_);
  }
  cookie_ = cookie;
  if (cookie) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.ForwardingPipelineConfig.cookie)
}
inline ::p4::v1::ForwardingPipelineConfig_Cookie* ForwardingPipelineConfig::release_cookie() {
  
  ::p4::v1::ForwardingPipelineConfig_Cookie* temp = cookie_;
  cookie_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::ForwardingPipelineConfig_Cookie* ForwardingPipelineConfig::unsafe_arena_release_cookie() {
  // @@protoc_insertion_point(field_release:p4.v1.ForwardingPipelineConfig.cookie)
  
  ::p4::v1::ForwardingPipelineConfig_Cookie* temp = cookie_;
  cookie_ = nullptr;
  return temp;
}
inline ::p4::v1::ForwardingPipelineConfig_Cookie* ForwardingPipelineConfig::_internal_mutable_cookie() {
  
  if (cookie_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::ForwardingPipelineConfig_Cookie>(GetArenaForAllocation());
    cookie_ = p;
  }
  return cookie_;
}
inline ::p4::v1::ForwardingPipelineConfig_Cookie* ForwardingPipelineConfig::mutable_cookie() {
  ::p4::v1::ForwardingPipelineConfig_Cookie* _msg = _internal_mutable_cookie();
  // @@protoc_insertion_point(field_mutable:p4.v1.ForwardingPipelineConfig.cookie)
  return _msg;
}
inline void ForwardingPipelineConfig::set_allocated_cookie(::p4::v1::ForwardingPipelineConfig_Cookie* cookie) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cookie_;
  }
  if (cookie) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::ForwardingPipelineConfig_Cookie>::GetOwningArena(cookie);
    if (message_arena != submessage_arena) {
      cookie = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cookie, submessage_arena);
    }
    
  } else {
    
  }
  cookie_ = cookie;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.ForwardingPipelineConfig.cookie)
}

// -------------------------------------------------------------------

// GetForwardingPipelineConfigRequest

// uint64 device_id = 1;
inline void GetForwardingPipelineConfigRequest::clear_device_id() {
  device_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetForwardingPipelineConfigRequest::_internal_device_id() const {
  return device_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetForwardingPipelineConfigRequest::device_id() const {
  // @@protoc_insertion_point(field_get:p4.v1.GetForwardingPipelineConfigRequest.device_id)
  return _internal_device_id();
}
inline void GetForwardingPipelineConfigRequest::_internal_set_device_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  device_id_ = value;
}
inline void GetForwardingPipelineConfigRequest::set_device_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:p4.v1.GetForwardingPipelineConfigRequest.device_id)
}

// .p4.v1.GetForwardingPipelineConfigRequest.ResponseType response_type = 2;
inline void GetForwardingPipelineConfigRequest::clear_response_type() {
  response_type_ = 0;
}
inline ::p4::v1::GetForwardingPipelineConfigRequest_ResponseType GetForwardingPipelineConfigRequest::_internal_response_type() const {
  return static_cast< ::p4::v1::GetForwardingPipelineConfigRequest_ResponseType >(response_type_);
}
inline ::p4::v1::GetForwardingPipelineConfigRequest_ResponseType GetForwardingPipelineConfigRequest::response_type() const {
  // @@protoc_insertion_point(field_get:p4.v1.GetForwardingPipelineConfigRequest.response_type)
  return _internal_response_type();
}
inline void GetForwardingPipelineConfigRequest::_internal_set_response_type(::p4::v1::GetForwardingPipelineConfigRequest_ResponseType value) {
  
  response_type_ = value;
}
inline void GetForwardingPipelineConfigRequest::set_response_type(::p4::v1::GetForwardingPipelineConfigRequest_ResponseType value) {
  _internal_set_response_type(value);
  // @@protoc_insertion_point(field_set:p4.v1.GetForwardingPipelineConfigRequest.response_type)
}

// -------------------------------------------------------------------

// GetForwardingPipelineConfigResponse

// .p4.v1.ForwardingPipelineConfig config = 1;
inline bool GetForwardingPipelineConfigResponse::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool GetForwardingPipelineConfigResponse::has_config() const {
  return _internal_has_config();
}
inline void GetForwardingPipelineConfigResponse::clear_config() {
  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::p4::v1::ForwardingPipelineConfig& GetForwardingPipelineConfigResponse::_internal_config() const {
  const ::p4::v1::ForwardingPipelineConfig* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::p4::v1::ForwardingPipelineConfig&>(
      ::p4::v1::_ForwardingPipelineConfig_default_instance_);
}
inline const ::p4::v1::ForwardingPipelineConfig& GetForwardingPipelineConfigResponse::config() const {
  // @@protoc_insertion_point(field_get:p4.v1.GetForwardingPipelineConfigResponse.config)
  return _internal_config();
}
inline void GetForwardingPipelineConfigResponse::unsafe_arena_set_allocated_config(
    ::p4::v1::ForwardingPipelineConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.GetForwardingPipelineConfigResponse.config)
}
inline ::p4::v1::ForwardingPipelineConfig* GetForwardingPipelineConfigResponse::release_config() {
  
  ::p4::v1::ForwardingPipelineConfig* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p4::v1::ForwardingPipelineConfig* GetForwardingPipelineConfigResponse::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:p4.v1.GetForwardingPipelineConfigResponse.config)
  
  ::p4::v1::ForwardingPipelineConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::p4::v1::ForwardingPipelineConfig* GetForwardingPipelineConfigResponse::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::p4::v1::ForwardingPipelineConfig>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::p4::v1::ForwardingPipelineConfig* GetForwardingPipelineConfigResponse::mutable_config() {
  ::p4::v1::ForwardingPipelineConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:p4.v1.GetForwardingPipelineConfigResponse.config)
  return _msg;
}
inline void GetForwardingPipelineConfigResponse::set_allocated_config(::p4::v1::ForwardingPipelineConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::p4::v1::ForwardingPipelineConfig>::GetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.GetForwardingPipelineConfigResponse.config)
}

// -------------------------------------------------------------------

// Error

// int32 canonical_code = 1;
inline void Error::clear_canonical_code() {
  canonical_code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Error::_internal_canonical_code() const {
  return canonical_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Error::canonical_code() const {
  // @@protoc_insertion_point(field_get:p4.v1.Error.canonical_code)
  return _internal_canonical_code();
}
inline void Error::_internal_set_canonical_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  canonical_code_ = value;
}
inline void Error::set_canonical_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_canonical_code(value);
  // @@protoc_insertion_point(field_set:p4.v1.Error.canonical_code)
}

// string message = 2;
inline void Error::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:p4.v1.Error.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.Error.message)
}
inline std::string* Error::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:p4.v1.Error.message)
  return _s;
}
inline const std::string& Error::_internal_message() const {
  return message_.Get();
}
inline void Error::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:p4.v1.Error.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Error::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.Error.message)
}

// string space = 3;
inline void Error::clear_space() {
  space_.ClearToEmpty();
}
inline const std::string& Error::space() const {
  // @@protoc_insertion_point(field_get:p4.v1.Error.space)
  return _internal_space();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_space(ArgT0&& arg0, ArgT... args) {
 
 space_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.Error.space)
}
inline std::string* Error::mutable_space() {
  std::string* _s = _internal_mutable_space();
  // @@protoc_insertion_point(field_mutable:p4.v1.Error.space)
  return _s;
}
inline const std::string& Error::_internal_space() const {
  return space_.Get();
}
inline void Error::_internal_set_space(const std::string& value) {
  
  space_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_space() {
  
  return space_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Error::release_space() {
  // @@protoc_insertion_point(field_release:p4.v1.Error.space)
  return space_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Error::set_allocated_space(std::string* space) {
  if (space != nullptr) {
    
  } else {
    
  }
  space_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), space,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.Error.space)
}

// int32 code = 4;
inline void Error::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Error::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Error::code() const {
  // @@protoc_insertion_point(field_get:p4.v1.Error.code)
  return _internal_code();
}
inline void Error::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void Error::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:p4.v1.Error.code)
}

// .google.protobuf.Any details = 5;
inline bool Error::_internal_has_details() const {
  return this != internal_default_instance() && details_ != nullptr;
}
inline bool Error::has_details() const {
  return _internal_has_details();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Error::_internal_details() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = details_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Error::details() const {
  // @@protoc_insertion_point(field_get:p4.v1.Error.details)
  return _internal_details();
}
inline void Error::unsafe_arena_set_allocated_details(
    ::PROTOBUF_NAMESPACE_ID::Any* details) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(details_);
  }
  details_ = details;
  if (details) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p4.v1.Error.details)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Error::release_details() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = details_;
  details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Error::unsafe_arena_release_details() {
  // @@protoc_insertion_point(field_release:p4.v1.Error.details)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = details_;
  details_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Error::_internal_mutable_details() {
  
  if (details_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    details_ = p;
  }
  return details_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Error::mutable_details() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_details();
  // @@protoc_insertion_point(field_mutable:p4.v1.Error.details)
  return _msg;
}
inline void Error::set_allocated_details(::PROTOBUF_NAMESPACE_ID::Any* details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(details_);
  }
  if (details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(details));
    if (message_arena != submessage_arena) {
      details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, details, submessage_arena);
    }
    
  } else {
    
  }
  details_ = details;
  // @@protoc_insertion_point(field_set_allocated:p4.v1.Error.details)
}

// -------------------------------------------------------------------

// CapabilitiesRequest

// -------------------------------------------------------------------

// CapabilitiesResponse

// string p4runtime_api_version = 1;
inline void CapabilitiesResponse::clear_p4runtime_api_version() {
  p4runtime_api_version_.ClearToEmpty();
}
inline const std::string& CapabilitiesResponse::p4runtime_api_version() const {
  // @@protoc_insertion_point(field_get:p4.v1.CapabilitiesResponse.p4runtime_api_version)
  return _internal_p4runtime_api_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CapabilitiesResponse::set_p4runtime_api_version(ArgT0&& arg0, ArgT... args) {
 
 p4runtime_api_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p4.v1.CapabilitiesResponse.p4runtime_api_version)
}
inline std::string* CapabilitiesResponse::mutable_p4runtime_api_version() {
  std::string* _s = _internal_mutable_p4runtime_api_version();
  // @@protoc_insertion_point(field_mutable:p4.v1.CapabilitiesResponse.p4runtime_api_version)
  return _s;
}
inline const std::string& CapabilitiesResponse::_internal_p4runtime_api_version() const {
  return p4runtime_api_version_.Get();
}
inline void CapabilitiesResponse::_internal_set_p4runtime_api_version(const std::string& value) {
  
  p4runtime_api_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CapabilitiesResponse::_internal_mutable_p4runtime_api_version() {
  
  return p4runtime_api_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CapabilitiesResponse::release_p4runtime_api_version() {
  // @@protoc_insertion_point(field_release:p4.v1.CapabilitiesResponse.p4runtime_api_version)
  return p4runtime_api_version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CapabilitiesResponse::set_allocated_p4runtime_api_version(std::string* p4runtime_api_version) {
  if (p4runtime_api_version != nullptr) {
    
  } else {
    
  }
  p4runtime_api_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), p4runtime_api_version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:p4.v1.CapabilitiesResponse.p4runtime_api_version)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace p4

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::p4::v1::WriteRequest_Atomicity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::p4::v1::WriteRequest_Atomicity>() {
  return ::p4::v1::WriteRequest_Atomicity_descriptor();
}
template <> struct is_proto_enum< ::p4::v1::Update_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::p4::v1::Update_Type>() {
  return ::p4::v1::Update_Type_descriptor();
}
template <> struct is_proto_enum< ::p4::v1::RuntimeReconfigEntry_RuntimeReconfigType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::p4::v1::RuntimeReconfigEntry_RuntimeReconfigType>() {
  return ::p4::v1::RuntimeReconfigEntry_RuntimeReconfigType_descriptor();
}
template <> struct is_proto_enum< ::p4::v1::ChangeRegisterArrayEntry_RegisterArrayChangeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::p4::v1::ChangeRegisterArrayEntry_RegisterArrayChangeType>() {
  return ::p4::v1::ChangeRegisterArrayEntry_RegisterArrayChangeType_descriptor();
}
template <> struct is_proto_enum< ::p4::v1::SetForwardingPipelineConfigRequest_Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::p4::v1::SetForwardingPipelineConfigRequest_Action>() {
  return ::p4::v1::SetForwardingPipelineConfigRequest_Action_descriptor();
}
template <> struct is_proto_enum< ::p4::v1::GetForwardingPipelineConfigRequest_ResponseType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::p4::v1::GetForwardingPipelineConfigRequest_ResponseType>() {
  return ::p4::v1::GetForwardingPipelineConfigRequest_ResponseType_descriptor();
}
template <> struct is_proto_enum< ::p4::v1::SdnPort> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::p4::v1::SdnPort>() {
  return ::p4::v1::SdnPort_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_p4_2fv1_2fp4runtime_2eproto
